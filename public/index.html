<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task Master</title>
    <link rel="icon" type="image/png" href="/favicon/favicon.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Allow text selection in input fields and textareas */
        input,
        textarea {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #f0f4f8 0%, #e2e8f0 100%);
            height: 100vh;
            overflow: hidden;
            color: #1e293b;
            line-height: 1.6;
        }

        .container {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        /* App Header */
        .app-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: #ffffff;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            z-index: 1000;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            box-sizing: border-box;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .header-title {
            font-size: 20px;
            font-weight: 700;
            color: #0f172a;
            margin: 0;
        }

        .header-user {
            font-size: 14px;
            color: #64748b;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .add-task-btn, .profile-btn {
            padding: 8px 16px;
            border: 1px solid #e2e8f0;
            background: #ffffff;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #475569;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .add-task-btn:hover, .profile-btn:hover {
            background: #f8fafc;
            border-color: #cbd5e1;
        }

        .add-task-btn svg {
            width: 16px;
            height: 16px;
        }

        /* Workspace */
        .workspace {
            display: grid;
            grid-template-columns: 280px 1fr 1fr;
            grid-template-rows: 1fr;
            gap: 16px;
            padding: 16px;
            flex: 1;
            min-height: 0;
            overflow: hidden;
            height: calc(100vh - 60px);
            margin-top: 60px;
        }

        /* Left Column */
        .left-column {
            display: grid;
            grid-template-rows: 1fr 1fr;
            gap: 16px;
            height: 100%;
        }

        /* Floating Window Styles */
        .floating-window {
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(0, 0, 0, 0.08);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: box-shadow 0.2s ease;
            border: 1px solid rgba(226, 232, 240, 0.8);
            height: calc(100vh - 92px);
            max-height: calc(100vh - 92px);
        }

        .floating-window:hover {
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.15), 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .window-header {
            background: linear-gradient(135deg, #f8fafc 0%, #ffffff 100%);
            padding: 14px 18px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            flex-shrink: 0;
            height: 52px;
            box-sizing: border-box;
        }

        .window-title {
            font-size: 15px;
            font-weight: 600;
            color: #0f172a;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .window-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 20px;
            min-height: 0;
            height: calc(100vh - 92px - 52px);
            max-height: calc(100vh - 92px - 52px);
        }

        /* Task Creation Window */
        .task-creation-window {
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 100;
        }

        /* Profile Window */
        .profile-window {
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* Calendar Window */
        .calendar-window {
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* Task List Window */
        .task-list-window {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #taskList {
            flex: 1;
            overflow-y: auto;
            padding-right: 8px;
        }

        /* Custom Scrollbar */
        .left-panel::-webkit-scrollbar,
        .right-panel::-webkit-scrollbar,
        #taskList::-webkit-scrollbar {
            width: 8px;
        }

        .left-panel::-webkit-scrollbar-track,
        .right-panel::-webkit-scrollbar-track,
        #taskList::-webkit-scrollbar-track {
            background: transparent;
        }

        .left-panel::-webkit-scrollbar-thumb,
        .right-panel::-webkit-scrollbar-thumb,
        #taskList::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }

        .left-panel::-webkit-scrollbar-thumb:hover,
        .right-panel::-webkit-scrollbar-thumb:hover,
        #taskList::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        h1 {
            margin-bottom: 8px;
            color: #0f172a;
            font-size: 32px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        h2 {
            margin-bottom: 24px;
            color: #1e293b;
            font-size: 20px;
            font-weight: 600;
            letter-spacing: -0.3px;
        }

        .form-container {
            background: #ffffff;
            padding: 32px;
            border-radius: 16px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05), 0 1px 2px rgba(0,0,0,0.1);
            border: 1px solid #e2e8f0;
            margin-bottom: 24px;
        }

        .form-group {
            margin-bottom: 24px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 14px;
            color: #475569;
        }

        input, select {
            width: 100%;
            padding: 12px 16px;
            border: 1.5px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.2s ease;
            background: #ffffff;
            color: #1e293b;
            box-sizing: border-box;
            height: 40px; /* altura fija compartida (Title, Date, Time, etc.) */
        }

        textarea {
            width: 100%;
            padding: 12px 16px;
            border: 1.5px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.2s ease;
            background: #ffffff;
            color: #1e293b;
            box-sizing: border-box;
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        textarea {
            resize: vertical;
            min-height: 80px;
            font-family: inherit;
        }

        #taskDescription {
            resize: none;
            line-height: 1.5;
            overflow-y: auto;
            box-sizing: border-box;
            padding-right: 24px; /* Extra padding to accommodate scrollbar */
            scrollbar-width: thin; /* Firefox */
            scrollbar-color: #cbd5e1 transparent; /* Firefox */
        }

        /* Custom scrollbar for task description to maintain padding and rounded corners */
        #taskDescription::-webkit-scrollbar {
            width: 8px;
        }

        #taskDescription::-webkit-scrollbar-track {
            background: transparent;
            margin: 12px 0;
        }

        #taskDescription::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }

        #taskDescription::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        .date-time-row {
            display: grid;
            grid-template-columns: 1.1fr 0.9fr 1fr; /* fecha un poco más ancha, hora un poco más estrecha, último tercio libre */
            gap: 16px;
            align-items: start;
        }

        .date-time-summary-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            position: relative;
            margin-left: -10px; /* eliminar el gap con la columna del time picker */
        }

        .date-time-summary-wrapper label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 14px;
            visibility: hidden;
            height: 20px;
            line-height: 20px;
        }

        .date-time-summary {
            font-size: 14px;
            font-weight: 500;
            color: #1e293b;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 47px; /* altura aproximada del input: 12px padding top + ~20px contenido + 12px padding bottom + 3px border */
        }

        .date-picker-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
        }

        .date-picker-wrapper input[type="text"] {
            flex: 1;
            padding-right: 110px; /* espacio para días restantes + icono */
        }

        .time-picker-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
        }

        /* Hacer que el campo de hora tenga el mismo estilo visual que el de fecha */
        #taskTime {
            flex: 1;
            box-sizing: border-box;
            padding: 12px 100px 12px 16px; /* espacio para el label de horas + icono del reloj */
            border-radius: 8px;
            border: 1.5px solid #e2e8f0;
            background: #ffffff;
            font-size: 14px;
            color: #1e293b;
            -webkit-appearance: none;
               -moz-appearance: textfield;
                    appearance: none;
        }

        #taskTime:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .time-picker-diff {
            position: absolute;
            right: 40px; /* antes del icono del reloj */
            top: 50%;
            transform: translateY(-50%);
            font-size: 11px;
            font-weight: 600;
            color: #9ca3af; /* gris suave */
            white-space: nowrap;
            pointer-events: none;
        }

        .time-picker-diff.time-picker-diff-past {
            color: #f97373; /* rojo apagado para fechas pasadas */
        }

        .time-picker-button {
            position: absolute;
            right: 14px; /* desplazado un poco hacia la izquierda para más margen con el borde */
            top: 50%;
            transform: translateY(-50%);
            background: transparent;
            border: none;
            padding: 0;
            cursor: pointer;
            color: #64748b;
            border-radius: 0; /* sin recuadro redondeado */
            box-shadow: none; /* sin sombra por defecto */
            transition: color 0.2s ease, transform 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .time-picker-button:hover,
        .time-picker-button:focus-visible {
            color: #2563eb; /* solo cambia el color del icono */
            background: transparent; /* sin fondo */
            box-shadow: none;
            transform: translateY(-50%);
        }

        .date-picker-remove-btn,
        .time-picker-remove-btn {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ef4444;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            cursor: pointer;
            padding: 0;
            z-index: 10;
            transition: opacity 0.2s ease, transform 0.2s ease;
            opacity: 0;
            pointer-events: none;
        }

        .date-picker-wrapper:hover .date-picker-remove-btn.has-value,
        .time-picker-wrapper:hover .time-picker-remove-btn.has-value {
            opacity: 1;
            pointer-events: auto;
        }

        .date-picker-remove-btn:hover,
        .time-picker-remove-btn:hover {
            background: #ef4444; /* mantener el color rojo */
            opacity: 0.9;
            transform: scale(1.1);
        }

        .date-picker-remove-btn svg,
        .time-picker-remove-btn svg {
            width: 12px;
            height: 12px;
        }

        .tag-remove-btn svg {
            width: 12px;
            height: 12px;
        }

        .tag-remove-btn:hover {
            background: #ef4444; /* mantener el color rojo */
            opacity: 0.9;
            transform: scale(1.1);
        }

        .date-picker-diff {
            position: absolute;
            right: 40px; /* antes del icono del calendario */
            top: 50%;
            transform: translateY(-50%);
            font-size: 11px;
            font-weight: 600;
            color: #9ca3af; /* gris suave */
            white-space: nowrap;
            pointer-events: none;
        }

        /* Time Picker */

        .time-picker-popover {
            position: absolute;
            z-index: 3000;
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 16px;
            box-shadow: 0 12px 24px rgba(15, 23, 42, 0.15);
            padding: 12px 16px;
            width: 520px; /* un poco más ancha para que quepan bien los quick options */
            display: none;
            display: none;
        }

        .time-picker-popover.active {
            display: flex;
            flex-direction: column;
            gap: 10px;
            animation: fadeInScale 0.15s ease;
        }

        .time-picker-quick-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .time-picker-quick-row button {
            flex: 1;
            min-width: 0;
            padding: 8px 12px;
            font-size: 13px;
            font-weight: 500;
            border-radius: 10px;
            border: 1px solid #e2e8f0;
            background: #f8fafc;
            color: #1e293b;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .time-picker-quick-row button:hover {
            border-color: #3b82f6;
            background: #eff6ff;
            color: #1d4ed8;
        }

        .time-picker-hours-row {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-top: 0;
            padding-top: 10px;
            border-top: 1px solid #e2e8f0; /* línea divisoria entre opciones rápidas y horas */
        }

        .time-picker-hours-bar {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 4px;
        }

        .time-hour {
            padding: 8px 0;
            min-height: 32px;
            font-size: 13px;
            font-weight: 500;
            text-align: center;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
            background: #ffffff;
            color: #475569;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .time-hour:hover {
            background: #eff6ff;
            border-color: #3b82f6;
            color: #1d4ed8;
        }

        .time-hour.selected {
            background: #3b82f6;
            color: #ffffff;
            border-color: #3b82f6;
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
        }

        .time-picker-minutes-row {
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: space-between;
            margin-top: 10px; /* más espacio respecto a la fila de horas para diferenciarlas */
        }

        .time-picker-minutes-bar {
            display: flex;
            gap: 6px;
            justify-content: center;
            flex: 1 1 auto;
        }

        .time-picker-minutes-row.disabled {
            opacity: 0.45;
        }

        .time-picker-minutes-row.disabled .time-minute,
        .time-picker-minutes-row.disabled .time-adjust-btn {
            pointer-events: none;
        }

        .time-minute {
            width: 60px; /* ancho fijo, algo más estrecho para equilibrar márgenes */
            padding: 8px 0;
            min-height: 32px;
            font-size: 13px;
            font-weight: 500;
            text-align: center;
            border-radius: 6px; /* mismo estilo cuadrado que las horas, solo un poco más ancho */
            border: 1px solid #e2e8f0;
            background: #ffffff;
            color: #475569;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .time-minute:hover {
            background: #eff6ff;
            border-color: #3b82f6;
            color: #1d4ed8;
        }

        .time-minute.selected {
            background: #3b82f6;
            border-color: #3b82f6;
            color: #ffffff;
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
        }

        .time-adjust-group {
            display: flex;
            gap: 6px;
        }

        .time-adjust-btn {
            min-width: 34px;
            padding: 6px 8px;
            min-height: 34px;
            font-size: 13px;
            font-weight: 600;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
            background: #f8fafc;
            color: #475569;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .time-adjust-btn:hover {
            background: #eff6ff;
            border-color: #3b82f6;
            color: #1d4ed8;
        }

        .date-picker-button {
            position: absolute;
            right: 14px; /* desplazado un poco hacia la izquierda para más margen con el borde */
            top: 50%;
            transform: translateY(-50%);
            background: transparent;
            border: none;
            padding: 0;
            cursor: pointer;
            color: #64748b;
            border-radius: 0; /* sin recuadro redondeado */
            box-shadow: none; /* sin sombra por defecto */
            transition: color 0.2s ease, transform 0.2s ease;
        }

        .date-picker-button:hover,
        .date-picker-button:focus-visible {
            color: #2563eb; /* solo cambia el color del icono */
            background: transparent; /* sin fondo */
            box-shadow: none;
            transform: translateY(-50%);
        }

        .date-picker-popover {
            position: absolute;
            z-index: 3000;
            background: #ffffff;
            border: 1px solid #e2e8f0; /* recuperamos contorno sutil */
            border-radius: 16px; /* recuperamos esquinas redondeadas para aspecto de ventana */
            box-shadow: 0 12px 24px rgba(15, 23, 42, 0.15); /* sombra para destacar la ventana */
            padding: 16px;
            width: 540px;
            display: none;
            flex-direction: row;
            gap: 16px;
            align-items: stretch;
        }

        .date-picker-popover.active {
            display: flex;
            animation: fadeInScale 0.15s ease;
        }

        .date-picker-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .date-picker-column.quick-column {
            flex: 0 0 170px;
        }

        .date-picker-column.calendar-column {
            flex: 1;
        }

        .date-picker-quick-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
            height: 100%;
            flex: 1 1 auto;
        }

        .date-picker-quick-options button {
            width: 100%;
            padding: 12px 12px;
            border-radius: 10px;
            border: 1px solid #e2e8f0;
            background: #f8fafc;
            font-size: 13px;
            font-weight: 500;
            color: #1e293b;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            min-height: 45.7px;
        }

        .quick-option-label {
            flex: 1;
        }

        .quick-option-date {
            font-size: 12px;
            font-weight: 500;
            color: #64748b;
            margin-left: 8px;
            white-space: nowrap;
        }

        .date-picker-quick-options button:hover {
            border-color: #3b82f6;
            background: #eff6ff;
            color: #1d4ed8;
        }

        .date-picker-calendar {
            border-left: 1px solid #e2e8f0;
            padding-left: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .date-picker-calendar-header {
            display: grid;
            grid-template-columns: 80px 1fr 80px;
            align-items: center;
            min-height: 36px;
            gap: 8px;
        }

        .date-picker-calendar-header-left {
            display: flex;
            align-items: center;
            height: 100%;
            color: #475569;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .date-picker-calendar-header-right {
            display: inline-flex;
            justify-content: flex-end;
            gap: 20px;
            align-items: center;
        }

        .date-picker-calendar-title {
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 16px;
            font-weight: 700;
            color: #0f172a;
            white-space: nowrap;
            min-width: 0;
        }

        .calendar-nav {
            background: transparent;
            border: none;
            padding: 0 4px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #475569;
            font-size: 26px;
            line-height: 0;
            transform: translateY(-2px);
            transition: color 0.2s ease, transform 0.2s ease;
            outline: none;
            appearance: none;
            box-shadow: none;
        }

        /* Ajuste específico para el texto MONTH/YEAR: mismo estilo pero tamaño como antes */
        #datePickerModeLabel.calendar-nav {
            font-size: 13px;
            font-weight: 600;
            line-height: 1;
            /* Pequeño ajuste para centrar visualmente con el título del mes/año */
            transform: translateY(1px);
            padding: 0 2px;
        }

        /* Evitar que el hover global de .calendar-nav desplace demasiado el botón MONTH/YEAR */
        #datePickerModeLabel.calendar-nav:hover,
        #datePickerModeLabel.calendar-nav:focus-visible {
            transform: translateY(1px);
        }

        .calendar-nav:hover,
        .calendar-nav:focus-visible {
            color: #2563eb;
            transform: translateY(-3px);
            background: transparent;
            box-shadow: none;
        }

        .date-picker-calendar-weekdays {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .date-picker-calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 6px;
        }

        .calendar-month {
            border: none;
            background: transparent;
            border-radius: 8px;
            padding: 10px 8px;
            font-size: 13px;
            font-weight: 500;
            color: #1e293b;
            cursor: pointer;
            transition: background-color 0.15s ease, color 0.15s ease, box-shadow 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            white-space: nowrap;
            box-shadow: 0 0 0 1px rgba(148, 163, 184, 0.4) inset; /* sutil recuadro */
        }

        .calendar-month:hover {
            background: #f1f5f9;
            color: #1d4ed8;
            /* mantenemos el mismo borde sutil al resaltar */
            box-shadow: 0 0 0 1px rgba(148, 163, 184, 0.4) inset;
        }

        .calendar-month.hover-linked {
            background: #f1f5f9;
            color: #1d4ed8;
            /* mismo borde también cuando se resalta desde las opciones rápidas */
            box-shadow: 0 0 0 1px rgba(148, 163, 184, 0.4) inset;
        }

        .calendar-month.today {
            box-shadow: 0 0 0 1px #3b82f6 inset;
        }

        .calendar-month.selected {
            background: #3b82f6;
            color: #ffffff;
            box-shadow: 0 4px 10px rgba(59, 130, 246, 0.25);
        }

        .calendar-day {
            border: none;
            background: transparent;
            border-radius: 8px;
            padding: 8px 0;
            font-size: 13px;
            font-weight: 500;
            color: #1e293b;
            cursor: pointer;
            transition: background-color 0.15s ease, color 0.15s ease, box-shadow 0.15s ease;
            box-shadow: 0 0 0 1px rgba(148, 163, 184, 0.35) inset; /* sutil recuadro */
        }

        .calendar-day:hover {
            background: #f1f5f9;
            color: #1d4ed8;
            /* mantenemos el mismo borde al pasar el cursor */
            box-shadow: 0 0 0 1px rgba(148, 163, 184, 0.35) inset;
        }

        .calendar-day.hover-linked {
            background: #f1f5f9;
            color: #1d4ed8;
            /* y también cuando se resalta desde las opciones rápidas */
            box-shadow: 0 0 0 1px rgba(148, 163, 184, 0.35) inset;
        }

        .calendar-day.outside {
            color: #cbd5e1;
        }

        .calendar-day.today {
            /* Visual highlight without affecting layout height */
            border: none;
            box-shadow: 0 0 0 1px #3b82f6 inset;
        }

        .calendar-day.selected {
            background: #3b82f6;
            color: #ffffff;
            box-shadow: 0 4px 10px rgba(59, 130, 246, 0.25);
        }

        button {
            padding: 12px 24px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }

        button:hover {
            background: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        button:active {
            transform: translateY(0);
        }

        .task-item {
            background: white;
            padding: 24px;
            margin-bottom: 16px;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05), 0 1px 2px rgba(0,0,0,0.1);
            border: 1px solid #e2e8f0;
            transition: all 0.2s ease;
        }

        .task-item:hover {
            box-shadow: 0 4px 6px rgba(0,0,0,0.07), 0 2px 4px rgba(0,0,0,0.06);
            transform: translateY(-1px);
        }

        .task-header {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            margin-bottom: 12px;
        }

        .task-header input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-top: 2px;
            cursor: pointer;
            accent-color: #3b82f6;
        }

        .task-title {
            font-weight: 600;
            font-size: 16px;
            color: #1e293b;
            flex: 1;
            line-height: 1.5;
        }

        .task-item.completed .task-title {
            text-decoration: line-through;
            color: #94a3b8;
        }

        .task-info {
            color: #64748b;
            font-size: 14px;
            margin-bottom: 12px;
            line-height: 1.6;
            margin-left: 32px;
        }

        .task-date-time {
            color: #94a3b8;
            font-size: 13px;
            margin-top: 8px;
            margin-left: 32px;
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .task-actions {
            display: flex;
            gap: 8px;
            margin-top: 16px;
            margin-left: 32px;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 13px;
            border-radius: 6px;
        }

        .btn-edit {
            background: #f59e0b;
        }

        .btn-edit:hover {
            background: #d97706;
        }

        .btn-delete {
            background: #ef4444;
        }

        .btn-delete:hover {
            background: #dc2626;
        }

        .edit-form {
            display: none;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e2e8f0;
        }

        .edit-form.active {
            display: block;
        }

        .message {
            padding: 14px 18px;
            margin-bottom: 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .message.success {
            background: #d1fae5;
            color: #065f46;
            border: 1px solid #a7f3d0;
        }

        .message.error {
            background: #fee2e2;
            color: #991b1b;
            border: 1px solid #fecaca;
        }

        .message.info {
            background: #dbeafe;
            color: #1d4ed8;
            border: 1px solid #bfdbfe;
        }

        .empty {
            text-align: center;
            padding: 60px 40px;
            color: #94a3b8;
            font-size: 15px;
        }

        #message {
            position: fixed;
            bottom: 24px;
            right: 24px;
            z-index: 100000;
            max-width: 360px;
            animation: slideIn 0.3s ease;
            pointer-events: none;
            filter: none !important;
            mix-blend-mode: normal;
        }

        @keyframes slideIn {
            from {
                transform: translateY(100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* Login/Register Styles */
        .auth-container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .auth-box {
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
            width: 100%;
            max-width: 420px;
        }

        .auth-tabs {
            display: flex;
            margin-bottom: 28px;
            border-bottom: 2px solid #e2e8f0;
        }

        .auth-tab {
            flex: 1;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            background: none;
            border: none;
            font-size: 15px;
            font-weight: 500;
            color: #64748b;
            transition: all 0.2s ease;
        }

        .auth-tab:hover {
            color: #3b82f6;
        }

        .auth-tab.active {
            color: #3b82f6;
            border-bottom: 3px solid #3b82f6;
            margin-bottom: -2px;
            font-weight: 600;
        }

        .auth-form {
            display: none;
        }

        .auth-form.active {
            display: block;
        }

        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 32px;
            padding: 16px 20px;
            background: #f1f5f9;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
        }

        .top-bar strong {
            color: #1e293b;
            font-weight: 600;
            font-size: 14px;
        }

        .profile-btn {
            background: #3b82f6;
            padding: 8px 16px;
            font-size: 13px;
            border-radius: 6px;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .profile-btn:hover {
            background: #2563eb;
        }

        .logout-btn {
            background: transparent !important;
            border: none !important;
            padding: 0;
            color: #ef4444;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: color 0.2s ease;
            width: auto;
            text-align: center;
            display: block;
            margin: 0 auto;
            position: relative;
            box-shadow: none !important;
            text-shadow: none !important;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        .logout-btn:hover {
            background: transparent !important;
            color: #dc2626;
            text-decoration: underline;
            box-shadow: none !important;
        }

        .logout-btn:focus {
            background: transparent !important;
            outline: none;
            box-shadow: none !important;
        }

        .logout-btn:active {
            background: transparent !important;
            box-shadow: none !important;
        }

        /* Logout Confirmation Modal Styles */
        .logout-confirm-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 3000;
            backdrop-filter: blur(4px);
            animation: fadeIn 0.2s ease;
            align-items: center;
            justify-content: center;
        }

        .logout-confirm-overlay.active {
            display: flex;
        }

        .logout-confirm-modal {
            background: white;
            border-radius: 16px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
            animation: slideUpScale 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            transform-origin: center;
        }

        @keyframes slideUpScale {
            from {
                transform: translateY(20px) scale(0.9);
                opacity: 0;
            }
            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        .logout-confirm-content {
            padding: 32px;
            text-align: center;
        }

        .logout-confirm-content h3 {
            margin: 0 0 12px 0;
            font-size: 20px;
            font-weight: 600;
            color: #1e293b;
        }

        .logout-confirm-content p {
            margin: 0 0 24px 0;
            font-size: 14px;
            color: #64748b;
            line-height: 1.5;
        }

        .logout-confirm-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .logout-confirm-btn {
            padding: 10px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            border: none;
            transition: all 0.2s ease;
            min-width: 120px;
        }

        .logout-confirm-yes {
            background: #ef4444;
            color: white;
        }

        .logout-confirm-yes:hover {
            background: #dc2626;
            transform: translateY(-1px);
            box-shadow: 0 4px 6px -1px rgba(239, 68, 68, 0.3);
        }

        .logout-confirm-yes:active {
            transform: translateY(0);
        }

        .logout-confirm-no {
            background: #f1f5f9;
            color: #475569;
        }

        .logout-confirm-no:hover {
            background: #e2e8f0;
            transform: translateY(-1px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .logout-confirm-no:active {
            transform: translateY(0);
        }

        /* Profile Modal Styles */
        .profile-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            backdrop-filter: blur(4px);
            animation: fadeIn 0.2s ease;
        }

        .profile-overlay.active {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .profile-modal {
            background: white;
            border-radius: 20px;
            width: 95%;
            max-width: 1200px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .profile-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 28px 40px;
            border-bottom: 1px solid #e2e8f0;
            background: linear-gradient(135deg, #f8fafc 0%, #ffffff 100%);
        }

        .profile-header h2 {
            margin: 0;
            font-size: 28px;
            font-weight: 700;
            color: #0f172a;
            letter-spacing: -0.5px;
        }

        .close-profile {
            background: none !important;
            border: none !important;
            font-size: 24px;
            color: #64748b;
            cursor: pointer;
            padding: 0;
            margin: 0;
            width: auto;
            height: auto;
            display: inline-block;
            line-height: 1;
            outline: none !important;
            box-shadow: none !important;
            border-radius: 0 !important;
            transition: color 0.2s ease;
        }

        .close-profile:hover {
            color: #ef4444;
            background: none !important;
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
        }

        .close-profile:focus {
            outline: none !important;
            box-shadow: none !important;
            background: none !important;
            border: none !important;
        }

        .profile-content {
            padding: 40px;
            display: grid;
            grid-template-columns: 30% 70%;
            gap: 40px;
        }

        .profile-left-column {
            display: flex;
            flex-direction: column;
            gap: 40px;
        }

        .profile-right-column {
            display: flex;
            flex-direction: column;
            gap: 40px;
            width: 500px;
            flex-shrink: 0;
        }

        .profile-section {
            margin-bottom: 0;
            background: #ffffff;
            padding: 24px;
            padding-bottom: 20px;
            border-radius: 16px;
            border: 1px solid #e2e8f0;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            height: 500px;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            overflow: hidden;
        }

        .profile-section:last-child {
            margin-bottom: 0;
        }

        .profile-section h3 {
            font-size: 16px;
            font-weight: 700;
            color: #0f172a;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e2e8f0;
            letter-spacing: -0.2px;
        }

        .profile-info {
            background: #f8fafc;
            padding: 20px 24px;
            border-radius: 12px;
            margin-bottom: 16px;
            border: 1px solid #e2e8f0;
            transition: all 0.2s ease;
        }

        .profile-info.editable {
            background: #ffffff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            overflow: hidden;
            padding: 16px 20px;
            min-height: 48px;
        }

        .profile-info-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 0;
        }

        .profile-info-item:not(:last-child) {
            margin-bottom: 0;
        }

        .profile-info-label {
            font-weight: 600;
            color: #475569;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }

        .profile-info-value {
            font-weight: 600;
            color: #1e293b;
            font-size: 15px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            text-align: left;
        }

        .profile-editable-input {
            border: none;
            background: transparent;
            font-weight: 600;
            color: #1e293b;
            font-size: 15px;
            padding: 0;
            margin: 0;
            text-align: left;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            outline: none;
            cursor: text;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            height: auto;
            min-height: 24px;
            line-height: 1.6;
        }

        .password-input-wrapper {
            position: relative;
            width: 100%;
            display: flex;
            align-items: center;
        }

        .password-input {
            padding-right: 45px !important;
            width: calc(100% - 45px);
            max-width: 300px;
        }

        .profile-editable-input:hover {
            background: #f1f5f9;
            border-radius: 4px;
        }

        .profile-editable-input:focus {
            background: #f1f5f9;
            border-radius: 4px;
        }

        .password-toggle-btn {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            background: transparent;
            border: none;
            padding: 4px;
            cursor: pointer;
            transition: color 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            color: #64748b;
            flex-shrink: 0;
        }

        .password-toggle-btn:hover {
            background: transparent;
            color: #3b82f6;
            transform: translateY(-50%);
        }

        .password-toggle-btn:active {
            transform: translateY(-50%);
            color: #2563eb;
        }

        .password-toggle-btn svg {
            width: 20px;
            height: 20px;
            stroke: currentColor;
        }

        .profile-editable-input[readonly] {
            cursor: default;
            user-select: none;
            pointer-events: none;
        }

        .profile-editable-input:not([readonly]) {
            cursor: text;
        }

        /* Task Modal Styles */
        .task-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            z-index: 2000;
            backdrop-filter: blur(4px);
            animation: fadeIn 0.2s ease;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .task-modal-overlay.active {
            display: flex;
        }

        .task-modal {
            background: white;
            border-radius: 16px;
            width: 100%;
            max-width: 650px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
            animation: slideUpScale 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            transform-origin: center;
        }

        /* Tags modal specific styles - appears as auxiliary window */
        #tagsModalOverlay {
            background: rgba(0, 0, 0, 0.1);
            backdrop-filter: none;
            justify-content: flex-start;
            align-items: flex-start;
            padding: 0;
        }

        #tagsModalOverlay .task-modal {
            max-width: 450px;
            width: 450px;
            height: 500px;
            max-height: 500px;
            margin: 0;
            position: absolute;
            box-shadow: 0 10px 25px -5px rgba(0,0,0,0.2), 0 8px 10px -5px rgba(0,0,0,0.1);
            animation: fadeInScale 0.2s ease;
            transform-origin: top left;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        #tagsModalOverlay .task-modal-content {
            flex: 1;
            overflow: hidden;
            padding: 16px 20px;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        /* Hide scrollbars for tags modal columns but keep scroll functionality */
        #tagsModalFoldersColumn::-webkit-scrollbar,
        #tagsModalTagsColumn::-webkit-scrollbar,
        #tagsModalAllTagsColumn::-webkit-scrollbar {
            width: 0px;
            background: transparent;
        }
        
        #tagsModalFoldersColumn,
        #tagsModalTagsColumn,
        #tagsModalAllTagsColumn {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        
        #tagsModalFoldersColumn::-webkit-scrollbar-track,
        #tagsModalTagsColumn::-webkit-scrollbar-track,
        #tagsModalAllTagsColumn::-webkit-scrollbar-track {
            background: transparent;
        }
        
        #tagsModalOverlay .task-modal-header {
            padding: 16px 20px;
        }
        
        /* Remove profile-section styling inside tags modal */
        #tagsModalOverlay .profile-section {
            border-radius: 0 !important;
            background: transparent !important;
            box-shadow: none !important;
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
            height: auto !important;
            overflow: visible !important;
        }
        
        #tagsModalOverlay .task-modal-header h2 {
            font-size: 18px;
        }

        /* Create tag modal specific styles - appears as auxiliary window */
        #createTagModalOverlay {
            background: rgba(0, 0, 0, 0.1);
            backdrop-filter: none;
            justify-content: flex-start;
            align-items: flex-start;
            padding: 0;
        }

        #createTagModalOverlay .task-modal {
            max-width: 450px;
            width: 450px;
            height: 380px;
            max-height: 380px;
            margin: 0;
            position: absolute;
            box-shadow: 0 10px 25px -5px rgba(0,0,0,0.2), 0 8px 10px -5px rgba(0,0,0,0.1);
            animation: fadeInScale 0.2s ease;
            transform-origin: top left;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #createTagModalOverlay .task-modal-content {
            flex: 1;
            overflow: hidden;
            padding: 16px 20px;
        }

        #createTagModalOverlay .task-modal-header {
            padding: 12px 20px;
        }

        #createTagModalOverlay .task-modal-header h2 {
            font-size: 16px;
        }

        #createTagModalOverlay label {
            margin-bottom: 0 !important;
            line-height: 1 !important;
        }
        
        /* Create folder modal specific styles - appears as auxiliary window */
        #createFolderModalOverlay {
            background: rgba(0, 0, 0, 0.1);
            backdrop-filter: none;
            justify-content: flex-start;
            align-items: flex-start;
            padding: 0;
        }
        
        #createFolderModalOverlay .task-modal {
            max-width: 450px;
            width: 450px;
            height: 380px;
            max-height: 380px;
            margin: 0;
            position: absolute;
            box-shadow: 0 10px 25px -5px rgba(0,0,0,0.2), 0 8px 10px -5px rgba(0,0,0,0.1);
            animation: fadeInScale 0.2s ease;
            transform-origin: top left;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* Create choice modal styles */
        #createChoiceModalOverlay {
            background: transparent;
            backdrop-filter: none;
            justify-content: flex-start;
            align-items: flex-start;
            padding: 0;
        }
        
        #createChoiceMenu {
            position: fixed;
            z-index: 10001;
        }
        
        #createFolderModalOverlay .task-modal-content {
            flex: 1;
            overflow: hidden;
            padding: 16px 20px;
        }
        
        #createFolderModalOverlay .task-modal-header {
            padding: 12px 20px;
        }
        
        #createFolderModalOverlay .task-modal-header h2 {
            font-size: 16px;
        }
        
        #createFolderModalOverlay label {
            margin-bottom: 0 !important;
            line-height: 1 !important;
        }

        @keyframes fadeInScale {
            from {
                transform: scale(0.95);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .task-modal-header {
            padding: 24px 28px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            background: white;
            border-radius: 16px 16px 0 0;
            z-index: 10;
        }

        .task-modal-header h2 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
            color: #0f172a;
        }

        .task-modal-close {
            background: none !important;
            border: none !important;
            font-size: 28px;
            color: #64748b;
            cursor: pointer;
            width: auto;
            height: auto;
            display: inline-block;
            line-height: 1;
            padding: 0;
            margin: 0;
            outline: none !important;
            box-shadow: none !important;
            border-radius: 0 !important;
            transition: color 0.2s ease;
        }

        .task-modal-close:hover {
            color: #ef4444;
            background: none !important;
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
        }

        .task-modal-close:focus {
            outline: none !important;
            box-shadow: none !important;
            background: none !important;
            border: none !important;
        }

        .task-modal-content {
            padding: 24px 28px;
        }

        /* Tags Styles */
        .tag {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
            color: white;
            margin-right: 5px;
        }

        .tag-select-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 5px;
        }

        .tag-checkbox-item {
            display: flex;
            align-items: center;
            padding: 6px 12px;
            border: 2px solid #ddd;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
            font-size: 13px;
        }

        .tag-checkbox-item:hover {
            border-color: #007bff;
            background: #f0f7ff;
        }

        .tag-checkbox-item.selected {
            border-color: #007bff;
            background: #007bff;
            color: white;
        }


        .tag-checkbox-item .tag-color-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 6px;
            display: inline-block;
        }

        .tags-section {
            margin-top: 24px;
            padding-top: 24px;
            border-top: 1px solid #e2e8f0;
        }

        .tags-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .tag-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 12px;
            background: #f1f5f9;
            border: 1px solid #e2e8f0;
            transition: all 0.2s ease;
        }

        .tag-item:hover {
            background: #e2e8f0;
        }

        .tag-item .tag-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
        }

        .tag-item .delete-tag {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            cursor: pointer;
            font-size: 10px;
            padding: 0;
            line-height: 1;
        }

        .tag-item .delete-tag:hover {
            background: #c82333;
        }

        .new-folder-form {
            display: flex;
            gap: 10px;
            margin-bottom: 12px;
        }

        .new-folder-form input {
            flex: 1;
        }

        .new-folder-form input[type="color"] {
            width: 60px;
            height: 44px;
            border-radius: 8px;
            cursor: pointer;
        }

        .folder-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
        }

        .folder-card .delete-tag:hover {
            background: #fee2e2 !important;
        }

        .tag-item:hover {
            background: #f1f5f9 !important;
        }

        .tag-item .delete-tag:hover {
            opacity: 1 !important;
            background: #fee2e2;
        }

        .create-btn {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: 2px solid #3b82f6;
            background: #3b82f6;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.2);
            padding: 0;
        }

        .create-btn:hover {
            background: #2563eb;
            border-color: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 4px 6px rgba(59, 130, 246, 0.3);
        }

        .create-btn:active {
            transform: translateY(0);
        }

        .create-btn svg {
            width: 20px;
            height: 20px;
        }

        .view-btn {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: 2px solid #e2e8f0;
            background: #ffffff;
            color: #64748b;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            padding: 0;
        }

        .view-btn:hover {
            border-color: #3b82f6;
            color: #3b82f6;
            background: #eff6ff;
        }

        .view-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        .view-btn.active:hover {
            background: #2563eb;
            border-color: #2563eb;
        }

        #sortOrderBtn {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 0;
        }

        #sortOrderBtn svg {
            display: block;
            margin: 0;        }

        /* Drag and drop styles */
        .tag-item[draggable="true"] {
            user-select: none;
        }

        .tag-item[draggable="true"]:active {
            cursor: grabbing;
        }

        .folder-item.drag-over {
            opacity: 0.7;
            transform: scale(1.02);
            transition: all 0.2s ease;
        }

        /* Context Menu Styles */
        .context-menu {
            position: fixed;
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 4px;
            z-index: 10000;
            min-width: 160px;
            max-width: 260px;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }

        .context-menu-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            cursor: pointer;
            border-radius: 4px;
            color: #1e293b;
            font-size: 14px;
            transition: background 0.2s ease;
        }

        .context-menu-item:hover {
            background: #f1f5f9;
        }

        .context-menu-item-danger {
            color: #ef4444;
        }

        .context-menu-item-danger:hover {
            background: #fee2e2;
        }

        .context-menu-item svg {
            flex-shrink: 0;
        }

        .context-menu-item + .context-menu-item {
            border-top: 1px solid #f1f5f9;
        }

        .context-menu-confirm {
            display: none;
            flex-direction: column;
            gap: 12px;
            width: 100%;
            min-height: 100%;
            max-width: 100%;
            box-sizing: border-box;
            overflow: hidden;
            word-break: break-word;
            justify-content: center;
            align-items: center;
            padding: 8px 12px;
            background: #ffffff;
            font-family: inherit;
        }

        .context-menu-confirm-title {
            font-weight: 600;
            font-size: 14px;
            color: #1e293b;
            text-align: center;
            width: 100%;
        }

        .context-menu-confirm-buttons {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            flex-wrap: wrap;
            width: 100%;
        }

        .context-menu-btn {
            border: none;
            border-radius: 8px;
            padding: 8px 14px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1 1 100px;
            text-align: center;
        }

        .context-menu-btn-cancel {
            background: #f1f5f9;
            color: #0f172a;
        }

        .context-menu-btn-cancel:hover {
            background: #e2e8f0;
        }

        .context-menu-btn-delete {
            background: #ef4444;
            color: #ffffff;
        }

        .context-menu-btn-delete:hover {
            background: #dc2626;
        }

        /* Highlight styles for context menu selection */
        .tag-item.context-selected {
            background: #dbeafe !important;
        }

        .folder-item.context-selected {
            position: relative;
        }

        .folder-item.context-selected::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 200, 87, 0.25) 0%, rgba(255, 140, 0, 0.25) 100%);
            border-radius: 8px;
            pointer-events: none;
            z-index: 1;
        }

        .folder-card-clickable {
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .folder-card-clickable:hover {
            transform: translateX(2px);
        }

        .folder-item:hover {
            transform: translateX(2px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .folder-tags-collapsed {
            display: none;
        }

        /* Hide scrollbars but keep scroll functionality */
        #foldersColumn::-webkit-scrollbar,
        #tagsColumn::-webkit-scrollbar {
            width: 0px;
            background: transparent;
        }

        #foldersColumn,
        #tagsColumn {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        #foldersColumn::-webkit-scrollbar-track,
        #tagsColumn::-webkit-scrollbar-track {
            background: transparent;
        }

        #allTagsColumn::-webkit-scrollbar {
            width: 0px;
            background: transparent;
        }

        #allTagsColumn {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        #allTagsColumn::-webkit-scrollbar-track {
            background: transparent;
        }

        .new-tag-form {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .new-tag-form input {
            flex: 1;
        }

        .new-tag-form input[type="color"] {
            width: 50px;
            height: 38px;
            padding: 2px;
        }

        .new-tag-form select {
            flex: 1;
            max-width: 150px;
            padding: 8px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            background: white;
            font-size: 14px;
        }

        /* Files Upload Styles */
        .files-upload-container {
            display: flex;
            gap: 12px;
            align-items: flex-start;
            flex-wrap: wrap;
        }

        .files-preview-list {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            flex-shrink: 0;
        }

        .files-preview-list:empty {
            display: none;
        }

        .files-upload-container:not(:has(.files-preview-list > *)) .image-upload-area,
        .files-upload-container.no-files .image-upload-area {
            width: 100%;
            flex: none;
        }

        .file-preview-item {
            position: relative;
            flex-shrink: 0;
            border-radius: 12px;
            overflow: visible;
            border: 2px solid #e2e8f0;
            background: #ffffff;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .file-preview-item.image-preview {
            /* Para imágenes, la altura se sincronizará con el área de carga */
        }

        .file-preview-item.pdf-preview {
            width: 160px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px;
            box-sizing: border-box;
        }

        .file-preview-image {
            width: auto;
            height: 100%;
            object-fit: cover;
            display: block;
            border-radius: 12px;
        }

        .file-preview-pdf-box {
            width: auto;
            height: auto;
            background: #ef4444;
            border-radius: 4px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 4px 8px;
            margin-bottom: 8px;
            flex-shrink: 0;
        }

        .file-preview-pdf-box-text {
            color: #ffffff;
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 0.5px;
            line-height: 1;
        }

        .file-preview-pdf-title {
            font-size: 11px;
            color: #1e293b;
            text-align: center;
            word-break: break-word;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            max-width: 100%;
            line-height: 1.5;
            flex: 1;
            min-height: 0;
        }

        .file-preview-pdf-title.single-line {
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-line-clamp: unset;
            -webkit-box-orient: unset;
        }

        .file-remove-btn {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ef4444;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            cursor: pointer;
            padding: 0;
            z-index: 100;
            transition: opacity 0.2s ease, transform 0.2s ease;
            opacity: 0;
            pointer-events: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .file-preview-item:hover .file-remove-btn {
            opacity: 1;
            pointer-events: auto;
        }

        .file-remove-btn:hover {
            background: #ef4444;
            opacity: 0.9;
            transform: scale(1.1);
        }

        .file-remove-btn svg {
            width: 12px;
            height: 12px;
        }

        /* Image Styles - Legacy support */
        .image-upload-container {
            display: flex;
            gap: 12px;
            align-items: flex-start;
        }

        .image-preview-wrapper {
            position: relative;
            flex-shrink: 0;
            border-radius: 12px;
            overflow: visible;
            border: 2px solid #e2e8f0;
            background: #ffffff;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .task-image-preview {
            width: auto;
            height: 100%;
            object-fit: cover;
            display: block;
            border-radius: 12px;
        }

        .image-remove-btn {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ef4444;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            cursor: pointer;
            padding: 0;
            z-index: 100;
            transition: opacity 0.2s ease, transform 0.2s ease;
            opacity: 0;
            pointer-events: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .image-preview-wrapper:hover .image-remove-btn {
            opacity: 1;
            pointer-events: auto;
        }

        .image-remove-btn:hover {
            background: #ef4444;
            opacity: 0.9;
            transform: scale(1.1);
        }

        .image-remove-btn svg {
            width: 12px;
            height: 12px;
        }

        .task-image {
            margin-top: 12px;
            max-width: 100%;
            max-height: 300px;
            border-radius: 10px;
            border: 1px solid #e2e8f0;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
        }

        .task-image:hover {
            opacity: 0.9;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .image-upload-area {
            border: 2px dashed #cbd5e1;
            border-radius: 12px;
            padding: 24px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8fafc;
            flex: 1;
            min-width: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .image-upload-area.has-files {
            padding: 24px 16px;
            flex: 1;
            min-width: 0;
        }

        .image-upload-area.has-image {
            padding: 24px 16px;
            flex: 1;
            min-width: 0;
        }

        .image-upload-area:hover {
            border-color: #3b82f6;
            background: #eff6ff;
        }

        .image-upload-area.drag-over {
            border-color: #3b82f6;
            background: #dbeafe;
            border-style: solid;
            transform: scale(1.02);
        }

        .image-upload-area input[type="file"] {
            display: none;
        }

        #imagePreviewText {
            font-size: 14px;
            color: #64748b;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Filter Buttons */
        .filter-buttons {
            display: flex;
            gap: 12px;
            margin-bottom: 24px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e2e8f0;
        }

        .filter-btn {
            padding: 10px 20px;
            border: 1.5px solid #e2e8f0;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            color: #64748b;
        }

        .filter-btn:hover {
            border-color: #3b82f6;
            background: #eff6ff;
            color: #3b82f6;
        }

        .filter-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.2);
        }

        /* Search Styles */
        .search-container {
            margin-bottom: 24px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e2e8f0;
        }

        .search-input {
            width: 100%;
            padding: 14px 18px;
            border: 1.5px solid #e2e8f0;
            border-radius: 10px;
            font-size: 14px;
            transition: all 0.2s ease;
            background: white;
        }

        .search-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .search-input::placeholder {
            color: #94a3b8;
        }

        /* Responsive Profile Modal */
        @media (max-width: 768px) {
            .profile-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div id="message"></div>
    
    <!-- Login/Register Screen -->
    <div id="authScreen" class="auth-container">
        <div class="auth-box">
            <div class="auth-tabs">
                <button class="auth-tab active" onclick="showLogin()">Login</button>
                <button class="auth-tab" onclick="showRegister()">Register</button>
            </div>
            
            <form id="loginForm" class="auth-form active">
                <div class="form-group">
                    <label for="loginEmail">Email</label>
                    <input type="email" id="loginEmail" required>
                </div>
                <div class="form-group">
                    <label for="loginPassword">Password</label>
                    <input type="password" id="loginPassword" required>
                </div>
                <button type="submit">Login</button>
            </form>
            
            <form id="registerForm" class="auth-form">
                <div class="form-group">
                    <label for="registerName">Name</label>
                    <input type="text" id="registerName" required>
                </div>
                <div class="form-group">
                    <label for="registerEmail">Email</label>
                    <input type="email" id="registerEmail" required>
                </div>
                <div class="form-group">
                    <label for="registerPassword">Password</label>
                    <input type="password" id="registerPassword" required>
                </div>
                <button type="submit">Register</button>
            </form>
        </div>
    </div>

    <!-- Main App Screen -->
    <div id="appScreen" class="container" style="display: none;">
        <header class="app-header">
            <div class="header-left">
                <h1 class="header-title">Task Master</h1>
                <span class="header-user" id="userEmail"></span>
                    </div>
            <div class="header-actions">
                <button class="add-task-btn" onclick="openTaskModal()">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4"></path>
                    </svg>
                    New Task
                </button>
                    <button class="profile-btn" onclick="openProfile()">Profile</button>
                </div>
        </header>

        <div class="workspace">
            <!-- Left Column: Main and Profile -->
            <div class="left-column">
                <!-- Main Empty Window -->
                <div id="mainEmptyWindow" class="floating-window" style="display: flex;">
                    <div class="window-header">
                        <div class="window-title">
                            <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="margin-right: 4px;">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                            </svg>
                            Main
                        </div>
                    </div>
                    <div class="window-content">
                        <!-- Content will be added here -->
                    </div>
                </div>

                <!-- Profile Window -->
                <div id="profileWindow" class="floating-window profile-window" style="display: flex;">
                    <div class="window-header">
                        <div class="window-title">
                            <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="margin-right: 4px;">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
                            </svg>
                            Profile
                        </div>
                    </div>
                    <div class="window-content">
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 12px; padding: 20px;">
                            <div style="width: 64px; height: 64px; border-radius: 50%; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); display: flex; align-items: center; justify-content: center; color: white; font-size: 24px; font-weight: 600;" id="profileInitial">
                                <!-- User initial will be populated here -->
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 16px; font-weight: 600; color: #0f172a; margin-bottom: 4px;" id="profileWindowName">
                                    <!-- User name will be populated here -->
                                </div>
                                <div style="font-size: 13px; color: #64748b;" id="profileWindowEmail">
                                    <!-- User email will be populated here -->
                                </div>
                            </div>
                            <button onclick="openProfile()" style="margin-top: 8px; padding: 8px 16px; background: #3b82f6; color: white; border: none; border-radius: 6px; font-size: 13px; font-weight: 500; cursor: pointer;">Open Profile</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Center Column: Calendar -->
            <div>
                <div id="calendarWindow" class="floating-window calendar-window" style="display: flex;">
                    <div class="window-header">
                        <div class="window-title">
                            <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="margin-right: 4px;">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                            </svg>
                            Calendar
                        </div>
                    </div>
                    <div class="window-content">
                        <div id="calendarContainer">
                            <!-- Calendar will be rendered here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Column: Task List -->
            <div>
                <div id="taskListWindow" class="floating-window task-list-window" style="display: flex;">
                    <div class="window-header">
                        <div class="window-title">
                            <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="margin-right: 4px;">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path>
                            </svg>
                            <span id="tasksTitle">Pending Tasks</span>
                        </div>
                    </div>
                    <div class="window-content">
                        <div style="margin-bottom: 16px;">
                            <input type="text" id="taskSearch" class="search-input" placeholder="Search tasks..." oninput="handleSearch()" style="width: 100%; margin-bottom: 12px;">
                            <div class="filter-buttons" style="display: flex; gap: 6px;">
                                <button class="filter-btn active" onclick="setFilter('pending')" id="filterPending" style="flex: 1; padding: 6px 12px; font-size: 12px;">Pending</button>
                                <button class="filter-btn" onclick="setFilter('completed')" id="filterCompleted" style="flex: 1; padding: 6px 12px; font-size: 12px;">Completed</button>
                                <button class="filter-btn" onclick="setFilter('all')" id="filterAll" style="flex: 1; padding: 6px 12px; font-size: 12px;">All</button>
                            </div>
                        </div>
                        <div id="taskList" style="flex: 1; overflow-y: auto;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Task Creation Modal -->
    <div id="taskModalOverlay" class="task-modal-overlay" onclick="closeTaskModalOnOverlay(event)">
        <div class="task-modal" onclick="event.stopPropagation()">
            <div class="task-modal-header">
                <h2>Create New Task</h2>
                <button class="task-modal-close" onclick="closeTaskModal()">×</button>
            </div>
            <div class="task-modal-content">
                <form id="taskForm">
                    <div class="form-group">
                        <label for="taskTitle">Title</label>
                        <input type="text" id="taskTitle" required>
                    </div>
                    <div class="form-group">
                        <label for="taskDescription">Description</label>
                        <textarea id="taskDescription" rows="5"></textarea>
                    </div>
                    <div class="form-group">
                        <div class="date-time-row">
                            <div>
                                <label for="taskDate">Date</label>
                                <div class="date-picker-wrapper">
                                    <input type="text" id="taskDateDisplay" placeholder="dd/mm/yyyy" inputmode="numeric" autocomplete="off">
                                    <span id="taskDateDiffLabel" class="date-picker-diff"></span>
                                    <input type="date" id="taskDate" style="display: none;">
                                    <button type="button" class="date-picker-button" onclick="toggleDatePicker(event)" aria-label="Select date">
                                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                                            <line x1="16" y1="2" x2="16" y2="6"></line>
                                            <line x1="8" y1="2" x2="8" y2="6"></line>
                                            <line x1="3" y1="10" x2="21" y2="10"></line>
                                        </svg>
                                    </button>
                                    <button type="button" class="date-picker-remove-btn" onclick="clearDateValue(event)" aria-label="Clear date">
                                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                                            <line x1="18" y1="6" x2="6" y2="18"></line>
                                            <line x1="6" y1="6" x2="18" y2="18"></line>
                                        </svg>
                                    </button>
                                </div>
                            </div>
                            <div>
                                <label for="taskTime">Time</label>
                                <div class="time-picker-wrapper">
                                    <input type="text" id="taskTime" placeholder="hh:mm" inputmode="numeric" autocomplete="off">
                                    <span id="taskTimeDiffLabel" class="time-picker-diff"></span>
                                    <input type="time" id="taskTimeHidden" style="display: none;">
                                    <button type="button" class="time-picker-button" onclick="toggleTimePicker(event)" aria-label="Select time">
                                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <circle cx="12" cy="12" r="10"></circle>
                                            <polyline points="12 6 12 12 16 14"></polyline>
                                        </svg>
                                    </button>
                                    <button type="button" class="time-picker-remove-btn" onclick="clearTimeValue(event)" aria-label="Clear time">
                                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                                            <line x1="18" y1="6" x2="6" y2="18"></line>
                                            <line x1="6" y1="6" x2="18" y2="18"></line>
                                        </svg>
                                    </button>
                                </div>
                            </div>
                            <div class="date-time-summary-wrapper">
                                <label>Summary</label>
                                <span id="dateTimeSummary" class="date-time-summary"></span>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Tags</label>
                        <div id="taskTags" class="tag-select-row">
                            <!-- Tags will be populated here -->
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Files</label>
                        <div class="files-upload-container no-files">
                            <div class="files-preview-list" id="filesPreviewList"></div>
                            <div class="image-upload-area" id="imageUploadArea" onclick="document.getElementById('taskFiles').click()">
                                <input type="file" id="taskFiles" accept="image/*,.pdf" multiple>
                                <div id="imagePreviewText">Click to select or drag & drop images/PDF</div>
                            </div>
                        </div>
                        <small style="color: #94a3b8; font-size: 11px; display: block; margin-top: 5px;">Formats: Images (JPEG, JPG, PNG, GIF, WEBP) max 10MB each, PDF max 20MB. Max 3 images + 1 PDF</small>
                    </div>
                    <div style="display: flex; gap: 12px; justify-content: center; margin-top: 24px; padding-top: 24px; border-top: 1px solid #e2e8f0;">
                        <button type="button" onclick="closeTaskModal()" style="min-width: 120px; background: #f1f5f9; color: #475569; border: 1px solid #e2e8f0; padding: 8px 16px; border-radius: 6px; font-size: 13px; font-weight: 500; cursor: pointer;">Cancel</button>
                        <button type="submit" style="min-width: 120px; background: #3b82f6; color: white; border: none; padding: 8px 16px; border-radius: 6px; font-size: 13px; font-weight: 500; cursor: pointer;">Create Task</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <div id="datePickerPopover" class="date-picker-popover" onclick="event.stopPropagation()">
        <div class="date-picker-column quick-column date-picker-quick-options">
            <button type="button" data-option="today" onclick="applyQuickDateOption('today')">
                <span class="quick-option-label">Today</span>
                <span class="quick-option-date"></span>
            </button>
            <button type="button" data-option="tomorrow" onclick="applyQuickDateOption('tomorrow')">
                <span class="quick-option-label">Tomorrow</span>
                <span class="quick-option-date"></span>
            </button>
            <button type="button" data-option="next-week" onclick="applyQuickDateOption('next-week')">
                <span class="quick-option-label">Next Week</span>
                <span class="quick-option-date"></span>
            </button>
            <button type="button" data-option="next-month" onclick="applyQuickDateOption('next-month')">
                <span class="quick-option-label">Next Month</span>
                <span class="quick-option-date"></span>
            </button>
            <button type="button" data-option="next-year" onclick="applyQuickDateOption('next-year')">
                <span class="quick-option-label">Next Year</span>
                <span class="quick-option-date"></span>
            </button>
        </div>
        <div class="date-picker-column calendar-column date-picker-calendar">
            <div class="date-picker-calendar-header">
                <div class="date-picker-calendar-header-left">
                    <button type="button" id="datePickerModeLabel" class="calendar-nav" onclick="toggleCalendarMode()" aria-label="Toggle between month and year view">MONTH</button>
                </div>
                <span id="datePickerMonthLabel" class="date-picker-calendar-title"></span>
                <div class="date-picker-calendar-header-right">
                    <button type="button" class="calendar-nav" onclick="changeDatePickerMonth(-1)" aria-label="Previous month">‹</button>
                    <button type="button" class="calendar-nav" onclick="changeDatePickerMonth(1)" aria-label="Next month">›</button>
                </div>
            </div>
            <div class="date-picker-calendar-weekdays">
                <span>Mon</span>
                <span>Tue</span>
                <span>Wed</span>
                <span>Thu</span>
                <span>Fri</span>
                <span>Sat</span>
                <span>Sun</span>
            </div>
            <div id="datePickerDays" class="date-picker-calendar-grid"></div>
        </div>
    </div>

    <!-- Time Picker Popover -->
    <div id="timePickerPopover" class="time-picker-popover" onclick="event.stopPropagation()">
        <div class="time-picker-quick-row">
            <button type="button" onclick="applyQuickTimeOption('now')">Now</button>
            <button type="button" onclick="applyQuickTimeOption('midnight')">Midnight</button>
            <button type="button" onclick="applyQuickTimeOption('morning')">Morning</button>
            <button type="button" onclick="applyQuickTimeOption('noon')">Noon</button>
            <button type="button" onclick="applyQuickTimeOption('afternoon')">Afternoon</button>
            <button type="button" onclick="applyQuickTimeOption('evening')">Evening</button>
        </div>
        <div class="time-picker-hours-row">
            <div id="timePickerHoursBar" class="time-picker-hours-bar"></div>
            <div id="timePickerMinutesRow" class="time-picker-minutes-row">
                <div class="time-adjust-group">
                    <button type="button" class="time-adjust-btn" onclick="adjustSelectedTime(-5)">-5</button>
                    <button type="button" class="time-adjust-btn" onclick="adjustSelectedTime(-1)">-1</button>
                </div>
                <div id="timePickerMinutesBar" class="time-picker-minutes-bar"></div>
                <div class="time-adjust-group">
                    <button type="button" class="time-adjust-btn" onclick="adjustSelectedTime(1)">+1</button>
                    <button type="button" class="time-adjust-btn" onclick="adjustSelectedTime(5)">+5</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Profile Modal -->
    <div id="profileOverlay" class="profile-overlay" onclick="closeProfileOnOverlay(event)">
        <div class="profile-modal" onclick="event.stopPropagation()">
            <div class="profile-header">
                <h2>Profile</h2>
                <button class="close-profile" onclick="closeProfile()">×</button>
            </div>
            <div class="profile-content">
                <div class="profile-left-column">
                    <div class="profile-section">
                        <h3>Account Information</h3>
                        <div style="display: flex; flex-direction: column; gap: 12px; margin-top: 8px;">
                            <div class="profile-info">
                                <div class="profile-info-item">
                                    <span class="profile-info-label">Email</span>
                                    <span class="profile-info-value" id="profileEmail"></span>
                                </div>
                            </div>
                            <div class="profile-info editable">
                                <div class="profile-info-item">
                                    <span class="profile-info-label">Name</span>
                                    <input type="text" id="profileName" class="profile-editable-input" value="" placeholder="Enter your name">
                                </div>
                            </div>
                            <div class="profile-info editable">
                                <div class="profile-info-item">
                                    <span class="profile-info-label">Password</span>
                                    <div class="password-input-wrapper">
                                        <input type="password" id="profilePassword" class="profile-editable-input password-input" value="••••••••" readonly>
                                        <button type="button" id="togglePasswordBtn" class="password-toggle-btn" onclick="togglePasswordVisibility()">
                                            <svg id="eyeIcon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                                <circle cx="12" cy="12" r="3"></circle>
                                            </svg>
                                            <svg id="eyeOffIcon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
                                                <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
                                                <line x1="1" y1="1" x2="23" y2="23"></line>
                                            </svg>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e2e8f0;">
                            <button class="logout-btn" onclick="showLogoutConfirm()">Log out</button>
                        </div>
                    </div>
                </div>

                <div class="profile-right-column">
                    <div class="profile-section">
                        <h3>My Tags</h3>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <div style="display: flex; gap: 8px;">
                                <button id="viewFoldersBtn" class="view-btn active" onclick="handleViewFoldersClick()" title="View folders">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
                                    </svg>
                                </button>
                                <button id="viewTagsBtn" class="view-btn" onclick="handleViewTagsClick()" title="View all tags">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
                                        <line x1="7" y1="7" x2="7.01" y2="7"></line>
                                    </svg>
                                </button>
                            </div>
                            <input type="text" id="tagsSearchInput" placeholder="Search tags..." style="flex: 1; max-width: 250px; height: 36px; padding: 8px 12px; border-radius: 8px; border: 2px solid #e2e8f0; background: #ffffff; font-size: 14px; transition: all 0.2s ease; margin: 0 8px; outline: none;" oninput="handleTagsSearch()" onfocus="this.style.borderColor='#3b82f6'; this.style.boxShadow='0 0 0 3px rgba(59, 130, 246, 0.1)'" onblur="this.style.borderColor='#e2e8f0'; this.style.boxShadow='none'">
                            <button id="sortOrderBtn" class="view-btn" onclick="toggleSortOrder()" title="Toggle sort order">
                                <svg id="sortAscIcon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M15 5h4"></path>
                                    <path d="M12 9h7"></path>
                                    <path d="M12 13h7"></path>
                                    <path d="M12 17h7"></path>
                                    <path d="M3 5l3-3 3 3"></path>
                                    <path d="M6 2v20"></path>
                                </svg>
                                <svg id="sortDescIcon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
                                    <path d="M12 5h7"></path>
                                    <path d="M12 9h7"></path>
                                    <path d="M12 13h7"></path>
                                    <path d="M15 17h4"></path>
                                    <path d="M3 19l3 3 3-3"></path>
                                    <path d="M6 22V2"></path>
                                </svg>
                            </button>
                            <button id="openCreateTagMenuBtn" class="create-btn" onclick="showCreateMenu()" title="Create">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                    <line x1="12" y1="5" x2="12" y2="19"></line>
                                    <line x1="5" y1="12" x2="19" y2="12"></line>
                                </svg>
                            </button>
                        </div>
                        <div id="profileTagsList" class="tags-list" style="display: flex; gap: 16px; margin-bottom: 4px; flex: 1; min-height: 0; overflow: hidden; box-sizing: border-box; align-items: flex-start;">
                            <div id="foldersColumn" style="width: 200px; display: flex; flex-direction: column; gap: 8px; overflow-y: auto; padding-right: 8px; flex-shrink: 0; box-sizing: border-box; max-height: 332px;"></div>
                            <div id="tagsColumn" style="flex: 1; display: flex; flex-direction: column; gap: 8px; overflow-y: auto; padding: 12px; padding-bottom: 16px; background: #f8fafc; border-radius: 12px; border: 1px solid #e2e8f0; min-height: 0; box-sizing: border-box; height: 332px; max-height: 332px;"></div>
                            <div id="allTagsColumn" style="flex: 1; display: none; flex-direction: column; gap: 8px; overflow-y: auto; padding: 12px; padding-bottom: 16px; background: #f8fafc; border-radius: 12px; border: 1px solid #e2e8f0; min-height: 0; box-sizing: border-box; height: 332px; max-height: 332px;"></div>
                        </div>
                        <div class="new-folder-form" style="margin-bottom: 4px; margin-top: 0; display: none; flex-shrink: 0;" id="newFolderForm">
                            <input type="text" id="profileNewFolderName" placeholder="Folder name" style="flex: 1;">
                            <input type="color" id="profileNewFolderColor" value="#64748b" style="width: 60px; height: 44px; border-radius: 8px; cursor: pointer;">
                            <button type="button" onclick="createFolderFromProfile()" style="white-space: nowrap; background: #64748b; color: white;">Create Folder</button>
                        </div>
                        <div class="new-tag-form" style="margin-top: 0; margin-bottom: 0; display: none; flex-shrink: 0;" id="newTagForm">
                            <input type="text" id="profileNewTagName" placeholder="Tag name" maxlength="20" style="flex: 1;">
                            <input type="color" id="profileNewTagColor" value="#3b82f6" style="width: 60px; height: 44px; border-radius: 8px; cursor: pointer;">
                            <select id="profileNewTagFolder" style="flex: 1; max-width: 150px; padding: 8px; border-radius: 8px; border: 1px solid #e2e8f0;">
                                <option value="">No folder</option>
                            </select>
                            <button type="button" onclick="createTagFromProfile()" style="white-space: nowrap;">Add Tag</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Logout Confirmation Modal -->
    <div id="logoutConfirmOverlay" class="logout-confirm-overlay" onclick="closeLogoutConfirmOnOverlay(event)">
        <div class="logout-confirm-modal" onclick="event.stopPropagation()">
            <div class="logout-confirm-content">
                <h3>Are you sure you want to log out?</h3>
                <p>You will need to log in again to access your tasks.</p>
                <div class="logout-confirm-buttons">
                    <button class="logout-confirm-btn logout-confirm-yes" onclick="confirmLogout()">Yes, log out</button>
                    <button class="logout-confirm-btn logout-confirm-no" onclick="closeLogoutConfirm()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Tags Selection Modal -->
    <div id="tagsModalOverlay" class="task-modal-overlay" onclick="closeTagsModalOnOverlay(event)">
        <div class="task-modal" onclick="event.stopPropagation()">
            <div class="task-modal-header">
                <h2>Select Tags</h2>
                <button class="task-modal-close" onclick="closeTagsModal()">×</button>
            </div>
            <div class="task-modal-content">
                <div class="profile-section" style="margin-bottom: 0; box-shadow: none; border: none; padding: 0; border-radius: 0; background: transparent;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <div style="display: flex; gap: 8px;">
                            <button id="tagsModalViewFoldersBtn" class="view-btn active" onclick="handleTagsModalViewFoldersClick()" title="View folders">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
                                </svg>
                            </button>
                            <button id="tagsModalViewTagsBtn" class="view-btn" onclick="handleTagsModalViewTagsClick()" title="View all tags">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
                                    <line x1="7" y1="7" x2="7.01" y2="7"></line>
                                </svg>
                            </button>
                        </div>
                        <input type="text" id="tagsModalSearchInput" placeholder="Search tags..." style="flex: 1; max-width: 220px; height: 36px; padding: 8px 12px; border-radius: 8px; border: 2px solid #e2e8f0; background: #ffffff; font-size: 14px; transition: all 0.2s ease; margin: 0 8px; outline: none;" oninput="handleTagsModalSearch()" onfocus="this.style.borderColor='#3b82f6'; this.style.boxShadow='0 0 0 3px rgba(59, 130, 246, 0.1)'" onblur="this.style.borderColor='#e2e8f0'; this.style.boxShadow='none'">
                        <div style="display: flex; gap: 8px;">
                            <button id="tagsModalSortOrderBtn" class="view-btn" onclick="toggleTagsModalSortOrder()" title="Toggle sort order">
                                <svg id="tagsModalSortAscIcon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M15 5h4"></path>
                                    <path d="M12 9h7"></path>
                                    <path d="M12 13h7"></path>
                                    <path d="M12 17h7"></path>
                                    <path d="M3 5l3-3 3 3"></path>
                                    <path d="M6 2v20"></path>
                                </svg>
                                <svg id="tagsModalSortDescIcon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
                                    <path d="M12 5h7"></path>
                                    <path d="M12 9h7"></path>
                                    <path d="M12 13h7"></path>
                                    <path d="M15 17h4"></path>
                                    <path d="M3 19l3 3 3-3"></path>
                                    <path d="M6 22V2"></path>
                                </svg>
                            </button>
                            <button id="tagsModalCreateTagBtn" class="create-btn" onclick="openCreateChoiceModalFromTagsModal()" title="Create">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                    <line x1="12" y1="5" x2="12" y2="19"></line>
                                    <line x1="5" y1="12" x2="19" y2="12"></line>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div id="tagsModalTagsList" class="tags-list" style="display: flex; gap: 10px; margin-bottom: 0; flex: 1; min-height: 0; overflow: hidden; box-sizing: border-box; align-items: flex-start; height: 350px; max-height: 350px;">
                        <div id="tagsModalFoldersColumn" style="flex: 1; display: flex; flex-direction: column; gap: 6px; overflow-y: auto; padding-right: 6px; box-sizing: border-box; height: 350px; max-height: 350px; min-width: 0;"></div>
                        <div id="tagsModalTagsColumn" style="flex: 1; display: flex; flex-direction: column; gap: 6px; overflow-y: auto; padding: 10px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0; min-height: 0; box-sizing: border-box; height: 350px; max-height: 350px; min-width: 0;"></div>
                        <div id="tagsModalAllTagsColumn" style="flex: 1; display: none; flex-direction: column; gap: 6px; overflow-y: auto; padding: 10px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0; min-height: 0; box-sizing: border-box; height: 350px; max-height: 350px;"></div>
                    </div>
                </div>
                <div class="new-tag-form" style="margin-top: 10px; margin-bottom: 0; display: none; flex-shrink: 0;" id="tagsModalNewTagForm">
                    <input type="text" id="tagsModalNewTagName" placeholder="Tag name" maxlength="20" style="flex: 1;">
                    <input type="color" id="tagsModalNewTagColor" value="#3b82f6" style="width: 60px; height: 44px; border-radius: 8px; cursor: pointer;">
                    <select id="tagsModalNewTagFolder" style="flex: 1; max-width: 150px; padding: 8px; border-radius: 8px; border: 1px solid #e2e8f0;">
                        <option value="">No folder</option>
                    </select>
                    <button type="button" onclick="createTagFromTagsModal()" style="white-space: nowrap;">Add Tag</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Create Tag Modal -->
    <div id="createTagModalOverlay" class="task-modal-overlay" onclick="closeCreateTagModalOnOverlay(event)">
        <div class="task-modal" onclick="event.stopPropagation()">
            <div class="task-modal-header">
                <h2>Create Tag</h2>
                <button class="task-modal-close" onclick="closeCreateTagModal()">×</button>
            </div>
            <div class="task-modal-content">
                <form id="createTagForm" onsubmit="handleCreateTagSubmit(event)">
                    <div style="display: flex; align-items: flex-start; gap: 16px; margin-bottom: 16px; justify-content: space-between;">
                        <div style="flex: 1; display: flex; flex-direction: column; gap: 4px; min-width: 0;">
                            <label for="createTagName" style="font-size: 13px; font-weight: 500; color: #1e293b; margin: 0;">Name</label>
                            <input type="text" id="createTagName" required maxlength="15" placeholder="Enter tag name" title="Please fill in this field" style="height: 36px; padding: 8px 12px; border-radius: 8px; border: 2px solid #e2e8f0; background: #ffffff; font-size: 14px; outline: none; transition: all 0.2s ease; width: 100%; box-sizing: border-box;" oninput="updateCreateTagPreview(); this.setCustomValidity(''); if (this.value.length > 15) this.value = this.value.slice(0, 15); toggleCreateTagButton();" oninvalid="this.setCustomValidity('Please enter a tag name (max 15 characters)'); this.title='Please fill in this field';" onfocus="this.style.borderColor='#3b82f6'; this.style.boxShadow='0 0 0 3px rgba(59, 130, 246, 0.1)';" onblur="this.style.borderColor='#e2e8f0'; this.style.boxShadow='none'">
                        </div>
                        <div style="display: flex; gap: 16px; align-items: flex-end; flex-shrink: 0;">
                            <div style="display: flex; flex-direction: column; gap: 4px; align-items: center;">
                                <label for="createTagColorBtn" style="font-size: 13px; font-weight: 500; color: #1e293b; margin: 0; text-align: center;">Color</label>
                                <button type="button" id="createTagColorBtn" class="view-btn" title="Select color" onclick="showCreateTagColorMenu(event)" style="width: 50px; height: 36px;">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
                                        <line x1="7" y1="7" x2="7.01" y2="7"></line>
                                    </svg>
                                </button>
                            </div>
                            <div style="display: flex; flex-direction: column; gap: 4px; align-items: center;">
                                <label for="createTagFolderBtn" style="font-size: 13px; font-weight: 500; color: #1e293b; margin: 0; text-align: center;">Folder</label>
                                <button type="button" id="createTagFolderBtn" class="view-btn" title="Select folder" onclick="showCreateTagFolderMenu(event)" style="width: 50px; height: 36px;">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
                                    </svg>
                                </button>
                            </div>
                            <div style="display: flex; flex-direction: column; gap: 4px; align-items: center;">
                                <label for="createTagPinnedBtn" style="font-size: 13px; font-weight: 500; color: #1e293b; margin: 0; text-align: center;">Pin</label>
                                <button type="button" id="createTagPinnedBtn" class="view-btn" title="Pin to top" onclick="toggleCreateTagPin()" style="width: 50px; height: 36px;">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M17 12l4.5-2.5-7-7-2.5 4.5L3.5 10.5l10 10Z"></path>
                                        <path d="m1.5 22.5 7-7"></path>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <input type="hidden" id="createTagColor" value="#3b82f6">
                    </div>
                    <div id="createTagPreviewContainer" style="margin: 12px 0; display: flex; flex-direction: row; align-items: center; justify-content: center; gap: 12px;">
                        <div id="createTagPreviewBox" class="tag-item" style="display: flex; align-items: center; gap: 6px; padding: 6px 8px; background: #ffffff; border-radius: 6px; margin-bottom: 0; border: 1px solid #e2e8f0; width: 280px; max-width: 280px; height: 36px; min-height: 36px; max-height: 36px; box-sizing: border-box; box-shadow: inset 0 -1px 0 rgba(15, 23, 42, 0.05); cursor: default; overflow: hidden; pointer-events: none; user-select: none;">
                            <div id="createTagPreviewDot" style="width: 12px; height: 12px; border-radius: 50%; background-color: #3b82f6; flex-shrink: 0;"></div>
                            <svg id="createTagPreviewPin" style="width: 14px; height: 14px; display: none; flex-shrink: 0; color: #64748b;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M17 12l4.5-2.5-7-7-2.5 4.5L3.5 10.5l10 10Z"></path>
                                <path d="m1.5 22.5 7-7"></path>
                            </svg>
                            <span id="createTagPreviewText" style="flex: 1; min-width: 0; color: #1e293b; font-size: 14px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-weight: 400;">Sample Tag</span>
                            <span id="createTagPreviewFolder" style="font-size: 12px; color: #64748b; padding: 2px 8px; background: rgba(100, 116, 139, 0.125); border-radius: 4px; border: 1px solid #64748b; font-weight: 400; text-transform: uppercase; display: none; flex-shrink: 0; max-width: 120px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-left: 0;">Folder</span>
                        </div>
                        <div id="createTagTaskPreviewBox" class="tag-checkbox-item selected" style="position: relative; display: flex; align-items: center; justify-content: center; padding: 6px 18px; border: 2px solid #3b82f6; border-radius: 999px; background: #3b82f6; color: #ffffff; font-weight: 500; min-width: 100px; max-width: 180px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; pointer-events: none; user-select: none;">
                            <span id="createTagTaskPreviewText" style="color: #ffffff; font-weight: 500;">Sample Tag</span>
                        </div>
                    </div>
                    <div style="display: flex; gap: 12px; justify-content: center; margin-top: 8px;">
                        <button type="button" onclick="closeCreateTagModal()" style="min-width: 110px; text-align: center; background: #f1f5f9; color: #475569; border: 1px solid #e2e8f0; padding: 8px 16px; border-radius: 6px; font-size: 13px; font-weight: 500; cursor: pointer;">Cancel</button>
                        <button type="submit" id="createTagSubmitBtn" disabled style="min-width: 110px; text-align: center; background: #93c5fd; color: white; border: none; padding: 8px 16px; border-radius: 6px; font-size: 13px; font-weight: 500; cursor: not-allowed; opacity: 0.7;">Create Tag</button>
                    </div>
                    <input type="hidden" id="createTagFolderHidden" value="">
                    <input type="hidden" id="createTagPinnedHidden" value="false">
                </form>
            </div>
        </div>
    </div>

    <!-- Create Choice Modal (New Tag or New Folder) -->
    <div id="createChoiceModalOverlay" class="task-modal-overlay" onclick="closeCreateChoiceModalOnOverlay(event)" style="background: transparent; backdrop-filter: none;">
        <div id="createChoiceMenu" class="context-menu" onclick="event.stopPropagation()" style="display: flex;">
            <div class="context-menu-item" onclick="openCreateTagFromChoice()">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
                    <line x1="7" y1="7" x2="7.01" y2="7"></line>
                </svg>
                <span>New Tag</span>
            </div>
            <div class="context-menu-item" onclick="openCreateFolderFromChoice()">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
                </svg>
                <span>New Folder</span>
            </div>
        </div>
    </div>

    <!-- Create Folder Modal -->
    <div id="createFolderModalOverlay" class="task-modal-overlay" onclick="closeCreateFolderModalOnOverlay(event)">
        <div class="task-modal" onclick="event.stopPropagation()">
            <div class="task-modal-header">
                <h2>New Folder</h2>
                <button class="task-modal-close" onclick="closeCreateFolderModal()">×</button>
            </div>
            <div class="task-modal-content">
                <form id="createFolderForm" onsubmit="handleCreateFolderSubmit(event)">
                    <div style="display: flex; align-items: flex-start; gap: 16px; margin-bottom: 16px; justify-content: space-between;">
                        <div style="flex: 1; display: flex; flex-direction: column; gap: 4px; min-width: 0;">
                            <label for="createFolderName" style="font-size: 13px; font-weight: 500; color: #1e293b; margin: 0;">Name</label>
                            <input type="text" id="createFolderName" required maxlength="15" placeholder="Enter folder name" title="Please fill in this field" style="height: 36px; padding: 8px 12px; border-radius: 8px; border: 2px solid #e2e8f0; background: #ffffff; font-size: 14px; outline: none; transition: all 0.2s ease; width: 100%; box-sizing: border-box;" oninput="this.setCustomValidity(''); if (this.value.length > 15) this.value = this.value.slice(0, 15); toggleCreateFolderButton(); updateCreateFolderPreview();" oninvalid="this.setCustomValidity('Please enter a folder name (max 15 characters)'); this.title='Please fill in this field';" onfocus="this.style.borderColor='#3b82f6'; this.style.boxShadow='0 0 0 3px rgba(59, 130, 246, 0.1)';" onblur="this.style.borderColor='#e2e8f0'; this.style.boxShadow='none'">
                        </div>
                        <div style="display: flex; gap: 16px; align-items: flex-end; flex-shrink: 0;">
                            <div style="display: flex; flex-direction: column; gap: 4px; align-items: center;">
                                <label for="createFolderColorBtn" style="font-size: 13px; font-weight: 500; color: #1e293b; margin: 0; text-align: center;">Color</label>
                                <button type="button" id="createFolderColorBtn" class="view-btn" title="Select color" onclick="showCreateFolderColorMenu(event)" style="width: 50px; height: 36px;">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
                                    </svg>
                                </button>
                            </div>
                            <div style="display: flex; flex-direction: column; gap: 4px; align-items: center;">
                                <label for="createFolderPinnedBtn" style="font-size: 13px; font-weight: 500; color: #1e293b; margin: 0; text-align: center;">Pin</label>
                                <button type="button" id="createFolderPinnedBtn" class="view-btn" title="Pin to top" onclick="toggleCreateFolderPin()" style="width: 50px; height: 36px;">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M17 12l4.5-2.5-7-7-2.5 4.5L3.5 10.5l10 10Z"></path>
                                        <path d="m1.5 22.5 7-7"></path>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <input type="hidden" id="createFolderColor" value="#64748b">
                        <input type="hidden" id="createFolderPinnedHidden" value="false">
                    </div>
                    <div id="createFolderPreviewContainer" style="margin: 8px 0; display: flex; justify-content: center;">
                        <div id="createFolderPreviewCard" style="padding: 10px 14px; background: #f1f5f9; border-radius: 8px; border-left: 4px solid #64748b; border-right: 2px solid #e2e8f0; border-top: 2px solid #e2e8f0; border-bottom: 2px solid #e2e8f0; width: 240px; max-width: 260px; min-height: 46px; display: flex; align-items: center; gap: 8px; position: relative; box-sizing: border-box;">
                            <span id="createFolderPreviewName" style="font-weight: 600; font-size: 14px; color: #64748b; text-transform: uppercase; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1;">Sample Folder</span>
                            <svg id="createFolderPreviewPin" style="width: 16px; height: 16px; color: #64748b; display: none; flex-shrink: 0;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M17 12l4.5-2.5-7-7-2.5 4.5L3.5 10.5l10 10Z"></path>
                                <path d="m1.5 22.5 7-7"></path>
                            </svg>
                        </div>
                    </div>
                    <div style="display: flex; gap: 12px; justify-content: center; margin-top: 6px;">
                        <button type="button" onclick="closeCreateFolderModal()" style="min-width: 110px; text-align: center; background: #f1f5f9; color: #475569; border: 1px solid #e2e8f0; padding: 8px 16px; border-radius: 6px; font-size: 13px; font-weight: 500; cursor: pointer;">Cancel</button>
                        <button type="submit" id="createFolderSubmitBtn" disabled style="min-width: 110px; text-align: center; background: #93c5fd; color: white; border: none; padding: 8px 16px; border-radius: 6px; font-size: 13px; font-weight: 500; cursor: not-allowed; opacity: 0.7;">Create Folder</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div id="contextMenu" class="context-menu" style="display: none;" onclick="event.stopPropagation()">
        <div id="contextMenuOptions" style="display: flex; flex-direction: column; gap: 4px;">
            <div id="contextMenuPinOption" class="context-menu-item" onclick="handleContextMenuPin()">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M17 12l4.5-2.5-7-7-2.5 4.5L3.5 10.5l10 10Z"></path>
                    <path d="m1.5 22.5 7-7"></path>
                    <line id="contextMenuPinSlash" x1="3" y1="3" x2="21" y2="21" stroke="currentColor" stroke-width="2" style="display: none;"></line>
                </svg>
                <span id="contextMenuPinOptionLabel">Pin</span>
            </div>
        <div id="contextMenuEditOption" class="context-menu-item" onclick="handleContextMenuEdit()">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
            </svg>
            <span>Edit</span>
        </div>
        <div id="contextMenuDeleteOption" class="context-menu-item context-menu-item-danger" onclick="handleContextMenuDelete()">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
            </svg>
            <span>Delete</span>
            </div>
        </div>
        <div id="contextMenuConfirm" class="context-menu-confirm">
            <div class="context-menu-confirm-title" id="contextMenuConfirmTitle">Are you sure?</div>
            <div class="context-menu-confirm-buttons">
                <button class="context-menu-btn context-menu-btn-cancel" onclick="cancelContextMenuDelete()">Cancel</button>
                <button class="context-menu-btn context-menu-btn-delete" onclick="confirmContextMenuDelete()">Delete</button>
            </div>
        </div>
    </div>

    <script>
        const API_URL = '/api/tasks';
        const AUTH_URL = '/api/auth';
        const TAGS_URL = '/api/tags';
        const FOLDERS_URL = '/api/folders';
        const UPLOAD_URL = '/api/upload';
        const TAG_PRESET_COLORS = [
            '#3b82f6', // Blue
            '#ef4444', // Red
            '#10b981', // Green
            '#fbbf24', // Amber/Yellow (lighter)
            '#f97316', // Orange
            '#8b5cf6', // Purple
            '#ec4899', // Pink
            '#a16207', // Brown
            '#84cc16', // Lime
            '#64748b'  // Gray
        ];
        
        const FOLDER_PRESET_COLORS = [
            '#1d4ed8', // Darker blue
            '#b91c1c', // Darker red
            '#059669', // Darker green
            '#c98f00', // Deep yellow/gold
            '#ea580c', // Darker orange
            '#7c3aed', // Darker purple
            '#c026d3', // Darker pink
            '#6b3d05', // Darker brown
            '#3a5c0b', // Darker lime
            '#64748b'  // Gray
        ];
        let tasks = [];
        let tags = [];
        let folders = [];
        let viewMode = 'folders'; // 'folders' or 'tags'
        let selectedFolderId = null; // Currently selected folder
        let tagsSearchTerm = ''; // Search term for filtering tags
        let tagsSortOrder = 'asc'; // 'asc' for ascending (A-Z), 'desc' for descending (Z-A)
        // Tags modal state
        let tagsModalViewMode = 'folders'; // 'folders' or 'tags'
        let tagsModalSelectedFolderId = null; // Currently selected folder in modal
        let tagsModalSearchTerm = ''; // Search term for filtering tags in modal
        let tagsModalSortOrder = 'asc'; // 'asc' for ascending (A-Z), 'desc' for descending (Z-A)
        let tagsModalBaselineHeight = null; // Stores baseline content height for tags modal
        let datePickerState = {
            displayInput: null,
            hiddenInput: null,
            popover: null,
            isOpen: false,
            outsideHandler: null,
            keyHandler: null,
            calendarDaysContainer: null,
            calendarMonthLabel: null,
            calendarYear: null,
            calendarMonth: null,
            calendarMode: 'month', // 'month' or 'year'
            monthViewBaseHeight: null,
            shouldReplaceOnInput: false,
            previousValue: null
        };
        let timePickerState = {
            input: null,
            popover: null,
            hoursBar: null,
            minutesBar: null,
            selectedHour: null,
            selectedMinute: null,
            isOpen: false,
            outsideHandler: null,
            keyHandler: null,
            hiddenInput: null,
            shouldReplaceOnInput: false,
            previousValue: null
        };
        const DATE_PICKER_MONTH_NAMES = [
            'January', 'February', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'
        ];
        let selectedTagsForTask = []; // Array of tag IDs selected for the current task (max 3)
        let tagsModalOpened = false; // Flag to track if tags modal has been opened
        let token = localStorage.getItem('token');
        let userName = localStorage.getItem('userName') || '';
        let userEmail = localStorage.getItem('userEmail') || '';
        let currentTaskImage = null;
        let currentFilter = 'pending'; // 'pending', 'completed', 'all'
        let searchQuery = ''; // Current search query
        let tagFormMode = 'create';
        let editingTagId = null;
        let tagOriginalData = null;
        let folderFormMode = 'create';
        let editingFolderId = null;
        let folderOriginalData = null;

        // Check if user is logged in
        if (token) {
            userName = localStorage.getItem('userName') || '';
            userEmail = localStorage.getItem('userEmail') || '';
            showApp().catch(error => {
                console.error('Error initializing app:', error);
                showAuth();
            });
        } else {
            showAuth();
        }

        function showAuth() {
            document.getElementById('authScreen').style.display = 'flex';
            document.getElementById('appScreen').style.display = 'none';
        }

        // Calendar state
        let currentCalendarDate = new Date();

        async function showApp() {
            document.getElementById('authScreen').style.display = 'none';
            document.getElementById('appScreen').style.display = 'flex';
            updateUserDisplay();
            // Load tasks, tags and folders in parallel, but wait for all to complete
            try {
                await Promise.all([loadTasks(), loadTags(), loadFolders()]);
                updateTagSelect();
                renderCalendar();
            } catch (error) {
                console.error('Error loading app data:', error);
                showMessage('Error loading data', 'error');
            }
        }

        // Task Modal Functions
        function openTaskModal() {
            const modal = document.getElementById('taskModalOverlay');
            if (modal) {
                resetTaskForm();
                modal.classList.add('active');
                // Focus on title input
                setTimeout(() => {
                    const titleInput = document.getElementById('taskTitle');
                    if (titleInput) {
                        titleInput.focus();
                    }
                }, 100);
            }
        }

        function closeTaskModal() {
            const modal = document.getElementById('taskModalOverlay');
            if (modal) {
                modal.classList.remove('active');
            }
        }

        function closeTaskModalOnOverlay(event) {
            if (event.target.id === 'taskModalOverlay') {
                closeTaskModal();
            }
        }

        function resetTaskForm() {
            document.getElementById('taskForm').reset();
            syncDateDisplayFromHidden();
            removeTaskImage();
            // Clear tag selections
            document.querySelectorAll('#taskTags .tag-checkbox-item').forEach(item => {
                item.classList.remove('selected');
            });
            // Clear selected tags from modal
            selectedTagsForTask = [];
            tagsModalOpened = false; // Reset modal opened flag
            updateTagSelect();
            // Re-render tags modal if it's open
            const tagsModal = document.getElementById('tagsModalOverlay');
            if (tagsModal && tagsModal.classList.contains('active')) {
                renderTagsModal();
            }
            document.getElementById('taskTitle').focus();
        }

        // Calendar Functions
        function renderCalendar() {
            const container = document.getElementById('calendarContainer');
            if (!container) return;

            const year = currentCalendarDate.getFullYear();
            const month = currentCalendarDate.getMonth();

            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const daysInMonth = lastDay.getDate();
            const startingDayOfWeek = firstDay.getDay();

            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
            const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

            let html = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                    <button onclick="previousMonth()" style="padding: 6px 12px; background: #f1f5f9; border: 1px solid #e2e8f0; border-radius: 6px; cursor: pointer; font-size: 14px;">←</button>
                    <h3 style="margin: 0; font-size: 16px; font-weight: 600; color: #0f172a;">${monthNames[month]} ${year}</h3>
                    <button onclick="nextMonth()" style="padding: 6px 12px; background: #f1f5f9; border: 1px solid #e2e8f0; border-radius: 6px; cursor: pointer; font-size: 14px;">→</button>
                </div>
                <div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 4px; margin-bottom: 8px;">
            `;

            // Day names header
            dayNames.forEach(day => {
                html += `<div style="text-align: center; font-size: 12px; font-weight: 600; color: #64748b; padding: 8px;">${day}</div>`;
            });

            html += `</div><div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 4px;">`;

            // Empty cells for days before month starts
            for (let i = 0; i < startingDayOfWeek; i++) {
                html += `<div style="aspect-ratio: 1; background: #f8fafc; border-radius: 6px;"></div>`;
            }

            // Days of the month
            for (let day = 1; day <= daysInMonth; day++) {
                html += `<div style="aspect-ratio: 1; background: #ffffff; border: 1px solid #e2e8f0; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-size: 13px; color: #1e293b; cursor: pointer; transition: all 0.2s ease;" onmouseover="this.style.background='#f8fafc'; this.style.borderColor='#cbd5e1'" onmouseout="this.style.background='#ffffff'; this.style.borderColor='#e2e8f0'">${day}</div>`;
            }

            html += `</div>`;
            container.innerHTML = html;
        }

        function previousMonth() {
            currentCalendarDate.setMonth(currentCalendarDate.getMonth() - 1);
            renderCalendar();
        }

        function nextMonth() {
            currentCalendarDate.setMonth(currentCalendarDate.getMonth() + 1);
            renderCalendar();
        }

        function updateUserDisplay() {
            const displayText = userName ? `${userName} (${userEmail})` : userEmail;
            const userEmailEl = document.getElementById('userEmail');
            if (userEmailEl) {
                userEmailEl.textContent = displayText;
            }
            
            // Update profile window
            const profileInitial = document.getElementById('profileInitial');
            const profileWindowName = document.getElementById('profileWindowName');
            const profileWindowEmail = document.getElementById('profileWindowEmail');
            
            if (profileInitial) {
                const initial = userName ? userName.charAt(0).toUpperCase() : (userEmail ? userEmail.charAt(0).toUpperCase() : 'U');
                profileInitial.textContent = initial;
            }
            if (profileWindowName) {
                profileWindowName.textContent = userName || 'User';
            }
            if (profileWindowEmail) {
                profileWindowEmail.textContent = userEmail || '';
            }
        }

        function showMessage(text, type) {
            const msg = document.getElementById('message');
            msg.textContent = text;
            msg.className = `message ${type}`;
            msg.style.display = 'block';
            setTimeout(() => {
                msg.textContent = '';
                msg.style.display = 'none';
            }, 3000);
        }

        function getAuthHeaders() {
            return {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            };
        }

        function showLogin() {
            document.querySelectorAll('.auth-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.auth-form').forEach(form => form.classList.remove('active'));
            document.querySelector('.auth-tab').classList.add('active');
            document.getElementById('loginForm').classList.add('active');
        }

        function showRegister() {
            document.querySelectorAll('.auth-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.auth-form').forEach(form => form.classList.remove('active'));
            document.querySelectorAll('.auth-tab')[1].classList.add('active');
            document.getElementById('registerForm').classList.add('active');
        }

        // Login
        document.getElementById('loginForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const email = document.getElementById('loginEmail').value.trim();
            const password = document.getElementById('loginPassword').value.trim();

            try {
                const res = await fetch(`${AUTH_URL}/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email, password })
                });

                const data = await res.json();
                if (!res.ok) {
                    showMessage(data.message || 'Login failed', 'error');
                    return;
                }

                token = data.token;
                userName = data.name || '';
                userEmail = data.email;
                // Store plain password if available (from login response)
                if (data.passwordPlain) {
                    localStorage.setItem('userPasswordPlain', data.passwordPlain);
                }
                localStorage.setItem('token', token);
                localStorage.setItem('userName', userName);
                localStorage.setItem('userEmail', userEmail);
                loadNoFolderPinnedState();
                showMessage('Login successful', 'success');
                await showApp();
            } catch (error) {
                showMessage('Error logging in', 'error');
            }
        });

        // Register
        document.getElementById('registerForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const name = document.getElementById('registerName').value.trim();
            const email = document.getElementById('registerEmail').value.trim();
            const password = document.getElementById('registerPassword').value.trim();

            if (!name) {
                showMessage('Name is required', 'error');
                return;
            }

            try {
                const res = await fetch(`${AUTH_URL}/register`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, email, password })
                });

                const data = await res.json();
                if (!res.ok) {
                    showMessage(data.message || 'Registration failed', 'error');
                    return;
                }

                showMessage('Registration successful! Please login.', 'success');
                showLogin();
                document.getElementById('loginEmail').value = email;
            } catch (error) {
                showMessage('Error registering', 'error');
            }
        });

        let passwordVisible = false;
        let userPasswordPlain = '';
        const PASSWORD_PLACEHOLDER = '••••••••';

        async function loadUserPassword() {
            try {
                const res = await fetch(`${AUTH_URL}/password`, {
                    headers: getAuthHeaders()
                });
                
                if (res.status === 401) {
                    logout();
                    return;
                }
                
                if (res.ok) {
                    const data = await res.json();
                    userPasswordPlain = data.passwordPlain || '';
                }
            } catch (error) {
                console.error('Error loading password:', error);
            }
        }

        function openProfile() {
            const overlay = document.getElementById('profileOverlay');
            overlay.classList.add('active');
            document.getElementById('profileEmail').textContent = userEmail;
            document.getElementById('profileName').value = userName || '';
            
            // Try to get password from localStorage first, then from API
            userPasswordPlain = localStorage.getItem('userPasswordPlain') || '';
            loadUserPassword(); // Also load from API in case it's updated
            
            const passwordInput = document.getElementById('profilePassword');
            passwordInput.value = PASSWORD_PLACEHOLDER;
            passwordInput.type = 'password';
            passwordInput.readOnly = true;
            passwordInput.style.color = '#1e293b';
            passwordInput.style.letterSpacing = 'normal';
            passwordInput.style.cursor = 'default';
            passwordInput.style.pointerEvents = 'none';
            passwordVisible = false;
            document.getElementById('eyeIcon').style.display = 'block';
            document.getElementById('eyeOffIcon').style.display = 'none';
            loadTags(); // Refresh tags in profile
            loadFolders(); // Refresh folders in profile
            
            // Setup name input with debounce
            setupNameInput();
        }

        function togglePasswordVisibility() {
            const passwordInput = document.getElementById('profilePassword');
            const eyeIcon = document.getElementById('eyeIcon');
            const eyeOffIcon = document.getElementById('eyeOffIcon');
            
            if (passwordVisible) {
                // Ocultar contraseña - guardar cambios si se editó
                const currentValue = passwordInput.value;
                if (currentValue !== PASSWORD_PLACEHOLDER && currentValue !== userPasswordPlain) {
                    // La contraseña fue editada, actualizarla
                    updatePasswordFromProfile(currentValue);
                }
                
                passwordInput.type = 'password';
                passwordInput.value = PASSWORD_PLACEHOLDER;
                passwordInput.readOnly = true;
                passwordInput.style.color = '#1e293b';
                passwordInput.style.letterSpacing = 'normal';
                passwordInput.style.cursor = 'default';
                passwordInput.style.pointerEvents = 'none';
                eyeIcon.style.display = 'block';
                eyeOffIcon.style.display = 'none';
                passwordInput.title = '';
                passwordVisible = false;
            } else {
                // Mostrar contraseña real - permitir edición
                const passwordToShow = userPasswordPlain || PASSWORD_PLACEHOLDER;
                passwordInput.type = 'text';
                passwordInput.value = passwordToShow;
                passwordInput.readOnly = false;
                passwordInput.style.color = '#1e293b';
                passwordInput.style.letterSpacing = 'normal';
                passwordInput.style.cursor = 'text';
                passwordInput.style.pointerEvents = 'auto';
                eyeIcon.style.display = 'none';
                eyeOffIcon.style.display = 'block';
                passwordInput.title = 'Click to edit password';
                passwordVisible = true;
            }
        }

        async function updatePasswordFromProfile(newPassword) {
            if (!newPassword || newPassword.trim().length === 0) {
                showMessage('Password cannot be empty', 'error');
                return;
            }

            if (newPassword.length < 6) {
                showMessage('Password must be at least 6 characters', 'error');
                return;
            }

            try {
                // Primero verificar la contraseña actual (necesitamos la actual para cambiarla)
                // Como no tenemos la contraseña actual hasheada, vamos a usar un enfoque diferente:
                // Usar el endpoint de cambio de contraseña con la contraseña actual
                const currentPassword = userPasswordPlain || '';
                
                const res = await fetch(`${AUTH_URL}/change-password`, {
                    method: 'PUT',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ 
                        currentPassword: currentPassword,
                        newPassword: newPassword 
                    })
                });

                if (res.status === 401) {
                    logout();
                    return;
                }

                const data = await res.json();
                if (!res.ok) {
                    showMessage(data.message || 'Error updating password', 'error');
                    // Revertir el valor
                    document.getElementById('profilePassword').value = userPasswordPlain || PASSWORD_PLACEHOLDER;
                    return;
                }

                // Actualizar la contraseña almacenada
                userPasswordPlain = newPassword;
                localStorage.setItem('userPasswordPlain', newPassword);
                
                showMessage('Password updated successfully', 'success');
            } catch (error) {
                console.error('Error updating password:', error);
                showMessage('Error updating password', 'error');
                // Revertir el valor
                document.getElementById('profilePassword').value = userPasswordPlain || PASSWORD_PLACEHOLDER;
            }
        }

        function setupNameInput() {
            const nameInput = document.getElementById('profileName');
            let timeout;
            
            nameInput.addEventListener('input', () => {
                clearTimeout(timeout);
                timeout = setTimeout(async () => {
                    const newName = nameInput.value.trim();
                    if (newName && newName !== userName) {
                        await updateUserName(newName);
                    }
                }, 1000); // Wait 1 second after user stops typing
            });
            
            nameInput.addEventListener('blur', async () => {
                clearTimeout(timeout);
                const newName = nameInput.value.trim();
                if (newName && newName !== userName) {
                    await updateUserName(newName);
                } else if (!newName) {
                    nameInput.value = userName || ''; // Reset if empty
                }
            });
        }

        async function updateUserName(newName) {
            if (!newName) return;
            
            try {
                const res = await fetch(`${AUTH_URL}/update-name`, {
                    method: 'PUT',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ name: newName })
                });

                if (res.status === 401) {
                    logout();
                    return;
                }

                const data = await res.json();
                if (!res.ok) {
                    showMessage(data.message || 'Error updating name', 'error');
                    document.getElementById('profileName').value = userName || ''; // Revert on error
                    return;
                }

                userName = data.name;
                localStorage.setItem('userName', userName);
                updateUserDisplay();
                showMessage('Name updated', 'success');
            } catch (error) {
                showMessage('Error updating name', 'error');
                document.getElementById('profileName').value = userName || ''; // Revert on error
            }
        }

        function closeProfile() {
            const overlay = document.getElementById('profileOverlay');
            overlay.classList.remove('active');
        }

        function closeProfileOnOverlay(event) {
            if (event.target === event.currentTarget) {
                closeProfile();
            }
        }

        function showLogoutConfirm() {
            const overlay = document.getElementById('logoutConfirmOverlay');
            overlay.classList.add('active');
        }

        function closeLogoutConfirm() {
            const overlay = document.getElementById('logoutConfirmOverlay');
            overlay.classList.remove('active');
        }

        function closeLogoutConfirmOnOverlay(event) {
            if (event.target === event.currentTarget) {
                closeLogoutConfirm();
            }
        }

        function confirmLogout() {
            closeLogoutConfirm();
            logout();
        }

        function logout() {
            const previousPinKey = getNoFolderPinStorageKey();
            token = null;
            userName = null;
            userEmail = null;
            localStorage.removeItem('token');
            localStorage.removeItem('userName');
            localStorage.removeItem('userEmail');
            localStorage.removeItem('userPasswordPlain');
            localStorage.removeItem(previousPinKey);
            noFolderPinned = false;
            closeProfile();
            showAuth();
        }

        function showCreateMenu() {
            // Open the choice modal
            openCreateChoiceModal();
        }
        
        // Create Choice Modal Functions
        function openCreateChoiceModal() {
            const modal = document.getElementById('createChoiceModalOverlay');
            const menu = document.getElementById('createChoiceMenu');
            if (modal && menu) {
                // Get the button that triggered this
                const createBtn = document.getElementById('openCreateTagMenuBtn');
                if (createBtn) {
                    const btnRect = createBtn.getBoundingClientRect();
                    // Position menu below the button
                    menu.style.left = btnRect.left + 'px';
                    menu.style.top = (btnRect.bottom + 8) + 'px';
                    
                    // Ensure menu doesn't go off screen
                    const menuRect = menu.getBoundingClientRect();
                    if (menuRect.right > window.innerWidth) {
                        menu.style.left = (window.innerWidth - menuRect.width - 20) + 'px';
                    }
                    if (menuRect.bottom > window.innerHeight) {
                        menu.style.top = (btnRect.top - menuRect.height - 8) + 'px';
                    }
            } else {
                    // Fallback: center on screen
                    menu.style.left = ((window.innerWidth - 180) / 2) + 'px';
                    menu.style.top = ((window.innerHeight - 100) / 2) + 'px';
                }
                modal.classList.add('active');
            }
        }
        
        function openCreateChoiceModalFromTagsModal() {
            const modal = document.getElementById('createChoiceModalOverlay');
            const menu = document.getElementById('createChoiceMenu');
            if (modal && menu) {
                // Get the button that triggered this (from tags modal)
                const createBtn = document.getElementById('tagsModalCreateTagBtn');
                if (createBtn) {
                    const btnRect = createBtn.getBoundingClientRect();
                    // Position menu below the button
                    menu.style.left = btnRect.left + 'px';
                    menu.style.top = (btnRect.bottom + 8) + 'px';
                    
                    // Ensure menu doesn't go off screen
                    setTimeout(() => {
                        const menuRect = menu.getBoundingClientRect();
                        if (menuRect.right > window.innerWidth) {
                            menu.style.left = (window.innerWidth - menuRect.width - 20) + 'px';
                        }
                        if (menuRect.bottom > window.innerHeight) {
                            menu.style.top = (btnRect.top - menuRect.height - 8) + 'px';
                        }
                    }, 0);
                } else {
                    // Fallback: center on screen
                    menu.style.left = ((window.innerWidth - 180) / 2) + 'px';
                    menu.style.top = ((window.innerHeight - 100) / 2) + 'px';
                }
                modal.classList.add('active');
            }
        }
        
        function closeCreateChoiceModal() {
            const modal = document.getElementById('createChoiceModalOverlay');
            if (modal) {
                modal.classList.remove('active');
            }
        }
        
        function closeCreateChoiceModalOnOverlay(event) {
            if (event.target.id === 'createChoiceModalOverlay') {
                closeCreateChoiceModal();
            }
        }
        
        function openCreateTagFromChoice() {
            closeCreateChoiceModal();
            openCreateTagModal();
        }
        
        function openCreateFolderFromChoice() {
            closeCreateChoiceModal();
            openCreateFolderModal();
        }

        function toggleFolder(folderId) {
            const folderTags = document.getElementById(folderId);
            if (folderTags.style.display === 'none' || folderTags.style.display === '') {
                folderTags.style.display = 'block';
            } else {
                folderTags.style.display = 'none';
            }
        }

        async function createFolderFromProfile() {
            const name = document.getElementById('profileNewFolderName').value.trim();
            const color = document.getElementById('profileNewFolderColor').value;

            if (!name) {
                showMessage('Folder name is required', 'error');
                return;
            }

            try {
                const res = await fetch(FOLDERS_URL, {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ name, color })
                });

                if (res.status === 401) {
                    logout();
                    return;
                }

                const data = await res.json();
                if (!res.ok) {
                    showMessage(data.message || 'Error creating folder', 'error');
                    return;
                }

                showMessage('Folder created', 'success');
                document.getElementById('profileNewFolderName').value = '';
                document.getElementById('newFolderForm').style.display = 'none';
                await loadFolders();
            } catch (error) {
                showMessage('Error creating folder', 'error');
            }
        }

        async function createTagFromProfile() {
            const name = document.getElementById('profileNewTagName').value.trim();
            const color = document.getElementById('profileNewTagColor').value;
            const folderId = document.getElementById('profileNewTagFolder').value || null;

            if (!name) {
                showMessage('Tag name is required', 'error');
                return;
            }
            if (name.length > 15) {
                showMessage('Tag name must be 15 characters or less', 'error');
                return;
            }

            try {
                const res = await fetch(TAGS_URL, {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ name, color, folderId: folderId ? parseInt(folderId) : null })
                });

                if (res.status === 401) {
                    logout();
                    return;
                }

                const data = await res.json();
                if (!res.ok) {
                    showMessage(data.message || 'Error creating tag', 'error');
                    return;
                }

                showMessage('Tag created', 'success');
                document.getElementById('profileNewTagName').value = '';
                document.getElementById('newTagForm').style.display = 'none';
                await loadTags();
            } catch (error) {
                showMessage('Error creating tag', 'error');
            }
        }

        // Change Password form removed (password can be edited inline when visible)

        // Tags Management
        async function loadFolders() {
            try {
                const res = await fetch(FOLDERS_URL, {
                    headers: getAuthHeaders()
                });
                
                if (res.status === 401) {
                    logout();
                    return;
                }
                
                const data = await res.json();
                folders = data.map(folder => ({
                    ...folder,
                    pinned: !!folder.pinned
                }));
                updateFolderSelect();
                renderTags();
                // Update tags modal if it's open
                const tagsModal = document.getElementById('tagsModalOverlay');
                if (tagsModal && tagsModal.classList.contains('active')) {
                    renderTagsModal();
                }
            } catch (error) {
                showMessage('Error loading folders', 'error');
            }
        }

        async function loadTags() {
            try {
                const res = await fetch(TAGS_URL, {
                    headers: getAuthHeaders()
                });
                
                if (res.status === 401) {
                    logout();
                    return;
                }
                
                const data = await res.json();
                tags = data.map(tag => ({
                    ...tag,
                    pinned: !!tag.pinned
                }));
                renderTags();
                updateTagSelect();
                // Update tags modal if it's open
                const tagsModal = document.getElementById('tagsModalOverlay');
                if (tagsModal && tagsModal.classList.contains('active')) {
                    renderTagsModal();
                }
            } catch (error) {
                showMessage('Error loading tags', 'error');
            }
        }

        function updateFolderSelect() {
            const select = document.getElementById('profileNewTagFolder');
            const currentValue = select.value;
            select.innerHTML = '<option value="">No folder</option>';
            folders.forEach(folder => {
                const option = document.createElement('option');
                option.value = folder.id;
                option.textContent = escapeHtml(folder.name.toUpperCase());
                select.appendChild(option);
            });
            if (currentValue) {
                select.value = currentValue;
            }
        }

        function setViewMode(mode, reset = false) {
            const wasMode = viewMode;
            const isSameMode = wasMode === mode;
            viewMode = mode;
            
            // Reset selected folder when switching to tags view
            const switchingMode = !isSameMode;
            if (mode === 'tags') {
                selectedFolderId = null;
            }
            if ((reset && isSameMode) || switchingMode) {
                if (mode === 'folders') {
                    // keep selectedFolderId unless reset requested
                    if (reset && isSameMode) selectedFolderId = null;
                } else {
                    selectedFolderId = null;
                }
                tagsSearchTerm = '';
                const searchInput = document.getElementById('tagsSearchInput');
                if (searchInput) {
                    searchInput.value = '';
                }
            }
            
            // Update button states
            const viewFoldersBtn = document.getElementById('viewFoldersBtn');
            const viewTagsBtn = document.getElementById('viewTagsBtn');
            if (viewFoldersBtn) viewFoldersBtn.classList.toggle('active', mode === 'folders');
            if (viewTagsBtn) viewTagsBtn.classList.toggle('active', mode === 'tags');
            
            // Re-render
            renderTags();
        }

        function handleViewFoldersClick() {
            const reset = viewMode === 'folders';
            setViewMode('folders', reset);
            if (reset) {
                setTimeout(() => {
                    const foldersColumn = document.getElementById('foldersColumn');
                    const tagsColumn = document.getElementById('tagsColumn');
                    if (foldersColumn) foldersColumn.scrollTop = 0;
                    if (tagsColumn) tagsColumn.scrollTop = 0;
                }, 0);
            }
        }

        function handleViewTagsClick() {
            const reset = viewMode === 'tags';
            setViewMode('tags', reset);
            if (reset) {
                setTimeout(() => {
                    const allTagsColumn = document.getElementById('allTagsColumn');
                    if (allTagsColumn) allTagsColumn.scrollTop = 0;
                }, 0);
            }
        }

        function renderTags() {
            // Render in profile modal
            const foldersColumn = document.getElementById('foldersColumn');
            const tagsColumn = document.getElementById('tagsColumn');
            const allTagsColumn = document.getElementById('allTagsColumn');
            
            if (!foldersColumn || !tagsColumn || !allTagsColumn) {
                return;
            }
            
            // Update sort button icon
            updateSortButtonIcon();
            
            const searchLower = tagsSearchTerm.trim().toLowerCase();

            if (viewMode === 'tags') {
                // Show all tags in a flat list
                // Hide folders column and tags column, show allTagsColumn
                foldersColumn.style.display = 'none';
                tagsColumn.style.display = 'none';
                allTagsColumn.style.display = 'flex';
                
                if (tags.length === 0) {
                    allTagsColumn.innerHTML = '<div style="color: #94a3b8; font-size: 14px; padding: 20px; text-align: center;">No tags yet. Create your first tag below!</div>';
                    return;
                }

                let html = '';
                // Filter and sort tags alphabetically
                let filteredTags = tags;
                if (tagsSearchTerm.trim()) {
                    const searchLower = tagsSearchTerm.toLowerCase().trim();
                    filteredTags = tags.filter(tag => tag.name.toLowerCase().includes(searchLower));
                }
                const sortedTags = [...filteredTags].sort((a, b) => {
                    // First, sort by pinned status (pinned items first)
                    const aPinned = a.pinned ? 1 : 0;
                    const bPinned = b.pinned ? 1 : 0;
                    if (aPinned !== bPinned) {
                        return bPinned - aPinned;
                    }
                    // Then sort by name
                    const comparison = a.name.localeCompare(b.name);
                    return tagsSortOrder === 'asc' ? comparison : -comparison;
                });
                
                if (sortedTags.length === 0) {
                    allTagsColumn.innerHTML = '<div style="color: #94a3b8; font-size: 14px; padding: 20px; text-align: center;">No tags found</div>';
                    return;
                }
                
                sortedTags.forEach((tag, index) => {
                    const folder = folders.find(f => f.id === tag.folderId);
                    const isLast = index === sortedTags.length - 1;
                    html += `
                        <div class="tag-item" data-tag-id="${tag.id}" style="display: flex; align-items: center; gap: 10px; padding: 8px; background: #ffffff; border-radius: 6px; margin-bottom: ${isLast ? '0' : '6px'}; transition: background 0.2s ease;">
                            ${renderTagNameWithPin(tag)}
                            ${folder ? `<span onclick="navigateToFolder(${folder.id})" style="font-size: 12px; color: ${folder.color || '#64748b'}; padding: 2px 8px; background: ${folder.color || '#64748b'}20; border-radius: 4px; border: 1px solid ${folder.color || '#64748b'}; cursor: pointer; transition: all 0.2s ease;" onmouseover="this.style.color='${folder.color || '#64748b'}'; this.style.borderColor='${folder.color || '#64748b'}'; this.style.filter='brightness(1.2) saturate(1.3)'" onmouseout="this.style.color='${folder.color || '#64748b'}'; this.style.borderColor='${folder.color || '#64748b'}'; this.style.filter='none'">${escapeHtml(folder.name.toUpperCase())}</span>` : ''}
                        </div>
                    `;
                });
                allTagsColumn.innerHTML = html;
                
                // Setup context menu for tags in All Tags view
                setupTagContextMenu();
                
                return;
            }
            
            // View mode: folders
            // Show folders column and tags column, hide allTagsColumn
            foldersColumn.style.display = 'flex';
            tagsColumn.style.display = 'flex';
            allTagsColumn.style.display = 'none';
            
            if (tags.length === 0 && folders.length === 0) {
                foldersColumn.innerHTML = '';
                tagsColumn.innerHTML = '<div style="color: #94a3b8; font-size: 14px; padding: 20px; text-align: center;">No tags or folders yet. Create your first folder or tag below!</div>';
                return;
            }

            // Render folders in left column
            // Include "TAGS WITHOUT FOLDER" as a virtual folder in the sorting
            const tagsWithoutFolder = tags.filter(tag => !tag.folderId);
            if (tagsWithoutFolder.length === 0 && selectedFolderId === 'none') {
                selectedFolderId = null;
            }
            const allFoldersForSorting = [...folders];
            
            // Add virtual folder for tags without folder if there are any
            if (tagsWithoutFolder.length > 0) {
                allFoldersForSorting.push({
                    id: 'none',
                    name: 'NO FOLDER',
                    color: '#000000',
                    pinned: isNoFolderPinned(),
                    userId: null
                });
            }

            const searchingFolders = !selectedFolderId && searchLower.length > 0;
            const filteredFolders = searchingFolders
                ? allFoldersForSorting.filter(folder => {
                    const folderName = folder.id === 'none' ? 'TAGS WITHOUT FOLDER' : folder.name || '';
                    return folderName.toLowerCase().includes(searchLower);
                })
                : allFoldersForSorting;
            
            // Sort folders: pinned first, then by number of tags (descending), then alphabetically
            const sortedFolders = filteredFolders.sort((a, b) => {
                // First, sort by pinned status (pinned items first)
                const aPinned = (a.pinned ? 1 : 0);
                const bPinned = (b.pinned ? 1 : 0);
                if (aPinned !== bPinned) {
                    return bPinned - aPinned;
                }
                
                const aTagsCount = a.id === 'none' 
                    ? tagsWithoutFolder.length 
                    : tags.filter(tag => tag.folderId === a.id).length;
                const bTagsCount = b.id === 'none' 
                    ? tagsWithoutFolder.length 
                    : tags.filter(tag => tag.folderId === b.id).length;
                
                // Then sort by number of tags (descending)
                if (aTagsCount !== bTagsCount) {
                    return bTagsCount - aTagsCount;
                }
                
                // If equal, sort alphabetically
                return a.name.localeCompare(b.name);
            });
            
            if (searchingFolders && sortedFolders.length === 0) {
                foldersColumn.innerHTML = '<div style="color: #94a3b8; font-size: 14px; padding: 20px; text-align: center;">No folders found</div>';
                tagsColumn.innerHTML = '<div style="color: #94a3b8; font-size: 14px; padding: 20px; text-align: center;">Select a folder to view its tags</div>';
                return;
            }

            let foldersHtml = '';
            sortedFolders.forEach(folder => {
                const isNoneFolder = folder.id === 'none';
                const folderTags = isNoneFolder 
                    ? tagsWithoutFolder 
                    : tags.filter(tag => tag.folderId === folder.id).sort((a, b) => a.name.localeCompare(b.name));
                const folderColor = folder.color || '#64748b';
                const isSelected = isNoneFolder ? selectedFolderId === 'none' : selectedFolderId === folder.id;
                
                foldersHtml += `
                    <div class="folder-item" data-folder-id="${folder.id}" onclick="selectFolder(${isNoneFolder ? "'none'" : folder.id})" style="
                        padding: 10px 12px;
                        background: ${isSelected ? folderColor + '25' : folderColor + '15'};
                        border-radius: 8px;
                        border-left: 4px solid ${folderColor};
                        border-right: 2px solid ${isSelected ? folderColor : '#e2e8f0'};
                        border-top: 2px solid ${isSelected ? folderColor : '#e2e8f0'};
                        border-bottom: 2px solid ${isSelected ? folderColor : '#e2e8f0'};
                        cursor: pointer;
                        transition: all 0.2s ease;
                        width: 100%;
                        box-sizing: border-box;
                        height: 60px;
                        display: flex;
                        flex-direction: column;
                        justify-content: center;
                        position: relative;
                    ">
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <div style="font-weight: 600; color: ${folderColor}; font-size: 14px; margin-bottom: 2px; word-wrap: break-word; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1;">${escapeHtml(folder.name.toUpperCase())}</div>
                            ${folder.pinned ? `<svg style="width: 14px; height: 14px; flex-shrink: 0; color: ${folderColor};" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M17 12l4.5-2.5-7-7-2.5 4.5L3.5 10.5l10 10Z"></path>
                                <path d="m1.5 22.5 7-7"></path>
                            </svg>` : ''}
                        </div>
                        <div style="font-size: 11px; color: #64748b; font-weight: 500;">${folderTags.length} ${folderTags.length === 1 ? 'tag' : 'tags'}</div>
                    </div>
                `;
            });
            
            foldersColumn.innerHTML = foldersHtml;
            
            // Setup drag and drop event listeners for folders
            setupDragAndDrop();
            
            // Setup context menu for folders
            setupFolderContextMenu();
            
            // Render tags in right column based on selection
            let tagsHtml = '';
            if (selectedFolderId === null) {
                tagsColumn.innerHTML = '<div style="color: #94a3b8; font-size: 14px; padding: 20px; text-align: center;">Select a folder to view its tags</div>';
            } else if (selectedFolderId === 'none') {
                // Show tags without folder
                let filteredTagsWithoutFolder = tagsWithoutFolder;
                if (tagsSearchTerm.trim()) {
                    const searchLower = tagsSearchTerm.toLowerCase().trim();
                    filteredTagsWithoutFolder = tagsWithoutFolder.filter(tag => tag.name.toLowerCase().includes(searchLower));
                }
                
                if (filteredTagsWithoutFolder.length === 0) {
                    tagsColumn.innerHTML = '<div style="color: #94a3b8; font-size: 14px; padding: 20px; text-align: center;">' + (tagsSearchTerm.trim() ? 'No tags found' : 'NO TAGS WITHOUT FOLDER') + '</div>';
                } else {
                    // Sort filtered tags: pinned first, then alphabetically
                    const sortedTagsWithoutFolder = [...filteredTagsWithoutFolder].sort((a, b) => {
                        // First, sort by pinned status (pinned items first)
                        const aPinned = a.pinned ? 1 : 0;
                        const bPinned = b.pinned ? 1 : 0;
                        if (aPinned !== bPinned) {
                            return bPinned - aPinned;
                        }
                        // Then sort by name
                        const comparison = a.name.localeCompare(b.name);
                        return tagsSortOrder === 'asc' ? comparison : -comparison;
                    });
                    sortedTagsWithoutFolder.forEach((tag, index) => {
                        const isLast = index === sortedTagsWithoutFolder.length - 1;
                        tagsHtml += `
                            <div class="tag-item" draggable="true" data-tag-id="${tag.id}" style="display: flex; align-items: center; gap: 10px; padding: 8px; background: #ffffff; border-radius: 6px; margin-bottom: ${isLast ? '0' : '6px'}; transition: background 0.2s ease;">
                                ${renderTagNameWithPin(tag)}
                            </div>
                        `;
                    });
                    tagsColumn.innerHTML = tagsHtml;
                }
            } else {
                // Show tags from selected folder
                const selectedFolder = folders.find(f => f.id === selectedFolderId);
                if (selectedFolder) {
                    let folderTags = tags.filter(tag => tag.folderId === selectedFolderId);
                    // Apply search filter
                    if (tagsSearchTerm.trim()) {
                        const searchLower = tagsSearchTerm.toLowerCase().trim();
                        folderTags = folderTags.filter(tag => tag.name.toLowerCase().includes(searchLower));
                    }
                    
                    if (folderTags.length === 0) {
                        tagsColumn.innerHTML = '<div style="color: #94a3b8; font-size: 14px; padding: 20px; text-align: center;">' + (tagsSearchTerm.trim() ? 'No tags found' : 'This folder is empty') + '</div>';
                    } else {
                        // Sort filtered tags: pinned first, then alphabetically
                        const sortedFolderTags = [...folderTags].sort((a, b) => {
                            // First, sort by pinned status (pinned items first)
                            const aPinned = a.pinned ? 1 : 0;
                            const bPinned = b.pinned ? 1 : 0;
                            if (aPinned !== bPinned) {
                                return bPinned - aPinned;
                            }
                            // Then sort by name
                            const comparison = a.name.localeCompare(b.name);
                            return tagsSortOrder === 'asc' ? comparison : -comparison;
                        });
                        sortedFolderTags.forEach((tag, index) => {
                            const isLast = index === sortedFolderTags.length - 1;
                            tagsHtml += `
                                <div class="tag-item" draggable="true" data-tag-id="${tag.id}" style="display: flex; align-items: center; gap: 10px; padding: 8px; background: #ffffff; border-radius: 6px; margin-bottom: ${isLast ? '0' : '6px'}; transition: background 0.2s ease;">
                                    ${renderTagNameWithPin(tag)}
                                </div>
                            `;
                        });
                        tagsColumn.innerHTML = tagsHtml;
                    }
                }
            }
            
            // Setup drag and drop event listeners for tags
            setupTagDragListeners();
            
            // Setup context menu for tags
            setupTagContextMenu();
        }

        function setupDragAndDrop() {
            const folderItems = document.querySelectorAll('.folder-item[data-folder-id]');
            folderItems.forEach(folderItem => {
                folderItem.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    folderItem.style.opacity = '0.7';
                    folderItem.style.transform = 'scale(1.02)';
                });
                
                folderItem.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    folderItem.style.opacity = '1';
                    folderItem.style.transform = 'scale(1)';
                });
                
                folderItem.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    folderItem.style.opacity = '1';
                    folderItem.style.transform = 'scale(1)';
                    
                    const tagId = e.dataTransfer.getData('text/plain');
                    if (!tagId) return;
                    
                    const targetFolderId = folderItem.getAttribute('data-folder-id');
                    const newFolderId = targetFolderId === 'none' ? null : parseInt(targetFolderId);
                    
                    await moveTagToFolder(parseInt(tagId), newFolderId);
                });
            });
        }

        function setupTagDragListeners() {
            const tagItems = document.querySelectorAll('.tag-item[data-tag-id]');
            tagItems.forEach(tagItem => {
                // Track if right mouse button is pressed
                let isRightClick = false;
                let rightClickTimeout = null;
                
                tagItem.addEventListener('mousedown', (e) => {
                    if (e.button === 2) {
                        isRightClick = true;
                        // Temporarily disable draggable
                        tagItem.setAttribute('draggable', 'false');
                        // Re-enable after a short delay
                        rightClickTimeout = setTimeout(() => {
                            tagItem.setAttribute('draggable', 'true');
                            isRightClick = false;
                        }, 100);
                    }
                });
                
                tagItem.addEventListener('contextmenu', (e) => {
                    // Prevent drag when right clicking
                    isRightClick = true;
                    tagItem.setAttribute('draggable', 'false');
                    setTimeout(() => {
                        tagItem.setAttribute('draggable', 'true');
                        isRightClick = false;
                    }, 100);
                });
                
                tagItem.addEventListener('dragstart', (e) => {
                    // Prevent drag if it was triggered by right click
                    if (isRightClick) {
                        e.preventDefault();
                        e.stopPropagation();
                        return false;
                    }
                    
                    const tagId = tagItem.getAttribute('data-tag-id');
                    e.dataTransfer.setData('text/plain', tagId);
                    e.dataTransfer.effectAllowed = 'move';
                    tagItem.style.opacity = '0.5';
                });
                
                tagItem.addEventListener('dragend', (e) => {
                    tagItem.style.opacity = '1';
                    isRightClick = false;
                    if (rightClickTimeout) {
                        clearTimeout(rightClickTimeout);
                        rightClickTimeout = null;
                    }
                    // Reset all folder styles in case drag was cancelled
                    const folderItems = document.querySelectorAll('.folder-item[data-folder-id]');
                    folderItems.forEach(folder => {
                        folder.style.opacity = '1';
                        folder.style.transform = 'scale(1)';
                    });
                });
            });
        }

        // Context menu variables
        let contextMenuTarget = null;
        let contextMenuType = null; // 'folder' or 'tag'
        const NO_FOLDER_PIN_KEY_PREFIX = 'noFolderPinned:';
        let noFolderPinned = false;
        let contextSelectedElement = null;
        let contextMenuMode = 'options'; // 'options' or 'confirm'

        let activeTagModalDropdown = null;

        function getNoFolderPinStorageKey() {
            const identifier = userEmail || localStorage.getItem('userEmail') || 'anonymous';
            return `${NO_FOLDER_PIN_KEY_PREFIX}${identifier}`;
        }

        function loadNoFolderPinnedState() {
            const stored = localStorage.getItem(getNoFolderPinStorageKey());
            noFolderPinned = stored === 'true';
        }

        loadNoFolderPinnedState();

        function getDefaultFolderIdForNewTag() {
            const tagsModal = document.getElementById('tagsModalOverlay');
            if (tagsModal && tagsModal.classList.contains('active')) {
                if (tagsModalViewMode === 'folders' && tagsModalSelectedFolderId && tagsModalSelectedFolderId !== 'none') {
                    return tagsModalSelectedFolderId;
                }
            }
            if (selectedFolderId && selectedFolderId !== 'none') {
                return selectedFolderId;
            }
            return null;
        }

        function darkenColor(hexColor, amount = 0.2) {
            if (!hexColor || typeof hexColor !== 'string') return '#000000';
            let hex = hexColor.replace('#', '');
            if (hex.length === 3) {
                hex = hex.split('').map(ch => ch + ch).join('');
            }
            const num = parseInt(hex, 16);
            if (Number.isNaN(num)) return hexColor;
            let r = (num >> 16) & 255;
            let g = (num >> 8) & 255;
            let b = num & 255;
            r = Math.max(0, Math.min(255, Math.floor(r * (1 - amount))));
            g = Math.max(0, Math.min(255, Math.floor(g * (1 - amount))));
            b = Math.max(0, Math.min(255, Math.floor(b * (1 - amount))));
            const toHex = (value) => value.toString(16).padStart(2, '0');
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }

        function setupDatePicker() {
            const displayInput = document.getElementById('taskDateDisplay');
            const hiddenInput = document.getElementById('taskDate');
            const popover = document.getElementById('datePickerPopover');
            const daysContainer = document.getElementById('datePickerDays');
            const monthLabel = document.getElementById('datePickerMonthLabel');
            const modeLabel = document.getElementById('datePickerModeLabel');

            if (!displayInput || !hiddenInput || !popover || !daysContainer || !monthLabel || !modeLabel) return;

            datePickerState.displayInput = displayInput;
            datePickerState.hiddenInput = hiddenInput;
            datePickerState.popover = popover;
            datePickerState.calendarDaysContainer = daysContainer;
            datePickerState.calendarMonthLabel = monthLabel;
            datePickerState.calendarMode = 'month';
            // En vista de mes, el botón muestra la acción contraria: YEAR
            modeLabel.textContent = 'YEAR';

            // Inicializar los textos de las fechas rápidas
            updateQuickOptionLabels();

            // Configurar el comportamiento de hover de las opciones rápidas
            setupQuickOptionHover();

            // Máscara de entrada para que las barras se coloquen solas (dd/mm/yyyy)
            displayInput.addEventListener('input', handleDateInputMask);

            // Al hacer focus, guardar el valor previo y si hay contenido, seleccionar todo para que se reemplace al escribir
            displayInput.addEventListener('focus', () => {
                datePickerState.previousValue = displayInput.value;
                if (displayInput.value.trim()) {
                    displayInput.select();
                    datePickerState.shouldReplaceOnInput = true;
                }
            });

            displayInput.addEventListener('blur', handleDateDisplayBlur);
            displayInput.addEventListener('change', handleDateDisplayBlur);
            displayInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    handleDateDisplayBlur();
                    displayInput.blur();
                } else if (event.key === 'Backspace' && displayInput.value.trim()) {
                    // Prevenir borrar con backspace si hay contenido
                    event.preventDefault();
                }
            });

            syncDateDisplayFromHidden();
            updateDateRemoveButton();
            initializeDatePickerCalendarFromValue();
            renderDatePickerCalendar();
        }

        function setupTimePicker() {
            const input = document.getElementById('taskTime');
            const hiddenInput = document.getElementById('taskTimeHidden');
            const popover = document.getElementById('timePickerPopover');
            const hoursBar = document.getElementById('timePickerHoursBar');
            const minutesBar = document.getElementById('timePickerMinutesBar');

            if (!input || !popover || !hoursBar || !minutesBar) return;

            timePickerState.input = input;
            timePickerState.hiddenInput = hiddenInput;
            timePickerState.popover = popover;
            timePickerState.hoursBar = hoursBar;
            timePickerState.minutesBar = minutesBar;

            // Máscara de entrada para que los dos puntos se coloquen solos (hh:mm)
            input.addEventListener('input', handleTimeInputMask);
            
            // Al hacer focus, guardar el valor previo y si hay contenido, seleccionar todo para que se reemplace al escribir
            input.addEventListener('focus', () => {
                timePickerState.previousValue = input.value;
                if (input.value.trim()) {
                    input.select();
                    timePickerState.shouldReplaceOnInput = true;
                }
            });
            
            // Sincronizar cuando se pierde el foco
            input.addEventListener('blur', handleTimeInputBlur);
            input.addEventListener('change', handleTimeInputBlur);
            input.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    handleTimeInputBlur();
                    input.blur();
                } else if (event.key === 'Backspace' && input.value.trim()) {
                    // Prevenir borrar con backspace si hay contenido
                    event.preventDefault();
                }
            });

            // Inicializar valor desde el input si ya tiene hora
            if (input.value) {
                const [h, m] = input.value.split(':').map(v => parseInt(v, 10));
                if (!Number.isNaN(h)) timePickerState.selectedHour = h;
                if (!Number.isNaN(m)) timePickerState.selectedMinute = m;
                syncTimeHiddenInput();
            }

            updateTimeRemoveButton();
            renderTimePicker();
        }

        function toggleDatePicker(event) {
            event.stopPropagation();
            if (!datePickerState.popover) return;

            if (datePickerState.isOpen) {
                closeDatePicker();
            } else {
                openDatePicker();
            }
        }

        function toggleTimePicker(event) {
            event.stopPropagation();
            if (!timePickerState.popover || !timePickerState.input) return;

            if (timePickerState.isOpen) {
                closeTimePicker();
            } else {
                openTimePicker();
            }
        }

        function openDatePicker() {
            if (!datePickerState.popover || !datePickerState.displayInput) return;

            datePickerState.popover.classList.add('active');
            datePickerState.isOpen = true;

            positionDatePicker();

            initializeDatePickerCalendarFromValue();
            renderDatePickerCalendar();

            // Actualizar las fechas mostradas en las opciones rápidas cada vez que se abre
            updateQuickOptionLabels();

            datePickerState.outsideHandler = (event) => {
                const clickedInsideTrigger = event.target.closest('.date-picker-wrapper');
                const clickedInsidePopover = datePickerState.popover.contains(event.target);

                // Si hace clic fuera del popover y del trigger, cerramos y evitamos que
                // el clic dispare otras acciones en la interfaz.
                if (!clickedInsidePopover && !clickedInsideTrigger) {
                    event.preventDefault();
                    event.stopPropagation();
                    if (event.stopImmediatePropagation) {
                        event.stopImmediatePropagation();
                    }
                    closeDatePicker();
                }
            };

            datePickerState.keyHandler = (event) => {
                if (event.key === 'Escape') {
                    closeDatePicker();
                }
            };

            // Usamos captura para interceptar el clic antes que el resto de la UI
            document.addEventListener('click', datePickerState.outsideHandler, true);
            document.addEventListener('keydown', datePickerState.keyHandler);
            window.addEventListener('resize', positionDatePicker);
        }

        function openTimePicker() {
            if (!timePickerState.popover || !timePickerState.input) return;

            timePickerState.popover.classList.add('active');
            timePickerState.isOpen = true;

            positionTimePicker();
            renderTimePicker();

            timePickerState.outsideHandler = (event) => {
                const clickedInsideTrigger = event.target.closest('.time-picker-wrapper');
                const clickedInsidePopover = timePickerState.popover.contains(event.target);
                if (!clickedInsidePopover && !clickedInsideTrigger) {
                    closeTimePicker();
                }
            };

            timePickerState.keyHandler = (event) => {
                if (event.key === 'Escape') {
                    closeTimePicker();
                }
            };

            document.addEventListener('click', timePickerState.outsideHandler, true);
            document.addEventListener('keydown', timePickerState.keyHandler);
            window.addEventListener('resize', positionTimePicker);
        }

        function closeTimePicker() {
            if (!timePickerState.popover) return;
            timePickerState.popover.classList.remove('active');
            timePickerState.isOpen = false;

            if (timePickerState.outsideHandler) {
                document.removeEventListener('click', timePickerState.outsideHandler, true);
                timePickerState.outsideHandler = null;
            }
            if (timePickerState.keyHandler) {
                document.removeEventListener('keydown', timePickerState.keyHandler);
                timePickerState.keyHandler = null;
            }
            window.removeEventListener('resize', positionTimePicker);
        }

        function closeDatePicker() {
            if (!datePickerState.popover) return;
            datePickerState.popover.classList.remove('active');
            datePickerState.isOpen = false;

            if (datePickerState.outsideHandler) {
                document.removeEventListener('click', datePickerState.outsideHandler, true);
                datePickerState.outsideHandler = null;
            }
            if (datePickerState.keyHandler) {
                document.removeEventListener('keydown', datePickerState.keyHandler);
                datePickerState.keyHandler = null;
            }
            window.removeEventListener('resize', positionDatePicker);
        }

        function positionDatePicker() {
            if (!datePickerState.popover || !datePickerState.displayInput) return;
            const rect = datePickerState.displayInput.getBoundingClientRect();
            const scrollY = window.scrollY || document.documentElement.scrollTop;
            const scrollX = window.scrollX || document.documentElement.scrollLeft;
            let top = rect.top + scrollY - (datePickerState.popover.offsetHeight || 0) - 8;
            if (top < 20) {
                top = rect.bottom + scrollY + 8;
            }
            let left = rect.left + scrollX;

            const popoverWidth = datePickerState.popover.offsetWidth || 260;
            const viewportWidth = window.innerWidth;
            if (left + popoverWidth > viewportWidth - 20) {
                left = viewportWidth - popoverWidth - 20;
            }

            datePickerState.popover.style.top = `${top}px`;
            datePickerState.popover.style.left = `${Math.max(20, left)}px`;
        }

        function positionTimePicker() {
            if (!timePickerState.popover || !timePickerState.input) return;
            const rect = timePickerState.input.getBoundingClientRect();
            const scrollY = window.scrollY || document.documentElement.scrollTop;
            const scrollX = window.scrollX || document.documentElement.scrollLeft;

            // Intentar abrir por defecto ARRIBA, igual que el selector de fecha
            let top = rect.top + scrollY - (timePickerState.popover.offsetHeight || 0) - 8;
            if (top < 20) {
                // Si no hay espacio suficiente arriba, abrimos debajo
                top = rect.bottom + scrollY + 8;
            }

            const popoverWidth = timePickerState.popover.offsetWidth || 320;
            const viewportWidth = window.innerWidth;
            // Centrar horizontalmente respecto al campo de hora
            let left = rect.left + scrollX + (rect.width / 2) - (popoverWidth / 2);
            // Ajustar para no salirnos de los márgenes de la ventana
            if (left < 20) left = 20;
            if (left + popoverWidth > viewportWidth - 20) {
                left = viewportWidth - popoverWidth - 20;
            }

            timePickerState.popover.style.top = `${top}px`;
            timePickerState.popover.style.left = `${left}px`;
        }

        function initializeDatePickerCalendarFromValue() {
            let baseDate = null;
            if (datePickerState.hiddenInput && datePickerState.hiddenInput.value) {
                baseDate = parseISODate(datePickerState.hiddenInput.value);
            }
            if (!baseDate) {
                baseDate = new Date();
            }
            datePickerState.calendarYear = baseDate.getFullYear();
            datePickerState.calendarMonth = baseDate.getMonth();
        }

        function renderDatePickerCalendar() {
            if (!datePickerState.calendarDaysContainer || datePickerState.calendarYear === null) return;

            const container = datePickerState.calendarDaysContainer;
            container.innerHTML = '';

            const year = datePickerState.calendarYear;
            const month = datePickerState.calendarMonth;

            const mode = datePickerState.calendarMode || 'month';

            const weekdaysRow = document.querySelector('.date-picker-calendar-weekdays');
            if (weekdaysRow) {
                weekdaysRow.style.display = mode === 'year' ? 'none' : 'grid';
            }

            if (datePickerState.calendarMonthLabel) {
                if (mode === 'month') {
                    datePickerState.calendarMonthLabel.textContent = `${DATE_PICKER_MONTH_NAMES[month]} ${year}`;
                } else {
                    datePickerState.calendarMonthLabel.textContent = `${year}`;
                }
            }

            if (mode === 'year') {
                // Year view: 3x4 grid of months
                container.style.gridTemplateColumns = 'repeat(3, 1fr)';
                container.style.gridAutoRows = '1fr';
                container.style.alignContent = 'stretch';
                // Hacer que el grid de meses ocupe todo el alto disponible de la columna
                container.style.flex = '1 1 auto';

                const selectedDate = datePickerState.hiddenInput && datePickerState.hiddenInput.value
                    ? parseISODate(datePickerState.hiddenInput.value)
                    : null;
                const today = new Date();

                for (let m = 0; m < 12; m++) {
                    const monthButton = document.createElement('button');
                    monthButton.type = 'button';
                    monthButton.className = 'calendar-month';

                    const monthDate = new Date(year, m, 1);

                    if (selectedDate && selectedDate.getFullYear() === year && selectedDate.getMonth() === m) {
                        monthButton.classList.add('selected');
                    }

                    if (today.getFullYear() === year && today.getMonth() === m) {
                        monthButton.classList.add('today');
                    }

                    monthButton.textContent = DATE_PICKER_MONTH_NAMES[m];
                    monthButton.addEventListener('click', (event) => {
                        event.stopPropagation();
                        datePickerState.calendarMonth = m;
                        datePickerState.calendarMode = 'month';
                        const modeLabel = document.getElementById('datePickerModeLabel');
                        if (modeLabel) modeLabel.textContent = 'YEAR';
                        renderDatePickerCalendar();
                    });

                    container.appendChild(monthButton);
                }
                return;
            }

            // Month view: days grid
            container.style.gridTemplateColumns = 'repeat(7, 1fr)';
            container.style.gridAutoRows = '';
            container.style.height = '';
            // En vista de días, dejamos que el contenido marque la altura (sin forzar flex)
            container.style.flex = '';

            const firstOfMonth = new Date(year, month, 1);
            const startOffset = (firstOfMonth.getDay() + 6) % 7; // Shift so Monday is first column
            const totalCells = 42;

            const selectedDate = datePickerState.hiddenInput && datePickerState.hiddenInput.value
                ? parseISODate(datePickerState.hiddenInput.value)
                : null;
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            for (let i = 0; i < totalCells; i++) {
                const cellDate = new Date(year, month, 1 - startOffset + i);
                const isCurrentMonth = cellDate.getMonth() === month;
                if (!isCurrentMonth) {
                    const placeholder = document.createElement('div');
                    container.appendChild(placeholder);
                    continue;
                }
                const dayButton = document.createElement('button');
                dayButton.type = 'button';
                dayButton.className = 'calendar-day';
                if (isSameCalendarDate(cellDate, today)) {
                    dayButton.classList.add('today');
                }
                if (selectedDate && isSameCalendarDate(cellDate, selectedDate)) {
                    dayButton.classList.add('selected');
                }
                dayButton.textContent = cellDate.getDate();
                dayButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    setDateValue(cellDate, true);
                });

                container.appendChild(dayButton);
            }

            // Guardar altura mínima de la ventana (popover) solo la primera vez
            if (!datePickerState.monthViewBaseHeight && datePickerState.popover) {
                const baseHeight = datePickerState.popover.offsetHeight || datePickerState.popover.clientHeight;
                if (baseHeight) {
                    datePickerState.monthViewBaseHeight = baseHeight;
                    datePickerState.popover.style.minHeight = baseHeight + 'px';
                }
            } else if (datePickerState.monthViewBaseHeight && datePickerState.popover) {
                // Aseguramos el mínimo en siguientes renders
                datePickerState.popover.style.minHeight = datePickerState.monthViewBaseHeight + 'px';
            }
        }

        function changeDatePickerMonth(delta) {
            if (datePickerState.calendarYear === null || datePickerState.calendarMonth === null) {
                initializeDatePickerCalendarFromValue();
            }
            const mode = datePickerState.calendarMode || 'month';
            if (mode === 'year') {
                datePickerState.calendarYear += delta;
            } else {
                datePickerState.calendarMonth += delta;
                if (datePickerState.calendarMonth > 11) {
                    datePickerState.calendarMonth = 0;
                    datePickerState.calendarYear += 1;
                } else if (datePickerState.calendarMonth < 0) {
                    datePickerState.calendarMonth = 11;
                    datePickerState.calendarYear -= 1;
                }
            }
            renderDatePickerCalendar();
        }

        function renderTimePicker() {
            if (!timePickerState.hoursBar || !timePickerState.minutesBar) return;

            const hoursBar = timePickerState.hoursBar;
            const minutesBar = timePickerState.minutesBar;
            hoursBar.innerHTML = '';
            minutesBar.innerHTML = '';

            const selectedHour = timePickerState.selectedHour;
            const selectedMinute = timePickerState.selectedMinute;

            for (let h = 0; h < 24; h++) {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'time-hour';
                if (h === selectedHour) {
                    btn.classList.add('selected');
                }
                btn.textContent = String(h).padStart(2, '0');
                btn.addEventListener('click', (event) => {
                    event.stopPropagation();
                    timePickerState.selectedHour = h;
                    // Si aún no hay minutos seleccionados, por defecto :00
                    if (timePickerState.selectedMinute == null) {
                        timePickerState.selectedMinute = 0;
                    }
                    updateTimeInputFromState();
                    renderTimePicker();
                    renderTimeMinutesBar();
                });
                hoursBar.appendChild(btn);
            }

            // Siempre mostramos la barra de minutos para que :00, :15, etc. sean visibles desde el principio
            renderTimeMinutesBar();
        }

        function renderTimeMinutesBar() {
            if (!timePickerState.minutesBar) return;

            const minutesBar = timePickerState.minutesBar;
            minutesBar.innerHTML = '';

            const minutesOptions = [0, 15, 30, 45];
            const selectedMinute = timePickerState.selectedMinute;
            const selectedHour = timePickerState.selectedHour;

            // Desactivar visualmente la fila completa si no hay hora seleccionada
            const minutesRow = document.getElementById('timePickerMinutesRow');
            if (minutesRow) {
                if (selectedHour == null) {
                    minutesRow.classList.add('disabled');
                } else {
                    minutesRow.classList.remove('disabled');
                }
            }

            minutesOptions.forEach((m) => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'time-minute';
                if (selectedMinute != null && m === selectedMinute) {
                    btn.classList.add('selected');
                }
                const hourLabel = selectedHour != null
                    ? String(selectedHour).padStart(2, '0')
                    : 'hh';
                btn.textContent = `${hourLabel}:${String(m).padStart(2, '0')}`;
                btn.addEventListener('click', (event) => {
                    event.stopPropagation();
                    if (timePickerState.selectedHour == null) return; // seguridad extra
                    timePickerState.selectedMinute = m;
                    updateTimeInputFromState();
                    renderTimeMinutesBar();
                });
                minutesBar.appendChild(btn);
            });
        }

        function updateTimeInputFromState() {
            if (!timePickerState.input) return;
            if (timePickerState.selectedHour == null) {
                timePickerState.input.value = '';
                syncTimeHiddenInput();
                updateTimeDiffLabel(null);
                updateTimeRemoveButton();
                return;
            }
            const hour = String(timePickerState.selectedHour).padStart(2, '0');
            const minute = String((timePickerState.selectedMinute ?? 0)).padStart(2, '0');
            timePickerState.input.value = `${hour}:${minute}`;
            syncTimeHiddenInput();
            updateTimeDiffLabel();
            updateDateTimeSummary();
            updateTimeRemoveButton();
        }

        function updateTimeDiffLabel() {
            const labelEl = document.getElementById('taskTimeDiffLabel');
            if (!labelEl) return;

            // Necesitamos fecha y hora para calcular la diferencia
            const dateInput = document.getElementById('taskDate');
            if (!dateInput || !dateInput.value) {
                labelEl.textContent = '';
                labelEl.classList.remove('time-picker-diff-past');
                return;
            }

            if (timePickerState.selectedHour == null) {
                labelEl.textContent = '';
                labelEl.classList.remove('time-picker-diff-past');
                return;
            }

            // Crear fecha/hora objetivo
            const targetDate = new Date(dateInput.value);
            targetDate.setHours(timePickerState.selectedHour, timePickerState.selectedMinute ?? 0, 0, 0);

            // Fecha/hora actual
            const now = new Date();

            // Calcular diferencia en milisegundos
            const diffMs = targetDate.getTime() - now.getTime();
            const diffMinutes = Math.round(diffMs / (1000 * 60));
            const diffHours = Math.round(diffMs / (1000 * 60 * 60));

            // Solo mostrar si la diferencia es menor a 48 horas (en valor absoluto)
            if (Math.abs(diffHours) >= 48) {
                labelEl.textContent = '';
                labelEl.classList.remove('time-picker-diff-past');
                return;
            }

            let label = '';
            const absMinutes = Math.abs(diffMinutes);
            const absHours = Math.abs(diffHours);

            // Si la diferencia es 60 minutos o menos, mostrar en minutos (sin redondear la primera hora)
            if (absMinutes < 60) {
                if (diffMinutes === 0) {
                    label = 'Now';
                } else if (diffMinutes === 1) {
                    label = '1 minute left';
                } else if (diffMinutes > 1) {
                    label = `${diffMinutes} minutes left`;
                } else if (diffMinutes === -1) {
                    label = '1 minute ago';
                } else {
                    label = `${absMinutes} minutes ago`;
                }
            } else {
                // Si es más de 60 minutos, mostrar en horas
                if (diffHours === 1) {
                    label = '1 hour left';
                } else if (diffHours > 1) {
                    label = `${diffHours} hours left`;
                } else if (diffHours === -1) {
                    label = '1 hour ago';
                } else {
                    label = `${absHours} hours ago`;
                }
            }

            labelEl.textContent = label;

            // Aplicar color según si es pasado o futuro (rojo si ya pasó)
            if (diffMinutes < 0) {
                labelEl.classList.add('time-picker-diff-past');
            } else {
                labelEl.classList.remove('time-picker-diff-past');
            }
        }

        function updateDateTimeSummary() {
            const summaryEl = document.getElementById('dateTimeSummary');
            if (!summaryEl) return;

            const dateInput = document.getElementById('taskDate');
            const timeInput = document.getElementById('taskTimeHidden');

            if (!dateInput || !dateInput.value) {
                summaryEl.textContent = '';
                return;
            }

            // Parsear la fecha
            const date = parseISODate(dateInput.value);
            if (!date) {
                summaryEl.textContent = '';
                return;
            }

            // Nombres de los meses en inglés
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                'July', 'August', 'September', 'October', 'November', 'December'];

            const day = date.getDate();
            const month = monthNames[date.getMonth()];
            const year = date.getFullYear();

            let summary = `${day} ${month} ${year}`;

            // Añadir la hora si está disponible
            if (timeInput && timeInput.value) {
                const [hours, minutes] = timeInput.value.split(':');
                if (hours && minutes) {
                    summary += ` at ${hours}:${minutes}`;
                }
            }

            summaryEl.textContent = summary;
        }

        function syncTimeHiddenInput() {
            if (!timePickerState.hiddenInput || !timePickerState.input) return;
            const value = timePickerState.input.value;
            if (value && value.includes(':')) {
                timePickerState.hiddenInput.value = value;
            } else {
                timePickerState.hiddenInput.value = '';
            }
        }

        function handleTimeInputMask(event) {
            const input = event.target;
            
            // Si debe reemplazar todo (texto estaba seleccionado), tomar solo el nuevo carácter
            if (timePickerState.shouldReplaceOnInput && event.inputType === 'insertText' && event.data) {
                // Reemplazar todo con el nuevo carácter
                input.value = event.data;
                timePickerState.shouldReplaceOnInput = false;
                // Continuar con el procesamiento normal
            } else if (timePickerState.shouldReplaceOnInput) {
                // Si no es insertText, resetear el flag
                timePickerState.shouldReplaceOnInput = false;
            }
            
            // Tomamos solo dígitos de lo que se haya escrito/pegado
            let digits = input.value.replace(/\D/g, '');

            if (!digits) {
                input.value = '';
                return;
            }

            // Limitar a 4 dígitos (hhmm)
            if (digits.length > 4) {
                digits = digits.slice(0, 4);
            }

            let formatted = '';
            if (digits.length <= 2) {
                // h, hh
                formatted = digits;
            } else {
                // hhmm
                formatted = `${digits.slice(0, 2)}:${digits.slice(2)}`;
            }

            input.value = formatted;
        }

        function handleTimeInputBlur() {
            if (!timePickerState.input) return;
            const value = timePickerState.input.value.trim();
            if (!value) {
                timePickerState.selectedHour = null;
                timePickerState.selectedMinute = null;
                syncTimeHiddenInput();
                updateTimeRemoveButton();
                renderTimePicker();
                return;
            }

            const parsed = parseTimeValue(value);
            if (parsed) {
                timePickerState.selectedHour = parsed.hour;
                timePickerState.selectedMinute = parsed.minute;
                updateTimeInputFromState();
                renderTimePicker();
            } else {
                // Si no es válido, restaurar el valor previo
                if (timePickerState.previousValue !== null) {
                    timePickerState.input.value = timePickerState.previousValue;
                    // Intentar parsear el valor previo para actualizar el estado
                    const prevParsed = parseTimeValue(timePickerState.previousValue);
                    if (prevParsed) {
                        timePickerState.selectedHour = prevParsed.hour;
                        timePickerState.selectedMinute = prevParsed.minute;
                        updateTimeInputFromState();
                    } else {
                        // Si el valor previo tampoco es válido, limpiar
                        timePickerState.input.value = '';
                        timePickerState.selectedHour = null;
                        timePickerState.selectedMinute = null;
                        syncTimeHiddenInput();
                    }
                } else {
                    // Si no hay valor previo, limpiar
                    timePickerState.input.value = '';
                    timePickerState.selectedHour = null;
                    timePickerState.selectedMinute = null;
                    syncTimeHiddenInput();
                }
                updateTimeRemoveButton();
                renderTimePicker();
            }
        }

        function parseTimeValue(value) {
            // Formato esperado: hh:mm o hhmm
            const clean = value.replace(/\D/g, '');
            if (clean.length < 1) return null;

            let hour, minute;
            if (value.includes(':')) {
                const parts = value.split(':');
                hour = parseInt(parts[0], 10);
                minute = parseInt(parts[1] || '0', 10);
            } else {
                if (clean.length === 1) {
                    // Un solo dígito: interpretar como hora (0-9) con minutos en 00
                    hour = parseInt(clean, 10);
                    minute = 0;
                } else if (clean.length === 2) {
                    hour = parseInt(clean, 10);
                    minute = 0;
                } else if (clean.length >= 3) {
                    hour = parseInt(clean.slice(0, 2), 10);
                    minute = parseInt(clean.slice(2, 4) || '0', 10);
                } else {
                    return null;
                }
            }

            // Validar rango
            if (Number.isNaN(hour) || Number.isNaN(minute)) return null;
            if (hour < 0 || hour > 23) return null;
            if (minute < 0 || minute > 59) return null;

            return { hour, minute };
        }

        function adjustSelectedTime(deltaMinutes) {
            // Solo ajustamos si ya hay una hora seleccionada
            if (timePickerState.selectedHour == null) return;

            const currentMinutes =
                timePickerState.selectedHour * 60 + (timePickerState.selectedMinute ?? 0);
            let total = currentMinutes + deltaMinutes;

            // Limitar entre 00:00 y 23:59
            if (total < 0) total = 0;
            const maxMinutes = 23 * 60 + 59;
            if (total > maxMinutes) total = maxMinutes;

            timePickerState.selectedHour = Math.floor(total / 60);
            timePickerState.selectedMinute = total % 60;

            updateTimeInputFromState();
            renderTimePicker();
        }

        function isSameCalendarDate(dateA, dateB) {
            return (
                dateA.getFullYear() === dateB.getFullYear() &&
                dateA.getMonth() === dateB.getMonth() &&
                dateA.getDate() === dateB.getDate()
            );
        }

        function toggleCalendarMode() {
            const modeLabel = document.getElementById('datePickerModeLabel');
            if (!modeLabel) return;

            datePickerState.calendarMode = datePickerState.calendarMode === 'year' ? 'month' : 'year';
            // El texto siempre muestra la acción disponible (vista contraria)
            modeLabel.textContent = datePickerState.calendarMode === 'year' ? 'MONTH' : 'YEAR';
            renderDatePickerCalendar();
        }

        function handleDateDisplayBlur() {
            if (!datePickerState.displayInput) return;
            
            const value = datePickerState.displayInput.value.trim();
            if (!value) {
                if (datePickerState.hiddenInput) {
                    datePickerState.hiddenInput.value = '';
                }
                // Actualizar label de horas cuando se borra la fecha
                updateTimeDiffLabel();
                updateDateRemoveButton();
                updateDateTimeSummary();
                return;
            }

            // Completar automáticamente si el valor está incompleto
            const completedValue = completeDateValue(value);
            if (completedValue && completedValue !== value) {
                datePickerState.displayInput.value = completedValue;
            }

            const finalValue = completedValue || value;
            const parsed = parseDisplayDate(finalValue);
            if (parsed) {
                setDateValue(parsed, false);
            } else {
                // Si el input no es válido, restaurar el valor previo
                if (datePickerState.previousValue !== null) {
                    datePickerState.displayInput.value = datePickerState.previousValue;
                    // Intentar parsear el valor previo para actualizar el estado
                    const prevParsed = parseDisplayDate(datePickerState.previousValue);
                    if (prevParsed) {
                        setDateValue(prevParsed, false);
                    } else {
                        syncDateDisplayFromHidden();
                    }
                } else {
                    syncDateDisplayFromHidden();
                }
                // Actualizar label de horas aunque no se haya parseado correctamente
                updateTimeDiffLabel();
                updateDateRemoveButton();
            }
        }

        function completeDateValue(value) {
            // Tomar solo dígitos
            const digits = value.replace(/\D/g, '');
            if (!digits) return null;

            const now = new Date();
            const currentMonth = now.getMonth() + 1; // 1-12
            const currentYear = now.getFullYear();

            if (digits.length === 1) {
                // d → dd/mm/yyyy (día del mes actual, año actual)
                const day = digits.padStart(2, '0');
                return `${day}/${String(currentMonth).padStart(2, '0')}/${currentYear}`;
            } else if (digits.length === 2) {
                // dd → dd/mm/yyyy (día del mes actual, año actual)
                return `${digits}/${String(currentMonth).padStart(2, '0')}/${currentYear}`;
            } else if (digits.length === 3) {
                // dmm → dd/mm/yyyy (día 1 dígito, mes 2 dígitos, año actual)
                const day = digits.slice(0, 1).padStart(2, '0');
                const month = digits.slice(1, 3);
                return `${day}/${month}/${currentYear}`;
            } else if (digits.length === 4) {
                // ddmm → dd/mm/yyyy (día 2 dígitos, mes 2 dígitos, año actual)
                return `${digits.slice(0, 2)}/${digits.slice(2, 4)}/${currentYear}`;
            } else if (digits.length === 5) {
                // d/mmyy → dd/mm/yyyy (día 1 dígito, mes 2 dígitos, año 2 dígitos)
                const day = digits.slice(0, 1).padStart(2, '0');
                const month = digits.slice(1, 3);
                const year = 2000 + parseInt(digits.slice(3, 5), 10);
                return `${day}/${month}/${year}`;
            } else if (digits.length === 6) {
                // dd/mmyy → dd/mm/yyyy (día 2 dígitos, mes 2 dígitos, año 2 dígitos)
                const day = digits.slice(0, 2);
                const month = digits.slice(2, 4);
                const year = 2000 + parseInt(digits.slice(4, 6), 10);
                return `${day}/${month}/${year}`;
            } else if (value.includes('/') && value.split('/').length === 2) {
                // Si ya tiene formato dd/mm pero falta el año
                const parts = value.split('/');
                if (parts.length === 2) {
                    return `${parts[0]}/${parts[1]}/${currentYear}`;
                }
            } else if (value.includes('/') && value.split('/').length === 3) {
                // Si ya tiene formato completo, verificar si el año es de 2 dígitos
                const parts = value.split('/');
                if (parts.length === 3) {
                    const yearPart = parts[2];
                    if (yearPart.length === 2) {
                        // Año de 2 dígitos, añadir 2000
                        const year = 2000 + parseInt(yearPart, 10);
                        return `${parts[0]}/${parts[1]}/${year}`;
                    }
                }
            }

            return null; // No necesita completar
        }

        function parseDisplayDate(value) {
            const normalized = value.replace(/\./g, '/').replace(/-/g, '/');
            const parts = normalized.split('/');
            if (parts.length !== 3) return null;
            const [dayStr, monthStr, yearStr] = parts;
            const day = parseInt(dayStr, 10);
            const month = parseInt(monthStr, 10);
            const year = parseInt(yearStr, 10);
            if (
                Number.isNaN(day) || Number.isNaN(month) || Number.isNaN(year) ||
                day < 1 || day > 31 || month < 1 || month > 12 || year < 1900
            ) {
                return null;
            }
            const date = new Date(year, month - 1, day);
            if (date.getFullYear() !== year || date.getMonth() !== month - 1 || date.getDate() !== day) {
                return null;
            }
            return date;
        }

        function parseISODate(value) {
            const parts = value.split('-');
            if (parts.length !== 3) return null;
            const [yearStr, monthStr, dayStr] = parts;
            const year = parseInt(yearStr, 10);
            const month = parseInt(monthStr, 10);
            const day = parseInt(dayStr, 10);
            if (
                Number.isNaN(day) || Number.isNaN(month) || Number.isNaN(year) ||
                day < 1 || day > 31 || month < 1 || month > 12 || year < 1900
            ) {
                return null;
            }
            return new Date(year, month - 1, day);
        }

        function formatDisplayDate(date) {
            return `${String(date.getDate()).padStart(2, '0')}/${String(date.getMonth() + 1).padStart(2, '0')}/${date.getFullYear()}`;
        }

        function formatDisplayDateWithDiff(date) {
            const base = formatDisplayDate(date);

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            const target = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            const diffMs = target.getTime() - today.getTime();
            const diffDays = Math.round(diffMs / (1000 * 60 * 60 * 24));

            let label = '';
            if (diffDays === 0) {
                label = 'Today';
            } else {
                const absDays = Math.abs(diffDays);
                const isPast = diffDays < 0;
                
                // Calcular meses aproximados (usando 30 días por mes)
                const months = Math.round(absDays / 30);
                // Calcular años aproximados (usando 365 días por año)
                const years = Math.round(absDays / 365);
                
                if (absDays > 90) {
                    // Más de 90 días: mostrar en meses o años
                    if (months >= 12) {
                        // Más de 12 meses: mostrar en años
                        if (years === 1) {
                            label = isPast ? '1 year ago' : '1 year left';
                        } else {
                            label = isPast ? `${years} years ago` : `${years} years left`;
                        }
                    } else {
                        // Entre 90 días y 12 meses: mostrar en meses
                        if (months === 1) {
                            label = isPast ? '1 month ago' : '1 month left';
                        } else {
                            label = isPast ? `${months} months ago` : `${months} months left`;
                        }
                    }
                } else {
                    // Menos de 90 días: mostrar en días
                    if (diffDays === 1) {
                        label = '1 day left';
                    } else if (diffDays > 1) {
                        label = `${diffDays} days left`;
                    } else if (diffDays === -1) {
                        label = '1 day ago';
                    } else {
                        label = `${absDays} days ago`;
                    }
                }
            }

            return { base, label };
        }

        function updateDateDiffLabel(labelOrDate) {
            const labelEl = document.getElementById('taskDateDiffLabel');
            if (!labelEl) return;

            // Si recibimos null o cadena vacía, limpiamos el texto
            if (!labelOrDate) {
                labelEl.textContent = '';
                labelEl.style.color = '#9ca3af'; // gris por defecto
                return;
            }

            // Se asume que labelOrDate ya es el texto formateado (Today, 3 days left, etc.)
            labelEl.textContent = labelOrDate;

            // Colores según si la fecha está en el futuro/pasado:
            // - left / Today → gris suave
            // - ago → rojo suave apagado
            const lower = labelOrDate.toLowerCase();
            if (lower.includes('ago')) {
                labelEl.style.color = '#f97373'; // rojo apagado
            } else {
                labelEl.style.color = '#9ca3af'; // gris suave
            }
        }

        function handleDateInputMask(event) {
            const input = event.target;
            
            // Si debe reemplazar todo (texto estaba seleccionado), tomar solo el nuevo carácter
            if (datePickerState.shouldReplaceOnInput && event.inputType === 'insertText' && event.data) {
                // Reemplazar todo con el nuevo carácter
                input.value = event.data;
                datePickerState.shouldReplaceOnInput = false;
                // Continuar con el procesamiento normal
            } else if (datePickerState.shouldReplaceOnInput) {
                // Si no es insertText, resetear el flag
                datePickerState.shouldReplaceOnInput = false;
            }
            
            // Tomamos solo dígitos de lo que se haya escrito/pegado
            let digits = input.value.replace(/\D/g, '');

            if (!digits) {
                input.value = '';
                return;
            }

            // Limitar a 8 dígitos (ddmmyyyy)
            if (digits.length > 8) {
                digits = digits.slice(0, 8);
            }

            let formatted = '';
            // Solo formatear con barras si hay 7 o más dígitos (fecha completa)
            // Para 1-6 dígitos, mostrar solo los dígitos sin barras (se formateará al presionar Enter)
            if (digits.length <= 6) {
                // Mostrar solo los dígitos sin formatear
                formatted = digits;
            } else {
                // ddmmyyyy (o parcial) - lógica original con barras
                formatted = `${digits.slice(0, 2)}/${digits.slice(2, 4)}/${digits.slice(4)}`;
            }

            input.value = formatted;
        }

        function formatISODate(date) {
            return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
        }

        function syncDateDisplayFromHidden() {
            if (!datePickerState.hiddenInput || !datePickerState.displayInput) return;
            if (!datePickerState.hiddenInput.value) {
                datePickerState.displayInput.value = '';
                updateDateDiffLabel(null);
                updateDateRemoveButton();
                return;
            }

            const date = parseISODate(datePickerState.hiddenInput.value);
            if (date) {
                const { base, label } = formatDisplayDateWithDiff(date);
                datePickerState.displayInput.value = base;
                updateDateDiffLabel(label);
                updateDateRemoveButton();
            }
        }

        function setDateValue(date, closeAfter = true) {
            if (!datePickerState.hiddenInput || !datePickerState.displayInput) return;
            const iso = formatISODate(date);
            datePickerState.hiddenInput.value = iso;
            const { base, label } = formatDisplayDateWithDiff(date);
            datePickerState.displayInput.value = base;
            updateDateDiffLabel(label);
            // Actualizar también el label de horas si hay hora seleccionada
            updateTimeDiffLabel();
            // Actualizar el resumen de fecha y hora
            updateDateTimeSummary();
            // Actualizar visibilidad del botón de cerrar
            updateDateRemoveButton();
            datePickerState.calendarYear = date.getFullYear();
            datePickerState.calendarMonth = date.getMonth();
            if (datePickerState.isOpen) {
                renderDatePickerCalendar();
            }
            if (closeAfter) {
                closeDatePicker();
            }
        }

        function clearDateValue(event) {
            event.stopPropagation();
            if (!datePickerState.hiddenInput || !datePickerState.displayInput) return;
            datePickerState.hiddenInput.value = '';
            datePickerState.displayInput.value = '';
            updateDateDiffLabel(null);
            // Si se elimina la fecha, también eliminar la hora (sin día no tiene sentido tener hora)
            if (timePickerState.input) {
                timePickerState.selectedHour = null;
                timePickerState.selectedMinute = null;
                timePickerState.input.value = '';
                syncTimeHiddenInput();
                updateTimeInputFromState();
            }
            updateTimeDiffLabel();
            updateDateTimeSummary();
            updateDateRemoveButton();
        }

        function clearTimeValue(event) {
            event.stopPropagation();
            if (!timePickerState.input) return;
            timePickerState.selectedHour = null;
            timePickerState.selectedMinute = null;
            timePickerState.input.value = '';
            syncTimeHiddenInput();
            updateTimeInputFromState();
            updateTimeDiffLabel();
            updateDateTimeSummary();
            updateTimeRemoveButton();
        }

        function updateDateRemoveButton() {
            const removeBtn = document.querySelector('.date-picker-remove-btn');
            const dateInput = document.getElementById('taskDate');
            if (removeBtn && dateInput) {
                if (dateInput.value) {
                    removeBtn.classList.add('has-value');
                } else {
                    removeBtn.classList.remove('has-value');
                }
            }
        }

        function updateTimeRemoveButton() {
            const removeBtn = document.querySelector('.time-picker-remove-btn');
            if (removeBtn && timePickerState.input) {
                if (timePickerState.input.value) {
                    removeBtn.classList.add('has-value');
                } else {
                    removeBtn.classList.remove('has-value');
                }
            }
        }

        function applyQuickDateOption(option) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            let targetDate = new Date(today);

            targetDate = getQuickOptionDate(option, today);
            if (!targetDate) return;

            setDateValue(targetDate, true);
        }

        function applyQuickTimeOption(option) {
            const now = new Date();
            let target = new Date(now);

            switch (option) {
                case 'now':
                    break;
                case 'midnight':
                    target.setHours(0, 0, 0, 0);
                    break;
                case 'noon':
                    target.setHours(12, 0, 0, 0);
                    break;
                case 'morning':
                    target.setHours(9, 0, 0, 0);
                    break;
                case 'afternoon':
                    target.setHours(16, 0, 0, 0);
                    break;
                case 'evening':
                    target.setHours(20, 0, 0, 0);
                    break;
                default:
                    return;
            }

            const h = target.getHours();
            const m = target.getMinutes();
            timePickerState.selectedHour = h;
            // Para "now" usamos los minutos exactos; para el resto, redondeamos al cuarto de hora inferior
            timePickerState.selectedMinute =
                option === 'now' ? m : m - (m % 15);
            updateTimeInputFromState();
            renderTimePicker();
        }

        function getQuickOptionDate(option, baseDate = null) {
            const today = baseDate ? new Date(baseDate) : new Date();
            today.setHours(0, 0, 0, 0);
            let targetDate = new Date(today);

            switch (option) {
                case 'today':
                    break;
                case 'tomorrow':
                    targetDate = addDays(today, 1);
                    break;
                case 'next-week':
                    targetDate = addDays(today, 7);
                    break;
                case 'next-month':
                    targetDate = addMonths(today, 1);
                    break;
                case 'next-year':
                    targetDate = addYears(today, 1);
                    break;
                default:
                    return null;
            }
            return targetDate;
        }

        function updateQuickOptionLabels() {
            const buttons = document.querySelectorAll('.date-picker-quick-options button[data-option]');
            if (!buttons.length) return;

            buttons.forEach((button) => {
                const option = button.getAttribute('data-option');
                if (!option) return;

                const dateSpan = button.querySelector('.quick-option-date');
                if (!dateSpan) return;

                const date = getQuickOptionDate(option);
                if (!date) {
                    dateSpan.textContent = '';
                    return;
                }

                dateSpan.textContent = formatDisplayDate(date);
            });
        }

        function setupQuickOptionHover() {
            const buttons = document.querySelectorAll('.date-picker-quick-options button[data-option]');
            if (!buttons.length) return;

            buttons.forEach((button) => {
                const option = button.getAttribute('data-option');
                if (!option) return;

                button.addEventListener('mouseenter', () => {
                    setQuickOptionHover(option, true);
                });
                button.addEventListener('mouseleave', () => {
                    setQuickOptionHover(option, false);
                });
            });
        }

        function setQuickOptionHover(option, isHover) {
            if (!datePickerState.calendarDaysContainer) return;

            const container = datePickerState.calendarDaysContainer;

            // Limpiar cualquier hover previo
            const prev = container.querySelectorAll('.hover-linked');
            prev.forEach((el) => el.classList.remove('hover-linked'));

            if (!isHover) return;

            const mode = datePickerState.calendarMode || 'month';
            const year = datePickerState.calendarYear;
            const month = datePickerState.calendarMonth;
            if (year == null) return;

            const targetDate = getQuickOptionDate(option);
            if (!targetDate) return;

            if (mode === 'month') {
                // Resaltar el día concreto si está en el mes/año visibles
                if (targetDate.getFullYear() !== year || targetDate.getMonth() !== month) return;
                const targetDay = targetDate.getDate();
                const dayButtons = container.querySelectorAll('.calendar-day');
                dayButtons.forEach((btn) => {
                    const dayNumber = parseInt(btn.textContent, 10);
                    if (dayNumber === targetDay) {
                        btn.classList.add('hover-linked');
                    }
                });
            } else if (mode === 'year') {
                // Resaltar el mes correspondiente dentro del año visible
                if (targetDate.getFullYear() !== year) return;
                const targetMonthIndex = targetDate.getMonth();
                const monthButtons = container.querySelectorAll('.calendar-month');
                monthButtons.forEach((btn, index) => {
                    if (index === targetMonthIndex) {
                        btn.classList.add('hover-linked');
                    }
                });
            }
        }

        function addDays(date, days) {
            return new Date(date.getFullYear(), date.getMonth(), date.getDate() + days);
        }

        function addMonths(date, months) {
            return new Date(date.getFullYear(), date.getMonth() + months, date.getDate());
        }

        function addYears(date, years) {
            return new Date(date.getFullYear() + years, date.getMonth(), date.getDate());
        }

        function getPinIcon(color = '#64748b', size = 14) {
            return `<svg style="width: ${size}px; height: ${size}px; flex-shrink: 0; color: ${color};" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M17 12l4.5-2.5-7-7-2.5 4.5L3.5 10.5l10 10Z"></path>
                <path d="m1.5 22.5 7-7"></path>
            </svg>`;
        }

        function renderTagNameWithPin(tag, options = {}) {
            const {
                textColor = '#1e293b',
                fontSize = '14px',
                fontWeight = 'normal',
                flex = true,
                indicatorSize = 12,
                gap = 6,
                pinSize = 12,
                pinColor,
                showPin = true,
                showIndicator = true
            } = options;
            const flexStyle = flex ? 'flex: 1;' : '';
            const resolvedPinColor = pinColor || tag.color || '#3b82f6';
            const parts = [];
            if (showIndicator) {
                parts.push(`<span style="width: ${indicatorSize}px; height: ${indicatorSize}px; border-radius: 50%; background-color: ${tag.color || '#3b82f6'}; flex-shrink: 0;"></span>`);
            }
            if (showPin && tag.pinned) {
                parts.push(getPinIcon(resolvedPinColor, pinSize));
            }
            parts.push(`<span style="flex: 1; color: inherit;">${escapeHtml(tag.name)}</span>`);
            return `
                <span style="display: inline-flex; align-items: center; gap: ${gap}px; ${flexStyle} color: ${textColor}; font-size: ${fontSize}; font-weight: ${fontWeight};">
                    ${parts.join('')}
                </span>
            `;
        }

        function closeActiveTagModalDropdown() {
            if (activeTagModalDropdown && typeof activeTagModalDropdown.cleanup === 'function') {
                activeTagModalDropdown.cleanup();
            }
            activeTagModalDropdown = null;
        }

        function setContextMenuMode(mode) {
            const options = document.getElementById('contextMenuOptions');
            const confirm = document.getElementById('contextMenuConfirm');
            if (!options || !confirm) return;

            contextMenuMode = mode;
            if (mode === 'options') {
                options.style.display = 'flex';
                confirm.style.display = 'none';
            } else {
                options.style.display = 'none';
                confirm.style.display = 'flex';
            }
        }

        function showContextMenu(event, type, id) {
            event.preventDefault();
            event.stopPropagation();

            setContextMenuMode('options');
            const deleteOption = document.getElementById('contextMenuDeleteOption');
            const editOption = document.getElementById('contextMenuEditOption');
            const pinOption = document.getElementById('contextMenuPinOption');
            const pinOptionLabel = document.getElementById('contextMenuPinOptionLabel');
            const pinIconSlash = document.getElementById('contextMenuPinSlash');
            
            // Remove previous selection
            if (contextSelectedElement) {
                contextSelectedElement.classList.remove('context-selected');
            }
            
            // Find and highlight the clicked element
            let element = null;
            if (type === 'folder') {
                element = document.querySelector(`.folder-item[data-folder-id="${id}"]`);
            } else if (type === 'tag') {
                element = document.querySelector(`.tag-item[data-tag-id="${id}"]`);
            }
            
            if (element) {
                element.classList.add('context-selected');
                contextSelectedElement = element;
            }
            
            const contextMenu = document.getElementById('contextMenu');
            contextMenuTarget = id;
            contextMenuType = type;
            if (deleteOption) {
                if (type === 'folder' && (id === 'none' || id === null)) {
                    deleteOption.style.display = 'none';
                } else {
                    deleteOption.style.display = 'flex';
                }
            }
            if (editOption) {
                if (type === 'folder' && id === 'none') {
                    editOption.style.display = 'none';
                } else {
                    editOption.style.display = 'flex';
                }
            }
            if (pinOption) {
                if (type === 'folder' && id === null) {
                    pinOption.style.display = 'none';
                } else {
                    let isPinned = false;
                    if (type === 'folder') {
                        if (id === 'none') {
                            isPinned = isNoFolderPinned();
                        } else {
                            const folder = folders.find(f => f.id === id);
                            isPinned = !!folder?.pinned;
                        }
                    } else if (type === 'tag') {
                        const tag = tags.find(t => t.id === id);
                        isPinned = !!tag?.pinned;
                    }
                    pinOption.style.display = 'flex';
                    if (pinOptionLabel) {
                        pinOptionLabel.textContent = isPinned ? 'Unpin' : 'Pin';
                    }
                    if (pinIconSlash) {
                        pinIconSlash.style.display = isPinned ? 'block' : 'none';
                    }
                }
            }
            
            // Position menu at cursor
            contextMenu.style.display = 'flex';
            contextMenu.style.left = event.pageX + 'px';
            contextMenu.style.top = event.pageY + 'px';
            
            // Ensure menu stays within viewport
            setTimeout(() => {
                const rect = contextMenu.getBoundingClientRect();
                if (rect.right > window.innerWidth) {
                    contextMenu.style.left = (event.pageX - rect.width) + 'px';
                }
                if (rect.bottom > window.innerHeight) {
                    contextMenu.style.top = (event.pageY - rect.height) + 'px';
                }
            }, 0);
        }

        function hideContextMenu() {
            const contextMenu = document.getElementById('contextMenu');
            contextMenu.style.display = 'none';

            setContextMenuMode('options');
            
            // Remove highlight from selected element
            if (contextSelectedElement) {
                contextSelectedElement.classList.remove('context-selected');
                contextSelectedElement = null;
            }
            
            contextMenuTarget = null;
            contextMenuType = null;
        }

        function setupFolderContextMenu() {
            const folderItems = document.querySelectorAll('.folder-item[data-folder-id]');
            folderItems.forEach(folderItem => {
                folderItem.addEventListener('contextmenu', (e) => {
                    const folderId = folderItem.getAttribute('data-folder-id');
                    // Treat "none" folder the same as other folders
                    if (folderId === 'none') {
                        showContextMenu(e, 'folder', 'none');
                    } else {
                        showContextMenu(e, 'folder', parseInt(folderId));
                    }
                });
            });
        }

        function setupTagContextMenu() {
            const tagItems = document.querySelectorAll('.tag-item[data-tag-id]');
            tagItems.forEach(tagItem => {
                tagItem.addEventListener('contextmenu', (e) => {
                    const tagId = tagItem.getAttribute('data-tag-id');
                    showContextMenu(e, 'tag', parseInt(tagId));
                });
            });
        }

        function startTagEdit(tagId) {
            const numericId = typeof tagId === 'string' ? parseInt(tagId, 10) : tagId;
            const tag = tags.find(t => t.id === numericId);
            if (!tag) {
                showMessage('Tag not found', 'error');
                return;
            }
            openCreateTagModal({ mode: 'edit', tagData: tag });
        }

        function startFolderEdit(folderId) {
            if (folderId === 'none') {
                showMessage('This folder cannot be edited', 'error');
                return;
            }
            const numericId = typeof folderId === 'string' ? parseInt(folderId, 10) : folderId;
            const folder = folders.find(f => f.id === numericId);
            if (!folder) {
                showMessage('Folder not found', 'error');
                return;
            }
            openCreateFolderModal({ mode: 'edit', folderData: folder });
        }

        function handleContextMenuEdit() {
            const targetId = contextMenuTarget;
            const targetType = contextMenuType;
            hideContextMenu();
            
            if (!targetType || targetId === null || targetId === undefined) {
                return;
            }
            
            if (targetType === 'folder') {
                startFolderEdit(targetId);
            } else if (targetType === 'tag') {
                startTagEdit(targetId);
            }
        }

        async function handleContextMenuPin() {
            const targetId = contextMenuTarget;
            const targetType = contextMenuType;
            hideContextMenu();
            
            if (!targetType || targetId === null || targetId === undefined) {
                return;
            }
            
            if (targetType === 'folder') {
                await toggleFolderPinnedState(targetId);
            } else if (targetType === 'tag') {
                await toggleTagPinnedState(targetId);
            }
        }

        function handleContextMenuDelete() {
            if (contextMenuType === 'folder' && contextMenuTarget === 'none') {
                    showMessage('This folder cannot be deleted', 'error');
                hideContextMenu();
                    return;
                }

            const confirmTitle = document.getElementById('contextMenuConfirmTitle');
            confirmTitle.textContent = 'Are you sure?';

            setContextMenuMode('confirm');
        }

        function cancelContextMenuDelete() {
            setContextMenuMode('options');
        }

        function confirmContextMenuDelete() {
            const targetId = contextMenuTarget;
            const targetType = contextMenuType;

            hideContextMenu();

            if (targetType === 'folder' && targetId !== null) {
                deleteFolder(targetId);
            } else if (targetType === 'tag' && targetId !== null) {
                deleteTag(targetId);
            }
        }

        async function toggleFolderPinnedState(folderId) {
            if (folderId === 'none') {
                setNoFolderPinnedState(!isNoFolderPinned());
                return;
            }
            if (folderId === null || folderId === undefined) {
                showMessage('This folder cannot be pinned', 'error');
                return;
            }

            const numericId = typeof folderId === 'string' ? parseInt(folderId, 10) : folderId;
            if (Number.isNaN(numericId)) {
                return;
            }

            const folder = folders.find(f => f.id === numericId);
            if (!folder) {
                showMessage('Folder not found', 'error');
                return;
            }
            const willPin = !folder.pinned;

            try {
                const res = await fetch(`${FOLDERS_URL}/${numericId}`, {
                    method: 'PUT',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({
                        name: folder.id === 'none' ? 'NO FOLDER' : folder.name,
                        color: folder.color,
                        pinned: willPin
                    })
                });

                if (res.status === 401) {
                    logout();
                    return;
                }

                if (!res.ok) {
                    const error = await res.json();
                    throw new Error(error.message || 'Failed to update folder pin');
                }

                folder.pinned = willPin;
                renderTags();
                const tagsModal = document.getElementById('tagsModalOverlay');
                if (tagsModal && tagsModal.classList.contains('active')) {
                    renderTagsModal();
                }
                await loadFolders();
                showMessage(willPin ? 'Folder pinned' : 'Folder unpinned', 'success');
            } catch (error) {
                console.error('Error updating folder pin:', error);
                showMessage('Error updating folder pin', 'error');
            }
        }

        function isNoFolderPinned() {
            return noFolderPinned;
        }

        function setNoFolderPinnedState(shouldPin) {
            noFolderPinned = shouldPin;
            localStorage.setItem(getNoFolderPinStorageKey(), shouldPin ? 'true' : 'false');
            renderTags();
            const tagsModal = document.getElementById('tagsModalOverlay');
            if (tagsModal && tagsModal.classList.contains('active')) {
                renderTagsModal();
            }
            showMessage(shouldPin ? 'Folder pinned' : 'Folder unpinned', 'success');
        }

        async function toggleTagPinnedState(tagId) {
            const numericId = typeof tagId === 'string' ? parseInt(tagId, 10) : tagId;
            if (Number.isNaN(numericId)) {
                return;
            }

            const tag = tags.find(t => t.id === numericId);
            if (!tag) {
                showMessage('Tag not found', 'error');
                return;
            }
            const willPin = !tag.pinned;

            try {
                const res = await fetch(`${TAGS_URL}/${numericId}`, {
                    method: 'PUT',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({
                        name: tag.name,
                        color: tag.color,
                        folderId: tag.folderId,
                        pinned: willPin
                    })
                });

                if (res.status === 401) {
                    logout();
                    return;
                }

                if (!res.ok) {
                    const error = await res.json();
                    throw new Error(error.message || 'Failed to update tag pin');
                }

                tag.pinned = willPin;
                renderTags();
                const tagsModal = document.getElementById('tagsModalOverlay');
                if (tagsModal && tagsModal.classList.contains('active')) {
                    renderTagsModal();
                }
                await loadTags();
                showMessage(willPin ? 'Tag pinned' : 'Tag unpinned', 'success');
            } catch (error) {
                console.error('Error updating tag pin:', error);
                showMessage('Error updating tag pin', 'error');
            }
        }

        async function editFolder(folderId) {
            // "TAGS WITHOUT FOLDER" is a special folder that cannot be edited
            if (folderId === 'none') {
                showMessage('This folder cannot be edited', 'error');
                return;
            }

            const folder = folders.find(f => f.id === folderId);
            if (!folder) return;

            const newName = prompt('Enter new folder name:', folder.name);
            if (!newName || newName.trim() === '') return;

            const newColor = prompt('Enter new folder color (hex):', folder.color || '#64748b');
            if (!newColor) return;

            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`${FOLDERS_URL}/${folderId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        name: newName.trim().toUpperCase(),
                        color: newColor
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message || 'Failed to update folder');
                }

                await loadFolders();
                renderTags();
                showMessage('Folder updated', 'success');
            } catch (error) {
                console.error('Error updating folder:', error);
                showMessage('Error updating folder: ' + error.message, 'error');
            }
        }

        async function editTag(tagId) {
            const tag = tags.find(t => t.id === tagId);
            if (!tag) return;

            const newName = prompt('Enter new tag name:', tag.name);
            if (!newName || newName.trim() === '') return;
            
            if (newName.length > 20) {
                showMessage('Tag name must be 20 characters or less', 'error');
                return;
            }

            const newColor = prompt('Enter new tag color (hex):', tag.color || '#3b82f6');
            if (!newColor) return;

            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`${TAGS_URL}/${tagId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        name: newName.trim(),
                        color: newColor
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message || 'Failed to update tag');
                }

                await loadTags();
                renderTags();
                showMessage('Tag updated', 'success');
            } catch (error) {
                console.error('Error updating tag:', error);
                showMessage('Error updating tag: ' + error.message, 'error');
            }
        }

        async function moveTagToFolder(tagId, newFolderId) {
            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`/api/tags/${tagId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({ folderId: newFolderId })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message || 'Failed to move tag');
                }

                const updatedTag = await response.json();
                
                // Update the tag in the local array
                const tagIndex = tags.findIndex(t => t.id === tagId);
                if (tagIndex !== -1) {
                    tags[tagIndex] = {
                        ...tags[tagIndex],
                        ...updatedTag,
                        pinned: !!updatedTag.pinned
                    };
                }
                
                // Reload folders to update counts
                await loadFolders();
                
                // Re-render tags
                renderTags();
            } catch (error) {
                console.error('Error moving tag:', error);
                alert('Failed to move tag: ' + error.message);
            }
        }

        function selectFolder(folderId) {
            if (viewMode === 'folders') {
                selectedFolderId = folderId;
                if (tagsSearchTerm.trim() && folderId !== null) {
                    tagsSearchTerm = '';
                    const searchInput = document.getElementById('tagsSearchInput');
                    if (searchInput) {
                        searchInput.value = '';
                    }
                }
                renderTags();
            }
        }

        function navigateToFolder(folderId) {
            // Switch to folders view
            setViewMode('folders');
            // Select the folder
            selectedFolderId = folderId;
            // Re-render to show the selected folder
            renderTags();
        }

        function handleTagsSearch() {
            const searchInput = document.getElementById('tagsSearchInput');
            if (searchInput) {
                tagsSearchTerm = searchInput.value;
                renderTags();
            }
        }

        function toggleSortOrder() {
            tagsSortOrder = tagsSortOrder === 'asc' ? 'desc' : 'asc';
            updateSortButtonIcon();
            renderTags();
        }

        function updateSortButtonIcon() {
            const sortAscIcon = document.getElementById('sortAscIcon');
            const sortDescIcon = document.getElementById('sortDescIcon');
            if (sortAscIcon && sortDescIcon) {
                if (tagsSortOrder === 'asc') {
                    sortAscIcon.style.display = 'block';
                    sortDescIcon.style.display = 'none';
                } else {
                    sortAscIcon.style.display = 'none';
                    sortDescIcon.style.display = 'block';
                }
            }
        }

        function renderAccountTags() {
            const accountTagsList = document.getElementById('accountTagsList');
            if (!accountTagsList) return;

            if (tags.length === 0 && folders.length === 0) {
                accountTagsList.innerHTML = '<div style="color: #94a3b8; font-size: 12px; font-style: italic;">No tags yet</div>';
                return;
            }

            let html = '';

            // Render tags grouped by folders
            folders.forEach(folder => {
                const folderTags = tags.filter(tag => tag.folderId === folder.id);
                if (folderTags.length > 0) {
                    const folderColor = folder.color || '#64748b';
                    const sortedFolderTags = [...folderTags].sort((a, b) => {
                        const aPinned = a.pinned ? 1 : 0;
                        const bPinned = b.pinned ? 1 : 0;
                        if (aPinned !== bPinned) {
                            return bPinned - aPinned;
                        }
                        return a.name.localeCompare(b.name);
                    });
                    html += `
                        <div style="margin-bottom: 8px;">
                            <div style="font-size: 11px; font-weight: 600; color: ${folderColor}; margin-bottom: 6px; letter-spacing: 0.5px;">${escapeHtml(folder.name.toUpperCase())}</div>
                            <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                ${sortedFolderTags.map(tag => `
                                    <span style="display: inline-flex; align-items: center; gap: 6px; padding: 4px 8px; background: ${tag.color || '#3b82f6'}15; border: 1px solid ${tag.color || '#3b82f6'}40; border-radius: 6px; font-size: 12px; color: #1e293b;">
                                        ${renderTagNameWithPin(tag, {fontSize: '12px', indicatorSize: 8, pinSize: 10, gap: 4, flex: false})}
                                    </span>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }
            });

            // Render tags without folder
            const tagsWithoutFolder = tags.filter(tag => !tag.folderId);
            const sortedAccountTagsWithoutFolder = [...tagsWithoutFolder].sort((a, b) => {
                const aPinned = a.pinned ? 1 : 0;
                const bPinned = b.pinned ? 1 : 0;
                if (aPinned !== bPinned) {
                    return bPinned - aPinned;
                }
                return a.name.localeCompare(b.name);
            });
            if (sortedAccountTagsWithoutFolder.length > 0) {
                html += `
                    <div style="margin-bottom: 8px;">
                        <div style="font-size: 11px; font-weight: 600; color: #64748b; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Sin carpeta</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                            ${sortedAccountTagsWithoutFolder.map(tag => `
                                <span style="display: inline-flex; align-items: center; gap: 6px; padding: 4px 8px; background: ${tag.color || '#3b82f6'}15; border: 1px solid ${tag.color || '#3b82f6'}40; border-radius: 6px; font-size: 12px; color: #1e293b;">
                                    ${renderTagNameWithPin(tag, {fontSize: '12px', indicatorSize: 8, pinSize: 10, gap: 4, flex: false})}
                                </span>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            accountTagsList.innerHTML = html || '<div style="color: #94a3b8; font-size: 12px; font-style: italic;">No tags yet</div>';
        }

        function updateTagSelect() {
            const container = document.getElementById('taskTags');
            container.innerHTML = '';
            
            if (tags.length === 0) {
                container.innerHTML = '<div style="color: #999; font-size: 12px;">No tags available. Create tags below.</div>';
                return;
            }
            
            // If modal has been opened, show only selected tags
            // Renderizar en orden normal: más antigua a la izquierda, más nueva a la derecha
            if (tagsModalOpened && selectedTagsForTask.length > 0) {
                selectedTagsForTask.forEach(tagId => {
                    const tag = tags.find(t => t.id === tagId);
                    if (tag) {
                        const tagItem = createTagCheckboxItem(tag, true, { showPin: false });
                        container.appendChild(tagItem);
                    }
                });
                
                // Always show "X more" button if there are remaining tags
                if (tags.length > selectedTagsForTask.length) {
                    const remainingCount = tags.length - selectedTagsForTask.length;
                    const moreBtn = document.createElement('div');
                    moreBtn.className = 'tag-checkbox-item';
                    moreBtn.style.cssText = 'border: 2px dashed #cbd5e1; border-radius: 12px; background: #f8fafc; color: #64748b; font-weight: 500; cursor: pointer; white-space: nowrap; transition: all 0.3s ease;';
                    moreBtn.textContent = `${remainingCount} more`;
                    moreBtn.onclick = function(event) {
                        openTagsModal(event);
                    };
                    moreBtn.onmouseover = function() {
                        this.style.borderColor = '#3b82f6';
                        this.style.background = '#eff6ff';
                    };
                    moreBtn.onmouseout = function() {
                        this.style.borderColor = '#cbd5e1';
                        this.style.background = '#f8fafc';
                    };
                    container.appendChild(moreBtn);
                }
                return;
            }
            
            // If modal hasn't been opened, show recommended tags + selected tags
            // Get recently used tags (tags used in tasks, sorted by most recent task)
            const tagUsageMap = new Map(); // tagId -> { lastUsed: date, count: number }
            
            tasks.forEach(task => {
                if (task.tagIds && Array.isArray(task.tagIds)) {
                    const taskDate = new Date(task.updatedAt || task.createdAt || 0);
                    task.tagIds.forEach(tagId => {
                        const existing = tagUsageMap.get(tagId);
                        if (!existing || taskDate > existing.lastUsed) {
                            tagUsageMap.set(tagId, {
                                lastUsed: taskDate,
                                count: (existing?.count || 0) + 1
                            });
                        } else {
                            existing.count++;
                        }
                    });
                }
            });
            
            // Sort tags giving priority to pinned ones, then by most used
            const sortedTags = [...tags].sort((a, b) => {
                const aPinned = a.pinned ? 1 : 0;
                const bPinned = b.pinned ? 1 : 0;
                if (aPinned !== bPinned) {
                    return bPinned - aPinned;
                }
                const aUsage = tagUsageMap.get(a.id);
                const bUsage = tagUsageMap.get(b.id);
                
                // Tags that have been used come before tags that haven't
                if (!aUsage && !bUsage) {
                    // If neither has been used, sort alphabetically
                    return a.name.localeCompare(b.name);
                }
                if (!aUsage) return 1; // Unused tags go to the end
                if (!bUsage) return -1; // Used tags come first
                
                // Both have been used - sort by count (most used first)
                if (aUsage.count !== bUsage.count) {
                    return bUsage.count - aUsage.count;
                }
                // If same count, sort by most recent
                return bUsage.lastUsed - aUsage.lastUsed;
            });
            
            // Always show up to 4 tags (pinned first, then most used)
            const numTagsToShow = 4;
            const pinnedTags = sortedTags.filter(tag => tag.pinned);
            const nonPinnedTags = sortedTags.filter(tag => !tag.pinned);
            const prioritizedTags = [];
            pinnedTags.forEach(tag => {
                if (prioritizedTags.length < numTagsToShow) prioritizedTags.push(tag);
            });
            nonPinnedTags.forEach(tag => {
                if (prioritizedTags.length < numTagsToShow) prioritizedTags.push(tag);
            });
            const visibleTags = prioritizedTags;
            const totalRemaining = Math.max(0, tags.length - visibleTags.length);
            
            // Primero renderizar las etiquetas seleccionadas (más antigua a la izquierda)
            selectedTagsForTask.forEach(tagId => {
                const tag = tags.find(t => t.id === tagId);
                if (tag) {
                    const tagItem = createTagCheckboxItem(tag, true, { showPin: false });
                    container.appendChild(tagItem);
                }
            });
            
            // Luego renderizar las etiquetas no seleccionadas (recomendadas)
            visibleTags.forEach(tag => {
                const isSelected = selectedTagsForTask.includes(tag.id);
                if (!isSelected) {
                    const tagItem = createTagCheckboxItem(tag, false, { showPin: false });
                    container.appendChild(tagItem);
                }
            });
            
            // Add "X more" button if there are remaining tags
            if (totalRemaining > 0) {
                const moreBtn = document.createElement('div');
                moreBtn.className = 'tag-checkbox-item';
                moreBtn.style.cssText = 'border: 2px dashed #cbd5e1; border-radius: 12px; background: #f8fafc; color: #64748b; font-weight: 500; cursor: pointer; white-space: nowrap; transition: all 0.3s ease;';
                moreBtn.textContent = `${totalRemaining} more`;
                moreBtn.onclick = function(event) {
                    openTagsModal(event);
                };
                moreBtn.onmouseover = function() {
                    this.style.borderColor = '#3b82f6';
                    this.style.background = '#eff6ff';
                };
                moreBtn.onmouseout = function() {
                    this.style.borderColor = '#cbd5e1';
                    this.style.background = '#f8fafc';
                };
                container.appendChild(moreBtn);
            }
        }
        
        function createTagCheckboxItem(tag, isSelectedFromModal = false, options = {}) {
            const { showPin = true } = options;
            const tagItem = document.createElement('div');
            tagItem.className = 'tag-checkbox-item';
            tagItem.dataset.tagId = tag.id;
            const isSelected = isSelectedFromModal || selectedTagsForTask.includes(tag.id);
            const tagColor = tag.color || '#3b82f6';
            const selectedMarkup = `
                ${renderTagNameWithPin(tag, {
                    textColor: '#ffffff',
                    indicatorSize: 10,
                    pinSize: 10,
                    pinColor: '#ffffff',
                    showPin,
                    showIndicator: false
                })}
            `;
            const defaultMarkup = `
                ${renderTagNameWithPin(tag, {
                    indicatorSize: 10,
                    showPin
                })}
            `;
            
            // Create close button for selected tags
            const closeBtn = isSelected ? `
                <span class="tag-remove-btn" onclick="removeTagFromSelection(${tag.id}); event.stopPropagation();" style="
                    position: absolute;
                    top: -6px;
                    right: -6px;
                    width: 18px;
                    height: 18px;
                    border-radius: 50%;
                    background: #ef4444;
                    color: white;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    cursor: pointer;
                    opacity: 0;
                    transition: opacity 0.2s ease, transform 0.2s ease;
                    z-index: 10;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                ">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </span>
            ` : '';
            
            tagItem.style.position = 'relative';
            
            // If selected, use tag color as background with white text, no color indicator
            if (isSelected) {
                tagItem.style.backgroundColor = tagColor;
                tagItem.style.borderColor = tagColor;
                tagItem.style.color = 'white';
                tagItem.style.textAlign = 'center';
                tagItem.style.justifyContent = 'center';
                tagItem.innerHTML = `
                    ${selectedMarkup}
                    ${closeBtn}
                `;
            } else {
                // Not selected: show color indicator and normal styling
                tagItem.innerHTML = `
                    ${defaultMarkup}
                `;
            }
            
            if (isSelected) {
                tagItem.classList.add('selected');
            }
            
            // Show/hide close button on hover
            if (isSelected) {
                tagItem.addEventListener('mouseenter', function() {
                    const closeBtn = this.querySelector('.tag-remove-btn');
                    if (closeBtn) closeBtn.style.opacity = '1';
                });
                tagItem.addEventListener('mouseleave', function() {
                    const closeBtn = this.querySelector('.tag-remove-btn');
                    if (closeBtn) closeBtn.style.opacity = '0';
                });
            }
                
                tagItem.addEventListener('click', function(e) {
                // Si se hace clic en la cruz, no hacer nada aquí (ya se maneja en removeTagFromSelection)
                if (e.target.closest('.tag-remove-btn')) {
                    return;
                }
                
                const wasSelected = selectedTagsForTask.includes(tag.id);
                
                // Si ya está seleccionado, no permitir deseleccionar haciendo clic en la etiqueta
                // Solo se puede deseleccionar con la cruz
                if (wasSelected) {
                    return;
                }
                
                // Select (with max 3 limit)
                // Si ya hay 3 etiquetas, eliminar la más antigua (la primera del array, más a la izquierda)
                if (selectedTagsForTask.length >= 3) {
                    selectedTagsForTask.shift();
                }
                // Añadir la nueva etiqueta al final (más a la derecha entre las seleccionadas)
                selectedTagsForTask.push(tag.id);
                this.classList.add('selected');
                // Apply selected styling
                this.style.backgroundColor = tagColor;
                this.style.borderColor = tagColor;
                this.style.color = 'white';
                this.style.textAlign = 'center';
                this.style.justifyContent = 'center';
                this.innerHTML = `
                    ${selectedMarkup}
                    ${closeBtn}
                `;
                // Re-attach hover listeners for close button
                this.addEventListener('mouseenter', function() {
                    const closeBtn = this.querySelector('.tag-remove-btn');
                    if (closeBtn) closeBtn.style.opacity = '1';
                });
                this.addEventListener('mouseleave', function() {
                    const closeBtn = this.querySelector('.tag-remove-btn');
                    if (closeBtn) closeBtn.style.opacity = '0';
                });
                
                updateTagSelect();
                // Re-render tags modal if it's open
                const tagsModal = document.getElementById('tagsModalOverlay');
                if (tagsModal && tagsModal.classList.contains('active')) {
                    renderTagsModal();
                }
            });
            
            return tagItem;
        }
        
        function toggleTagSelection(tagId) {
            const index = selectedTagsForTask.indexOf(tagId);
            
            if (index > -1) {
                // Deselect
                selectedTagsForTask.splice(index, 1);
            } else {
                // Select (with max 3 limit)
                if (selectedTagsForTask.length >= 3) {
                    // Remove the first (oldest) selected tag
                    selectedTagsForTask.shift();
                }
                selectedTagsForTask.push(tagId);
            }
            
            // Update the tag select display
            updateTagSelect();
            // Re-render tags modal to show updated selection state
            renderTagsModal();
        }
        
        function removeTagFromSelection(tagId) {
            selectedTagsForTask = selectedTagsForTask.filter(id => id !== tagId);
            updateTagSelect();
            // Re-render tags modal if it's open
            const tagsModal = document.getElementById('tagsModalOverlay');
            if (tagsModal && tagsModal.classList.contains('active')) {
                renderTagsModal();
            }
        }

        // Tags Modal Functions
        function openTagsModal(event) {
            // Mark that modal has been opened
            tagsModalOpened = true;
            const modal = document.getElementById('tagsModalOverlay');
            const modalContent = modal ? modal.querySelector('.task-modal') : null;
            
            if (modal && modalContent) {
                // Position relative to task creation modal
                let targetX = 600;
                let targetY = 120;
                
                const taskModal = document.getElementById('taskModalOverlay');
                if (taskModal && taskModal.classList.contains('active')) {
                    const taskModalContent = taskModal.querySelector('.task-modal');
                    if (taskModalContent) {
                        const taskModalRect = taskModalContent.getBoundingClientRect();
                        // Position to the right of the task modal with 16px gap
                        targetX = taskModalRect.right + 16;
                        targetY = taskModalRect.top;
                    }
                }
                
                // Set position
                modalContent.style.left = targetX + 'px';
                modalContent.style.top = targetY + 'px';
                
                modal.classList.add('active');
                // Reset modal state - default to showing all tags
                tagsModalViewMode = 'tags';
                tagsModalSelectedFolderId = null;
                tagsModalSearchTerm = '';
                tagsModalSortOrder = 'asc';
                const searchInput = document.getElementById('tagsModalSearchInput');
                if (searchInput) {
                    searchInput.value = '';
                }
                
                // Update button states
                const foldersBtn = document.getElementById('tagsModalViewFoldersBtn');
                const tagsBtn = document.getElementById('tagsModalViewTagsBtn');
                if (foldersBtn) foldersBtn.classList.remove('active');
                if (tagsBtn) tagsBtn.classList.add('active');
                
                renderTagsModal();
                updateTagsModalFolderSelect();
                
                // Adjust position and height after content is rendered
                setTimeout(() => {
                    adjustTagsModalPosition();
                }, 10);
        }
        }
        
        function showTagsModalNewTagForm() {
            // Only show form when in tags view (all tags)
            if (tagsModalViewMode !== 'tags') {
                return;
            }
            
            const tagForm = document.getElementById('tagsModalNewTagForm');
            if (tagForm) {
                if (tagForm.style.display === 'none' || tagForm.style.display === '') {
                    tagForm.style.display = 'flex';
                } else {
                    tagForm.style.display = 'none';
                }
            }
        }
        
        function updateTagsModalFolderSelect() {
            const select = document.getElementById('tagsModalNewTagFolder');
            if (!select) return;
            
            const currentValue = select.value;
            select.innerHTML = '<option value="">No folder</option>';
            
            folders.forEach(folder => {
                const option = document.createElement('option');
                option.value = folder.id;
                option.textContent = escapeHtml(folder.name.toUpperCase());
                select.appendChild(option);
            });
            
            if (currentValue) {
                select.value = currentValue;
            }
        }
        
        function createTagFromTagsModal() {
            // Open the create tag modal instead
            openCreateTagModal();
        }

        function resetTagFormState() {
            tagFormMode = 'create';
            editingTagId = null;
            tagOriginalData = null;
        }

        function getTagFormValues() {
            return {
                name: (document.getElementById('createTagName')?.value || '').trim(),
                color: document.getElementById('createTagColor')?.value || '',
                folderId: document.getElementById('createTagFolderHidden')?.value || '',
                pinned: document.getElementById('createTagPinnedHidden')?.value === 'true'
            };
        }

        function hasTagFormChanges() {
            if (tagFormMode !== 'edit' || !tagOriginalData) {
                return true;
            }
            const current = getTagFormValues();
            return (
                current.name !== tagOriginalData.name ||
                current.color !== tagOriginalData.color ||
                current.folderId !== (tagOriginalData.folderId || '') ||
                current.pinned !== tagOriginalData.pinned
            );
        }

        // Create Tag Modal Functions
        function toggleCreateTagButton() {
            const nameInput = document.getElementById('createTagName');
            const submitBtn = document.getElementById('createTagSubmitBtn');
            
            if (!nameInput || !submitBtn) return;
            
            const hasValue = nameInput.value.trim().length > 0;
            let canSubmit = hasValue;
            if (tagFormMode === 'edit') {
                canSubmit = hasValue && hasTagFormChanges();
            }
            
            if (canSubmit) {
                submitBtn.disabled = false;
                submitBtn.style.background = '#3b82f6';
                submitBtn.style.cursor = 'pointer';
                submitBtn.style.opacity = '1';
            } else {
                submitBtn.disabled = true;
                submitBtn.style.background = '#93c5fd';
                submitBtn.style.cursor = 'not-allowed';
                submitBtn.style.opacity = '0.7';
            }
            submitBtn.textContent = tagFormMode === 'edit' ? 'Save Changes' : 'Create Tag';
        }
        
        function openCreateTagModal(options = {}) {
            const modal = document.getElementById('createTagModalOverlay');
            const modalContent = modal ? modal.querySelector('.task-modal') : null;
            
            if (modal && modalContent) {
                const { mode = 'create', tagData = null } = options;
                const isEditMode = mode === 'edit' && tagData;
                if (isEditMode) {
                    tagFormMode = 'edit';
                    editingTagId = tagData.id;
                    tagOriginalData = {
                        name: (tagData.name || '').trim(),
                        color: tagData.color || '#3b82f6',
                        folderId: tagData.folderId ? String(tagData.folderId) : '',
                        pinned: !!tagData.pinned
                    };
                } else {
                    resetTagFormState();
                }
                // Position relative to task creation modal
                let targetX = 600;
                let targetY = 120;
                
                const taskModal = document.getElementById('taskModalOverlay');
                const tagsModal = document.getElementById('tagsModalOverlay');
                const createTagModalHeight = 242.406;
                const createTagModalWidth = 450;
                
                if (taskModal && taskModal.classList.contains('active')) {
                    const taskModalContent = taskModal.querySelector('.task-modal');
                    if (taskModalContent) {
                        const taskModalRect = taskModalContent.getBoundingClientRect();
                        // Position to the right of the task modal with 16px gap (same as tags modal)
                        targetX = taskModalRect.right + 16;
                        
                        // Always align top with task modal
                        targetY = taskModalRect.top;
                        
                        // If tags modal is open, adjust height to leave margin
                        if (tagsModal && tagsModal.classList.contains('active')) {
                            const tagsModalContent = tagsModal.querySelector('.task-modal');
                            if (tagsModalContent) {
                                const tagsModalRect = tagsModalContent.getBoundingClientRect();
                                // Calculate available space above tags modal
                                const availableHeight = tagsModalRect.top - targetY - 16; // 16px margin
                                // Adjust height if needed, but keep minimum
                                if (availableHeight < createTagModalHeight) {
                                    modalContent.style.height = Math.max(availableHeight, 200) + 'px';
                                    modalContent.style.maxHeight = Math.max(availableHeight, 200) + 'px';
                                } else {
                                    modalContent.style.height = createTagModalHeight + 'px';
                                    modalContent.style.maxHeight = createTagModalHeight + 'px';
                                }
                            }
                        } else {
                            // Fix height when opening from task modal without tags modal
                            modalContent.style.height = createTagModalHeight + 'px';
                            modalContent.style.maxHeight = createTagModalHeight + 'px';
                        }
                    }
                } else {
                    // If task modal is not open, center it on screen
                    targetX = (window.innerWidth - createTagModalWidth) / 2;
                    targetY = (window.innerHeight - createTagModalHeight) / 2;
                    // Fix height when opening from profile
                    modalContent.style.height = createTagModalHeight + 'px';
                    modalContent.style.maxHeight = createTagModalHeight + 'px';
                }
                
                const profileOverlay = document.getElementById('profileOverlay');
                if (profileOverlay && profileOverlay.classList.contains('active')) {
                    modalContent.style.height = createTagModalHeight + 'px';
                    modalContent.style.maxHeight = createTagModalHeight + 'px';
                }
                // Ensure modal doesn't go off screen
                const maxX = window.innerWidth - createTagModalWidth - 20;
                const maxY = window.innerHeight - createTagModalHeight - 20;
                
                const finalX = Math.min(targetX, maxX);
                const finalY = Math.min(targetY, maxY);
                
                // Set position
                modalContent.style.left = Math.max(finalX, 20) + 'px';
                modalContent.style.top = Math.max(finalY, 20) + 'px';
                
                modal.classList.add('active');
                
                const form = document.getElementById('createTagForm');
                if (form) {
                    form.reset();
                }
                
                const nameInput = document.getElementById('createTagName');
                const colorInput = document.getElementById('createTagColor');
                const folderHidden = document.getElementById('createTagFolderHidden');
                const pinnedHidden = document.getElementById('createTagPinnedHidden');
                const headerTitle = modal.querySelector('.task-modal-header h2');
                const submitBtn = document.getElementById('createTagSubmitBtn');
                
                if (headerTitle) {
                    headerTitle.textContent = isEditMode ? 'Edit Tag' : 'Create Tag';
                }
                if (submitBtn) {
                    submitBtn.textContent = isEditMode ? 'Save Changes' : 'Create Tag';
                }
                
                if (isEditMode && tagOriginalData) {
                    if (nameInput) nameInput.value = tagOriginalData.name;
                    if (colorInput) colorInput.value = tagOriginalData.color;
                    if (folderHidden) folderHidden.value = tagOriginalData.folderId || '';
                    if (pinnedHidden) pinnedHidden.value = tagOriginalData.pinned ? 'true' : 'false';
                } else {
                    const defaultFolderId = getDefaultFolderIdForNewTag();
                    if (nameInput) nameInput.value = '';
                    if (colorInput) colorInput.value = '#3b82f6';
                    if (folderHidden) folderHidden.value = defaultFolderId ? defaultFolderId : '';
                    if (pinnedHidden) pinnedHidden.value = 'false';
                }
                updateCreateTagFolderBtnVisual(document.getElementById('createTagFolderBtn'));
                updateCreateTagColorBtnVisual(document.getElementById('createTagColorBtn'));
                updateCreateTagPinBtnVisual(document.getElementById('createTagPinnedBtn'));
                updateCreateTagPreview();
                toggleCreateTagButton();
                
                // Focus on name input
                setTimeout(() => {
                    const nameInput = document.getElementById('createTagName');
                    if (nameInput) {
                        nameInput.focus();
                    }
                }, 100);
            }
        }

        function closeCreateTagModal() {
            const modal = document.getElementById('createTagModalOverlay');
            if (modal) {
                modal.classList.remove('active');
            }
            // Reset form
            const form = document.getElementById('createTagForm');
            if (form) {
                form.reset();
                document.getElementById('createTagColor').value = '#3b82f6';
                document.getElementById('createTagFolderHidden').value = '';
                document.getElementById('createTagPinnedHidden').value = 'false';
                updateCreateTagFolderBtnVisual(document.getElementById('createTagFolderBtn'));
                updateCreateTagColorBtnVisual(document.getElementById('createTagColorBtn'));
                updateCreateTagPinBtnVisual(document.getElementById('createTagPinnedBtn'));
                updateCreateTagPreview();
                toggleCreateTagButton();
            }
            resetTagFormState();
        }

        function closeCreateTagModalOnOverlay(event) {
            if (event.target.id === 'createTagModalOverlay') {
                closeCreateTagModal();
            }
        }
        
        // Create Folder Modal Functions
        function openCreateFolderModal(options = {}) {
            const modal = document.getElementById('createFolderModalOverlay');
            const modalContent = modal ? modal.querySelector('.task-modal') : null;
            
            if (modal && modalContent) {
                const { mode = 'create', folderData = null } = options;
                const isEditMode = mode === 'edit' && folderData && folderData.id !== 'none';
                if (isEditMode) {
                    folderFormMode = 'edit';
                    editingFolderId = folderData.id;
                    folderOriginalData = {
                        name: (folderData.name || '').trim(),
                        color: folderData.color || '#64748b',
                        pinned: !!folderData.pinned
                    };
                } else {
                    resetFolderFormState();
                }
                // Position relative to task creation modal
                let targetX = 600;
                let targetY = 120;
                
                const taskModal = document.getElementById('taskModalOverlay');
                const tagsModal = document.getElementById('tagsModalOverlay');
                const createTagModal = document.getElementById('createTagModalOverlay');
                const createFolderModalHeight = 242.406;
                const createFolderModalWidth = 450;
                
                if (taskModal && taskModal.classList.contains('active')) {
                    const taskModalContent = taskModal.querySelector('.task-modal');
                    if (taskModalContent) {
                        const taskModalRect = taskModalContent.getBoundingClientRect();
                        // Position to the right of the task modal with 16px gap (same as tags modal)
                        targetX = taskModalRect.right + 16;
                        
                        // Always align top with task modal
                        targetY = taskModalRect.top;
                        
                        // If tags modal is open, adjust position to leave margin
                        if (tagsModal && tagsModal.classList.contains('active')) {
                            const tagsModalContent = tagsModal.querySelector('.task-modal');
                            if (tagsModalContent) {
                                const tagsModalRect = tagsModalContent.getBoundingClientRect();
                                // Calculate available space above tags modal
                                const availableHeight = tagsModalRect.top - targetY - 16; // 16px margin
                                // Adjust height if needed, but keep minimum
                                if (availableHeight < createFolderModalHeight) {
                                    modalContent.style.height = Math.max(availableHeight, 200) + 'px';
                                    modalContent.style.maxHeight = Math.max(availableHeight, 200) + 'px';
                                } else {
                                    modalContent.style.height = createFolderModalHeight + 'px';
                                    modalContent.style.maxHeight = createFolderModalHeight + 'px';
                                }
                            }
                        } else {
                            // Fix height when opening from task modal without tags modal
                            modalContent.style.height = createFolderModalHeight + 'px';
                            modalContent.style.maxHeight = createFolderModalHeight + 'px';
                        }
                    }
                } else {
                    // If task modal is not open, center it on screen
                    targetX = (window.innerWidth - createFolderModalWidth) / 2;
                    targetY = (window.innerHeight - createFolderModalHeight) / 2;
                    // Fix height when opening from profile
                    modalContent.style.height = createFolderModalHeight + 'px';
                    modalContent.style.maxHeight = createFolderModalHeight + 'px';
                }
                
                const profileOverlay = document.getElementById('profileOverlay');
                if (profileOverlay && profileOverlay.classList.contains('active')) {
                    modalContent.style.height = createFolderModalHeight + 'px';
                    modalContent.style.maxHeight = createFolderModalHeight + 'px';
                }
                // Ensure modal doesn't go off screen
                const maxX = window.innerWidth - createFolderModalWidth - 20;
                const maxY = window.innerHeight - createFolderModalHeight - 20;
                
                const finalX = Math.min(targetX, maxX);
                const finalY = Math.min(targetY, maxY);
                
                // Set position
                modalContent.style.left = Math.max(finalX, 20) + 'px';
                modalContent.style.top = Math.max(finalY, 20) + 'px';
                
                modal.classList.add('active');
                
                // Reset form state
                const form = document.getElementById('createFolderForm');
                if (form) {
                    form.reset();
                }
                const nameInput = document.getElementById('createFolderName');
                const colorInput = document.getElementById('createFolderColor');
                const pinnedHidden = document.getElementById('createFolderPinnedHidden');
                const headerTitle = modal.querySelector('.task-modal-header h2');
                const submitBtn = document.getElementById('createFolderSubmitBtn');
                
                if (headerTitle) {
                    headerTitle.textContent = isEditMode ? 'Edit Folder' : 'New Folder';
                }
                if (submitBtn) {
                    submitBtn.textContent = isEditMode ? 'Save Changes' : 'Create Folder';
                }
                
                if (isEditMode && folderOriginalData) {
                    if (nameInput) nameInput.value = folderOriginalData.name;
                    if (colorInput) colorInput.value = folderOriginalData.color;
                    if (pinnedHidden) pinnedHidden.value = folderOriginalData.pinned ? 'true' : 'false';
                } else {
                    if (nameInput) nameInput.value = '';
                    if (colorInput) colorInput.value = '#64748b';
                    if (pinnedHidden) pinnedHidden.value = 'false';
                }
                updateCreateFolderColorBtnVisual(document.getElementById('createFolderColorBtn'));
                updateCreateFolderPinBtnVisual(document.getElementById('createFolderPinnedBtn'));
                toggleCreateFolderButton();
                
                // Focus on name input
                setTimeout(() => {
                    const nameInput = document.getElementById('createFolderName');
                    if (nameInput) {
                        nameInput.focus();
                    }
                }, 100);
            }
        }
        
        function closeCreateFolderModal() {
            const modal = document.getElementById('createFolderModalOverlay');
            if (modal) {
                modal.classList.remove('active');
            }
            // Reset form
            const form = document.getElementById('createFolderForm');
            if (form) {
                form.reset();
                document.getElementById('createFolderColor').value = '#64748b';
                document.getElementById('createFolderPinnedHidden').value = 'false';
                updateCreateFolderColorBtnVisual(document.getElementById('createFolderColorBtn'));
                updateCreateFolderPinBtnVisual(document.getElementById('createFolderPinnedBtn'));
                toggleCreateFolderButton();
            }
            resetFolderFormState();
        }
        
        function closeCreateFolderModalOnOverlay(event) {
            if (event.target.id === 'createFolderModalOverlay') {
                closeCreateFolderModal();
            }
        }

        function resetFolderFormState() {
            folderFormMode = 'create';
            editingFolderId = null;
            folderOriginalData = null;
        }

        function getFolderFormValues() {
            return {
                name: (document.getElementById('createFolderName')?.value || '').trim(),
                color: document.getElementById('createFolderColor')?.value || '',
                pinned: document.getElementById('createFolderPinnedHidden')?.value === 'true'
            };
        }

        function hasFolderFormChanges() {
            if (folderFormMode !== 'edit' || !folderOriginalData) {
                return true;
            }
            const current = getFolderFormValues();
            return (
                current.name !== folderOriginalData.name ||
                current.color !== folderOriginalData.color ||
                current.pinned !== folderOriginalData.pinned
            );
        }
        
        function toggleCreateFolderButton() {
            const nameInput = document.getElementById('createFolderName');
            const submitBtn = document.getElementById('createFolderSubmitBtn');
            
            if (!nameInput || !submitBtn) return;
            
            const hasValue = nameInput.value.trim().length > 0;
            let canSubmit = hasValue;
            if (folderFormMode === 'edit') {
                canSubmit = hasValue && hasFolderFormChanges();
            }
            
            if (canSubmit) {
                submitBtn.disabled = false;
                submitBtn.style.background = '#3b82f6';
                submitBtn.style.cursor = 'pointer';
                submitBtn.style.opacity = '1';
            } else {
                submitBtn.disabled = true;
                submitBtn.style.background = '#93c5fd';
                submitBtn.style.cursor = 'not-allowed';
                submitBtn.style.opacity = '0.7';
            }
            submitBtn.textContent = folderFormMode === 'edit' ? 'Save Changes' : 'Create Folder';
            
            updateCreateFolderPreview();
        }
        
        function updateCreateFolderPreview() {
            const previewCard = document.getElementById('createFolderPreviewCard');
            const previewName = document.getElementById('createFolderPreviewName');
            const previewPin = document.getElementById('createFolderPreviewPin');
            if (!previewCard || !previewName || !previewPin) return;
            
            const nameInput = document.getElementById('createFolderName');
            const colorInput = document.getElementById('createFolderColor');
            const pinnedHidden = document.getElementById('createFolderPinnedHidden');
            
            const folderName = (nameInput?.value.trim() || 'Sample Folder').toUpperCase();
            const color = colorInput?.value || '#64748b';
            const borderAccent = darkenColor(color, 0.15);
            
            previewName.textContent = folderName;
            previewName.style.color = color;
            
            previewCard.style.borderLeft = `4px solid ${color}`;
            previewCard.style.borderTop = `2px solid ${borderAccent}`;
            previewCard.style.borderRight = `2px solid ${borderAccent}`;
            previewCard.style.borderBottom = `2px solid ${borderAccent}`;
            previewCard.style.background = `${color}20`;
            
            const isPinned = pinnedHidden?.value === 'true';
            previewPin.style.display = isPinned ? 'block' : 'none';
            previewPin.style.color = color;
        }
        
        function showCreateFolderColorMenu(event) {
            event.preventDefault();
            event.stopPropagation();
            const colorBtn = document.getElementById('createFolderColorBtn');
            if (!colorBtn) return;
            
            if (activeTagModalDropdown && activeTagModalDropdown.type === 'folder-color') {
                closeActiveTagModalDropdown();
                return;
            }
            closeActiveTagModalDropdown();
            
            const existingMenu = document.getElementById('createFolderColorMenu');
            if (existingMenu) existingMenu.remove();
            
            const menu = document.createElement('div');
            menu.id = 'createFolderColorMenu';
            const menuWidth = 200;
            menu.style.cssText = `position: absolute; background: white; border: 1px solid #e2e8f0; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 10001; padding: 8px; display: grid; grid-template-columns: repeat(5, 1fr); gap: 6px; width: ${menuWidth}px;`;
            
            const btnRect = colorBtn.getBoundingClientRect();
            let leftPosition = btnRect.right - menuWidth;
            if (leftPosition < 20) {
                leftPosition = 20;
            }
            menu.style.left = leftPosition + 'px';
            menu.style.top = (btnRect.bottom + 4) + 'px';
            
            const cleanupColorMenu = () => {
                if (menu && menu.parentNode) {
                    menu.remove();
                }
                document.removeEventListener('click', closeMenu, true);
                if (activeTagModalDropdown && activeTagModalDropdown.type === 'folder-color') {
                    activeTagModalDropdown = null;
                }
            };
            
            const closeMenu = (e) => {
                if (!menu.contains(e.target) && !colorBtn.contains(e.target)) {
                    cleanupColorMenu();
                }
            };
            
            FOLDER_PRESET_COLORS.forEach(color => {
                const colorItem = document.createElement('div');
                colorItem.style.cssText = `width: 28px; height: 28px; border-radius: 6px; background: ${color}; cursor: pointer; border: 2px solid transparent; transition: all 0.2s ease;`;
                colorItem.onmouseover = () => {
                    colorItem.style.borderColor = '#3b82f6';
                    colorItem.style.transform = 'scale(1.1)';
                };
                colorItem.onmouseout = () => {
                    colorItem.style.borderColor = 'transparent';
                    colorItem.style.transform = 'scale(1)';
                };
                colorItem.onclick = () => {
                    document.getElementById('createFolderColor').value = color;
                    updateCreateFolderColorBtnVisual(document.getElementById('createFolderColorBtn'));
                    updateCreateFolderPreview();
                    cleanupColorMenu();
                };
                menu.appendChild(colorItem);
            });
            
            document.body.appendChild(menu);
            
            setTimeout(() => {
                document.addEventListener('click', closeMenu, true);
            }, 0);
            
            activeTagModalDropdown = {
                type: 'folder-color',
                cleanup: cleanupColorMenu
            };
        }
        
        function updateCreateFolderColorBtnVisual(btnElement) {
            if (!btnElement) return;
            const color = document.getElementById('createFolderColor').value || '#64748b';
            const darkerColor = darkenColor(color, 20);
            const svg = btnElement.querySelector('svg');
            
            if (svg) {
                svg.setAttribute('fill', color);
                svg.setAttribute('stroke', '#000000');
            }
            
            updateCreateFolderPreview();
            toggleCreateFolderButton();
        }
        
        function toggleCreateFolderPin() {
            const hiddenInput = document.getElementById('createFolderPinnedHidden');
            const btn = document.getElementById('createFolderPinnedBtn');
            const isPinned = hiddenInput.value === 'true';
            hiddenInput.value = isPinned ? 'false' : 'true';
            updateCreateFolderPinBtnVisual(btn);
            updateCreateFolderPreview();
            toggleCreateFolderButton();
        }
        
        function updateCreateFolderPinBtnVisual(btnElement) {
            if (!btnElement) return;
            const isPinned = document.getElementById('createFolderPinnedHidden').value === 'true';
            const svg = btnElement.querySelector('svg');
            
            if (isPinned) {
                btnElement.classList.add('active');
                btnElement.style.background = '#3b82f6';
                btnElement.style.borderColor = '#3b82f6';
                btnElement.style.color = '#ffffff';
                if (svg) {
                    svg.setAttribute('stroke', '#000000');
                }
            } else {
                btnElement.classList.remove('active');
                btnElement.style.background = '#ffffff';
                btnElement.style.borderColor = '#e2e8f0';
                btnElement.style.color = '#64748b';
                if (svg) {
                    svg.setAttribute('stroke', '#000000');
                }
            }
            
            updateCreateFolderPreview();
        }
        
        async function handleCreateFolderSubmit(event) {
            event.preventDefault();
            
            const name = document.getElementById('createFolderName').value.trim();
            const color = document.getElementById('createFolderColor').value;
            const pinned = document.getElementById('createFolderPinnedHidden').value === 'true';
            const isEditMode = folderFormMode === 'edit' && editingFolderId !== null;
            
            if (!name) {
                showMessage('Folder name is required', 'error');
                return;
            }
            if (name.length > 15) {
                showMessage('Folder name must be 15 characters or less', 'error');
                return;
            }
            
            try {
                const endpoint = isEditMode ? `${FOLDERS_URL}/${editingFolderId}` : FOLDERS_URL;
                const method = isEditMode ? 'PUT' : 'POST';
                const res = await fetch(endpoint, {
                    method,
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ name, color, pinned })
                });
                
                if (res.status === 401) {
                    logout();
                    return;
                }
                
                const data = await res.json();
                if (!res.ok) {
                    showMessage(data.message || 'Error creating folder', 'error');
                    return;
                }
                
                showMessage(isEditMode ? 'Folder updated' : 'Folder created', 'success');
                closeCreateFolderModal();
                await loadFolders();
                renderTags();
                // If tags modal is open, refresh it
                const tagsModal = document.getElementById('tagsModalOverlay');
                if (tagsModal && tagsModal.classList.contains('active')) {
                    renderTagsModal();
                }
            } catch (error) {
                console.error('Error creating folder:', error);
                showMessage('Error creating folder', 'error');
            }
        }

        function updateCreateTagModalFolderSelect() {
            // No longer needed - using button instead of select
        }

        function updateCreateTagFolderBtnVisual(btnElement) {
            if (!btnElement) return;
            const folderId = document.getElementById('createTagFolderHidden').value;
            const defaultBorder = '#e2e8f0';
            const defaultColor = '#64748b';
            const svg = btnElement.querySelector('svg');
            const folderPath = svg ? svg.querySelector('path') : null;
            if (folderId) {
                const folder = folders.find(f => f.id === parseInt(folderId));
                if (folder) {
                    const baseColor = folder.color || '#3b82f6';
                    const borderColor = darkenColor(baseColor, 0.25);
                    btnElement.style.borderColor = defaultBorder;
                    btnElement.style.background = '#ffffff';
                    btnElement.style.color = defaultColor;
                    if (folderPath) {
                        folderPath.setAttribute('stroke', '#000000');
                        folderPath.setAttribute('fill', baseColor);
                    }
                }
            } else {
                btnElement.style.borderColor = defaultBorder;
                btnElement.style.background = '#ffffff';
                btnElement.style.color = defaultColor;
                if (folderPath) {
                    folderPath.setAttribute('stroke', '#000000');
                    folderPath.setAttribute('fill', 'none');
                }
            }
            toggleCreateTagButton();
        }

        function showCreateTagFolderMenu(event) {
            event.preventDefault();
            event.stopPropagation();
            const folderBtn = document.getElementById('createTagFolderBtn');
            if (!folderBtn) return;
            
            if (activeTagModalDropdown && activeTagModalDropdown.type === 'folder') {
                closeActiveTagModalDropdown();
                return;
            }
            closeActiveTagModalDropdown();
            
            const existingMenu = document.getElementById('createTagFolderMenu');
            if (existingMenu) existingMenu.remove();
            
            let folderMenuStyles = document.getElementById('createTagFolderMenuStyles');
            if (!folderMenuStyles) {
                folderMenuStyles = document.createElement('style');
                folderMenuStyles.id = 'createTagFolderMenuStyles';
                folderMenuStyles.textContent = `
                    #createTagFolderMenu::-webkit-scrollbar {
                        display: none;
                    }
                    #createTagFolderMenu {
                        -ms-overflow-style: none;
                        scrollbar-width: none;
                    }
                `;
                document.head.appendChild(folderMenuStyles);
            }
            
            const menu = document.createElement('div');
            menu.id = 'createTagFolderMenu';
            menu.style.cssText = 'position: absolute; background: white; border: 1px solid #e2e8f0; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 10001; max-height: 200px; overflow-y: auto; overflow-x: hidden; min-width: 200px;';
            
            const btnRect = folderBtn.getBoundingClientRect();
            menu.style.left = btnRect.left + 'px';
            menu.style.top = (btnRect.bottom + 4) + 'px';
            
            folderBtn.classList.add('active');
            
            const cleanupFolderMenu = () => {
                if (menu && menu.parentNode) {
                    menu.remove();
                }
                folderBtn.classList.remove('active');
                document.removeEventListener('click', closeMenu, true);
                if (activeTagModalDropdown && activeTagModalDropdown.type === 'folder') {
                    activeTagModalDropdown = null;
                }
            };
            
            const closeMenu = (e) => {
                if (!menu.contains(e.target) && !folderBtn.contains(e.target)) {
                    cleanupFolderMenu();
                }
            };
            
            // Add "No folder" option
            const noFolderItem = document.createElement('div');
            noFolderItem.style.cssText = 'padding: 8px 12px; cursor: pointer; font-size: 14px; color: #1e293b; transition: background 0.2s ease;';
            noFolderItem.textContent = 'No folder';
            noFolderItem.onmouseover = () => noFolderItem.style.background = '#f8fafc';
            noFolderItem.onmouseout = () => noFolderItem.style.background = 'transparent';
            noFolderItem.onclick = () => {
                document.getElementById('createTagFolderHidden').value = '';
                updateCreateTagFolderBtnVisual(document.getElementById('createTagFolderBtn'));
                updateCreateTagPreview();
                toggleCreateTagButton();
                cleanupFolderMenu();
            };
            menu.appendChild(noFolderItem);
            
            // Add folder options
            folders.forEach(folder => {
                const folderItem = document.createElement('div');
                folderItem.style.cssText = 'padding: 8px 12px; cursor: pointer; font-size: 14px; color: #1e293b; transition: background 0.2s ease; display: flex; align-items: center; gap: 8px;';
                folderItem.innerHTML = `<span style="width: 12px; height: 12px; border-radius: 50%; background: ${folder.color || '#64748b'};"></span>${escapeHtml(folder.name.toUpperCase())}`;
                folderItem.onmouseover = () => folderItem.style.background = '#f8fafc';
                folderItem.onmouseout = () => folderItem.style.background = 'transparent';
                folderItem.onclick = () => {
                    document.getElementById('createTagFolderHidden').value = folder.id;
                    updateCreateTagFolderBtnVisual(document.getElementById('createTagFolderBtn'));
                    updateCreateTagPreview();
                    toggleCreateTagButton();
                    cleanupFolderMenu();
                };
                menu.appendChild(folderItem);
            });
            
            document.body.appendChild(menu);
            
            setTimeout(() => {
                document.addEventListener('click', closeMenu, true);
            }, 0);
            
            activeTagModalDropdown = {
                type: 'folder',
                cleanup: cleanupFolderMenu
            };
        }

        function showCreateTagColorMenu(event) {
            event.preventDefault();
            event.stopPropagation();
            const colorBtn = document.getElementById('createTagColorBtn');
            if (!colorBtn) return;
            
            if (activeTagModalDropdown && activeTagModalDropdown.type === 'color') {
                closeActiveTagModalDropdown();
                return;
            }
            closeActiveTagModalDropdown();
            
            const existingMenu = document.getElementById('createTagColorMenu');
            if (existingMenu) existingMenu.remove();
            
            const menu = document.createElement('div');
            menu.id = 'createTagColorMenu';
            const menuWidth = 200;
            menu.style.cssText = `position: absolute; background: white; border: 1px solid #e2e8f0; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 10001; padding: 8px; display: grid; grid-template-columns: repeat(5, 1fr); gap: 6px; width: ${menuWidth}px;`;
            
            const btnRect = colorBtn.getBoundingClientRect();
            let leftPosition = btnRect.right - menuWidth;
            if (leftPosition < 20) {
                leftPosition = 20;
            }
            menu.style.left = leftPosition + 'px';
            menu.style.top = (btnRect.bottom + 4) + 'px';
            
            const cleanupColorMenu = () => {
                if (menu && menu.parentNode) {
                    menu.remove();
                }
                document.removeEventListener('click', closeMenu, true);
                if (activeTagModalDropdown && activeTagModalDropdown.type === 'color') {
                    activeTagModalDropdown = null;
                }
            };
            
            const closeMenu = (e) => {
                if (!menu.contains(e.target) && !colorBtn.contains(e.target)) {
                    cleanupColorMenu();
                }
            };
            
            // Predefined colors
            TAG_PRESET_COLORS.forEach(color => {
                const colorItem = document.createElement('div');
                colorItem.style.cssText = `width: 28px; height: 28px; border-radius: 6px; background: ${color}; cursor: pointer; border: 2px solid transparent; transition: all 0.2s ease;`;
                colorItem.onmouseover = () => {
                    colorItem.style.borderColor = '#3b82f6';
                    colorItem.style.transform = 'scale(1.1)';
                };
                colorItem.onmouseout = () => {
                    colorItem.style.borderColor = 'transparent';
                    colorItem.style.transform = 'scale(1)';
                };
                colorItem.onclick = () => {
                    document.getElementById('createTagColor').value = color;
                    updateCreateTagColorBtnVisual(document.getElementById('createTagColorBtn'));
                    updateCreateTagPreview();
                    toggleCreateTagButton();
                    cleanupColorMenu();
                };
                menu.appendChild(colorItem);
            });
            
            document.body.appendChild(menu);
            
            setTimeout(() => {
                document.addEventListener('click', closeMenu, true);
            }, 0);
            
            activeTagModalDropdown = {
                type: 'color',
                cleanup: cleanupColorMenu
            };
        }

        function updateCreateTagColorBtnVisual(btnElement) {
            if (!btnElement) return;
            const color = document.getElementById('createTagColor').value;
            const tagPath = btnElement.querySelector('path');
            const tagDot = btnElement.querySelector('line');
            const defaultBorder = '#e2e8f0';
            if (color) {
                btnElement.style.borderColor = defaultBorder;
                btnElement.style.background = '#ffffff';
                btnElement.style.color = '#000000';
                if (tagPath) {
                    tagPath.setAttribute('stroke', '#000000');
                    tagPath.setAttribute('fill', color);
                }
                if (tagDot) {
                    tagDot.setAttribute('stroke', '#000000');
                }
            } else {
                btnElement.style.borderColor = defaultBorder;
                btnElement.style.background = '#ffffff';
                btnElement.style.color = '#64748b';
                if (tagPath) {
                    tagPath.setAttribute('stroke', 'currentColor');
                    tagPath.setAttribute('fill', 'none');
                }
                if (tagDot) {
                    tagDot.setAttribute('stroke', 'currentColor');
                }
            }
            toggleCreateTagButton();
        }

        function toggleCreateTagPin() {
            const hiddenInput = document.getElementById('createTagPinnedHidden');
            const btn = document.getElementById('createTagPinnedBtn');
            const isPinned = hiddenInput.value === 'true';
            hiddenInput.value = isPinned ? 'false' : 'true';
            updateCreateTagPinBtnVisual(btn);
            updateCreateTagPreview();
            toggleCreateTagButton();
        }

        function updateCreateTagPinBtnVisual(btnElement) {
            if (!btnElement) return;
            const isPinned = document.getElementById('createTagPinnedHidden').value === 'true';
            const svg = btnElement.querySelector('svg');
            
            if (isPinned) {
                btnElement.classList.add('active');
                btnElement.style.background = '#3b82f6';
                btnElement.style.borderColor = '#3b82f6';
                btnElement.style.color = '#ffffff';
                if (svg) {
                    svg.setAttribute('stroke', '#000000');
                }
            } else {
                btnElement.classList.remove('active');
                btnElement.style.background = '#ffffff';
                btnElement.style.borderColor = '#e2e8f0';
                btnElement.style.color = '#64748b';
                if (svg) {
                    svg.setAttribute('stroke', '#000000');
                }
            }
        }

        function updateCreateTagPreview() {
            const nameInput = document.getElementById('createTagName');
            const previewText = document.getElementById('createTagPreviewText');
            const previewDot = document.getElementById('createTagPreviewDot');
            const previewPin = document.getElementById('createTagPreviewPin');
            const folderBadge = document.getElementById('createTagPreviewFolder');
            const taskPreviewBox = document.getElementById('createTagTaskPreviewBox');
            const taskPreviewText = document.getElementById('createTagTaskPreviewText');
            const colorInput = document.getElementById('createTagColor');
            const folderHidden = document.getElementById('createTagFolderHidden');
            const pinnedHidden = document.getElementById('createTagPinnedHidden');
            
            if (!previewText || !previewDot || !folderBadge || !nameInput || !colorInput || !folderHidden || !taskPreviewBox || !taskPreviewText || !previewPin || !pinnedHidden) return;
            
            const name = nameInput.value.trim() || 'Sample Tag';
            previewText.textContent = name;
            
            const tagColor = colorInput.value || '#3b82f6';
            previewDot.style.backgroundColor = tagColor;
            taskPreviewText.textContent = name;
            taskPreviewText.style.color = '#ffffff';
            taskPreviewBox.style.backgroundColor = tagColor;
            taskPreviewBox.style.borderColor = tagColor;
            
            // Show/hide pin icon
            const isPinned = pinnedHidden.value === 'true';
            if (isPinned) {
                previewPin.style.display = 'block';
            } else {
                previewPin.style.display = 'none';
            }
            
            const folderId = folderHidden.value;
            if (folderId) {
                const folder = folders.find(f => f.id === parseInt(folderId));
                if (folder) {
                    folderBadge.textContent = folder.name.toUpperCase();
                    folderBadge.style.display = 'inline-flex';
                    folderBadge.style.borderColor = folder.color || '#64748b';
                    folderBadge.style.color = folder.color || '#64748b';
                    folderBadge.style.background = (folder.color || '#64748b') + '20';
                } else {
                    folderBadge.style.display = 'none';
                }
            } else {
                folderBadge.style.display = 'none';
            }
        }
        

        async function handleCreateTagSubmit(event) {
            event.preventDefault();
            
            const name = document.getElementById('createTagName').value.trim();
            const color = document.getElementById('createTagColor').value;
            const folderId = document.getElementById('createTagFolderHidden').value || null;
            const pinned = document.getElementById('createTagPinnedHidden').value === 'true';
            const isEditMode = tagFormMode === 'edit' && editingTagId !== null;

            if (!name) {
                showMessage('Tag name is required', 'error');
                return;
            }
            if (name.length > 15) {
                showMessage('Tag name must be 15 characters or less', 'error');
                return;
            }

            try {
                const endpoint = isEditMode ? `${TAGS_URL}/${editingTagId}` : TAGS_URL;
                const method = isEditMode ? 'PUT' : 'POST';
                const res = await fetch(endpoint, {
                    method,
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ 
                        name, 
                        color, 
                        folderId: folderId ? parseInt(folderId) : null,
                        pinned: pinned || false
                    })
                });

                if (res.status === 401) {
                    logout();
                    return;
                }

                const data = await res.json();
                if (!res.ok) {
                    showMessage(data.message || 'Error creating tag', 'error');
                    return;
                }

                showMessage(isEditMode ? 'Tag updated' : 'Tag created', 'success');
                closeCreateTagModal();
                await loadTags();
                renderTags();
                // If tags modal is open, refresh it
                const tagsModal = document.getElementById('tagsModalOverlay');
                if (tagsModal && tagsModal.classList.contains('active')) {
                    renderTagsModal();
                }
            } catch (error) {
                console.error('Error creating tag:', error);
                showMessage('Error creating tag', 'error');
            }
        }

        function closeTagsModal() {
            const modal = document.getElementById('tagsModalOverlay');
            if (modal) {
                modal.classList.remove('active');
            }
            tagsModalBaselineHeight = null;
        }

        function closeTagsModalOnOverlay(event) {
            if (event.target.id === 'tagsModalOverlay') {
                closeTagsModal();
            }
        }

        function setTagsModalViewMode(mode, reset = false) {
            const wasMode = tagsModalViewMode;
            const isSameMode = wasMode === mode;
            const switchingMode = !isSameMode;
            tagsModalViewMode = mode;
            
            // Reset selected folder when switching to tags view
            if (mode === 'tags') {
                tagsModalSelectedFolderId = null;
            }
            if ((reset && isSameMode) || switchingMode) {
                if (mode === 'folders' && !(reset && isSameMode)) {
                    // preserve folder selection unless explicit reset
                } else {
                    tagsModalSelectedFolderId = null;
                }
                tagsModalSearchTerm = '';
                const searchInput = document.getElementById('tagsModalSearchInput');
                if (searchInput) searchInput.value = '';
            }
            
            // Update button states
            const foldersBtn = document.getElementById('tagsModalViewFoldersBtn');
            const tagsBtn = document.getElementById('tagsModalViewTagsBtn');
            if (foldersBtn) foldersBtn.classList.toggle('active', mode === 'folders');
            if (tagsBtn) tagsBtn.classList.toggle('active', mode === 'tags');
            
            // Hide new tag form when switching to folders view
            const newTagForm = document.getElementById('tagsModalNewTagForm');
            if (newTagForm) {
                if (mode === 'folders') {
                    newTagForm.style.display = 'none';
                }
            }
            
            // Re-render
            renderTagsModal();
            // Adjust position after rendering
            setTimeout(() => {
                adjustTagsModalPosition();
            }, 10);
        }

        function handleTagsModalSearch() {
            const searchInput = document.getElementById('tagsModalSearchInput');
            if (!searchInput) return;
            const previous = tagsModalSearchTerm;
            tagsModalSearchTerm = searchInput.value;
            const reset = !tagsModalSelectedFolderId && !tagsModalSearchTerm.trim();
            if (reset && previous === '') {
                renderTagsModal();
                setTimeout(() => adjustTagsModalPosition(), 10);
                return;
            }
            renderTagsModal();
            // Adjust position after rendering
            setTimeout(() => {
                adjustTagsModalPosition();
            }, 10);
        }

        function handleTagsModalViewFoldersClick() {
            const reset = tagsModalViewMode === 'folders';
            setTagsModalViewMode('folders', reset);
            if (reset) {
                setTimeout(() => {
                    const foldersColumn = document.getElementById('tagsModalFoldersColumn');
                    const tagsColumn = document.getElementById('tagsModalTagsColumn');
                    if (foldersColumn) foldersColumn.scrollTop = 0;
                    if (tagsColumn) tagsColumn.scrollTop = 0;
                }, 0);
            }
        }

        function handleTagsModalViewTagsClick() {
            const reset = tagsModalViewMode === 'tags';
            setTagsModalViewMode('tags', reset);
            if (reset) {
                setTimeout(() => {
                    const allTagsColumn = document.getElementById('tagsModalAllTagsColumn');
                    if (allTagsColumn) allTagsColumn.scrollTop = 0;
                }, 0);
            }
        }

        function toggleTagsModalSortOrder() {
            tagsModalSortOrder = tagsModalSortOrder === 'asc' ? 'desc' : 'asc';
            updateTagsModalSortButtonIcon();
            renderTagsModal();
            // Adjust position after rendering
            setTimeout(() => {
                adjustTagsModalPosition();
            }, 10);
        }

        function updateTagsModalSortButtonIcon() {
            const sortAscIcon = document.getElementById('tagsModalSortAscIcon');
            const sortDescIcon = document.getElementById('tagsModalSortDescIcon');
            if (sortAscIcon && sortDescIcon) {
                if (tagsModalSortOrder === 'asc') {
                    sortAscIcon.style.display = 'block';
                    sortDescIcon.style.display = 'none';
                } else {
                    sortAscIcon.style.display = 'none';
                    sortDescIcon.style.display = 'block';
                }
            }
        }

        function selectTagsModalFolder(folderId) {
            tagsModalSelectedFolderId = folderId === 'none' ? 'none' : folderId;
            renderTagsModal();
            // Adjust position after rendering
            setTimeout(() => {
                adjustTagsModalPosition();
            }, 10);
        }
        
        function navigateToTagsModalFolder(folderId) {
            // Change to folders view mode
            tagsModalViewMode = 'folders';
            const foldersBtn = document.getElementById('tagsModalViewFoldersBtn');
            const tagsBtn = document.getElementById('tagsModalViewTagsBtn');
            if (foldersBtn) foldersBtn.classList.add('active');
            if (tagsBtn) tagsBtn.classList.remove('active');
            
            // Select the folder
            selectTagsModalFolder(folderId);
            
            // Scroll to make the folder visible in the left column
            setTimeout(() => {
                const foldersColumn = document.getElementById('tagsModalFoldersColumn');
                const folderElement = foldersColumn ? foldersColumn.querySelector(`[data-folder-id="${folderId === 'none' ? 'none' : folderId}"]`) : null;
                
                if (folderElement && foldersColumn) {
                    // Calculate the position of the folder relative to the scrollable container
                    // We need to account for all parent elements up to the foldersColumn
                    let totalOffsetTop = 0;
                    let currentElement = folderElement;
                    
                    // Traverse up to calculate the total offset from the top of foldersColumn
                    while (currentElement && currentElement !== foldersColumn) {
                        totalOffsetTop += currentElement.offsetTop;
                        currentElement = currentElement.offsetParent;
                        
                        // If we've gone outside the foldersColumn, we need to stop
                        if (currentElement && !foldersColumn.contains(currentElement)) {
                            // We've reached a parent outside foldersColumn, so we need to subtract
                            // the offset of foldersColumn itself
                            const foldersColumnOffset = foldersColumn.offsetTop;
                            totalOffsetTop = totalOffsetTop - foldersColumnOffset;
                            break;
                        }
                    }
                    
                    // Alternative simpler approach: use getBoundingClientRect
                    const folderRect = folderElement.getBoundingClientRect();
                    const columnRect = foldersColumn.getBoundingClientRect();
                    
                    // Calculate how much we need to scroll
                    // The difference between where the folder is and where we want it (top of visible area)
                    const currentScrollTop = foldersColumn.scrollTop;
                    const folderTopInColumn = folderRect.top - columnRect.top + currentScrollTop;
                    
                    // Scroll to position the folder at the very top of the visible area
                    foldersColumn.scrollTop = Math.max(0, folderTopInColumn);
                }
            }, 100);
        }

        function renderTagsModal() {
            // Render in tags modal
            const foldersColumn = document.getElementById('tagsModalFoldersColumn');
            const tagsColumn = document.getElementById('tagsModalTagsColumn');
            const allTagsColumn = document.getElementById('tagsModalAllTagsColumn');
            
            if (!foldersColumn || !tagsColumn || !allTagsColumn) {
                return;
            }
            
            // Update sort button icon
            updateTagsModalSortButtonIcon();
            
            if (tagsModalViewMode === 'tags') {
                // Show all tags in a flat list
                foldersColumn.style.display = 'none';
                tagsColumn.style.display = 'none';
                allTagsColumn.style.display = 'flex';
                
                if (tags.length === 0) {
                    allTagsColumn.innerHTML = '<div style="color: #94a3b8; font-size: 13px; padding: 12px; text-align: center;">No tags yet. Create your first tag in the profile!</div>';
                    return;
                }

                let html = '';
                // Filter and sort tags alphabetically
                let filteredTags = tags;
                if (tagsModalSearchTerm.trim()) {
                    const searchLower = tagsModalSearchTerm.toLowerCase().trim();
                    filteredTags = tags.filter(tag => tag.name.toLowerCase().includes(searchLower));
                }
                const sortedTags = [...filteredTags].sort((a, b) => {
                    // First, sort by pinned status (pinned items first)
                    const aPinned = a.pinned ? 1 : 0;
                    const bPinned = b.pinned ? 1 : 0;
                    if (aPinned !== bPinned) {
                        return bPinned - aPinned;
                    }
                    // Then sort by name
                    const comparison = a.name.localeCompare(b.name);
                    return tagsModalSortOrder === 'asc' ? comparison : -comparison;
                });
                
                if (sortedTags.length === 0) {
                    allTagsColumn.innerHTML = '<div style="color: #94a3b8; font-size: 13px; padding: 12px; text-align: center;">No tags found</div>';
                    return;
                }
                
                sortedTags.forEach((tag, index) => {
                    const folder = folders.find(f => f.id === tag.folderId);
                    const isLast = index === sortedTags.length - 1;
                    const isSelected = selectedTagsForTask.includes(tag.id);
                    const selectedStyle = isSelected ? 'background: #dbeafe; border: 1px solid #3b82f6;' : 'background: #ffffff;';
                    html += `
                        <div class="tag-item" data-tag-id="${tag.id}" onclick="toggleTagSelection(${tag.id})" style="display: flex; align-items: center; gap: 8px; padding: 6px; ${selectedStyle} border-radius: 4px; margin-bottom: ${isLast ? '0' : '4px'}; transition: background 0.2s ease; cursor: pointer; position: relative;">
                            ${renderTagNameWithPin(tag, {fontSize: '13px', indicatorSize: 10})}
                            ${folder ? `<span onclick="navigateToTagsModalFolder(${folder.id}); event.stopPropagation();" style="font-size: 11px; color: ${folder.color || '#64748b'}; padding: 2px 6px; background: ${folder.color || '#64748b'}20; border-radius: 3px; border: 1px solid ${folder.color || '#64748b'}; cursor: pointer; transition: all 0.2s ease;" onmouseover="this.style.color='${folder.color || '#64748b'}'; this.style.borderColor='${folder.color || '#64748b'}'; this.style.filter='brightness(1.2) saturate(1.3)'" onmouseout="this.style.color='${folder.color || '#64748b'}'; this.style.borderColor='${folder.color || '#64748b'}'; this.style.filter='none'">${escapeHtml(folder.name.toUpperCase())}</span>` : ''}
                        </div>
                    `;
                });
                allTagsColumn.innerHTML = html;
                // Adjust modal height after rendering
                setTimeout(() => {
                    adjustTagsModalPosition();
                }, 10);
                return;
            }
            
            // View mode: folders
            foldersColumn.style.display = 'flex';
            tagsColumn.style.display = 'flex';
            allTagsColumn.style.display = 'none';
            
            if (tags.length === 0 && folders.length === 0) {
                foldersColumn.innerHTML = '';
                tagsColumn.innerHTML = '<div style="color: #94a3b8; font-size: 13px; padding: 12px; text-align: center;">No tags or folders yet. Create your first folder or tag in the profile!</div>';
                return;
            }

            // Render folders in left column
            const tagsWithoutFolder = tags.filter(tag => !tag.folderId);
            if (tagsWithoutFolder.length === 0 && tagsModalSelectedFolderId === 'none') {
                tagsModalSelectedFolderId = null;
            }
            const allFoldersForSorting = [...folders];
            
            if (tagsWithoutFolder.length > 0) {
                allFoldersForSorting.push({
                    id: 'none',
                    name: 'TAGS WITHOUT FOLDER',
                    color: '#000000',
                    userId: null
                });
            }
            
            const sortedFolders = allFoldersForSorting.sort((a, b) => {
                // First, sort by pinned status (pinned items first)
                const aPinned = (a.pinned ? 1 : 0);
                const bPinned = (b.pinned ? 1 : 0);
                if (aPinned !== bPinned) {
                    return bPinned - aPinned;
                }
                
                const aTagsCount = a.id === 'none' 
                    ? tagsWithoutFolder.length 
                    : tags.filter(tag => tag.folderId === a.id).length;
                const bTagsCount = b.id === 'none' 
                    ? tagsWithoutFolder.length 
                    : tags.filter(tag => tag.folderId === b.id).length;
                
                if (aTagsCount !== bTagsCount) {
                    return bTagsCount - aTagsCount;
                }
                
                return a.name.localeCompare(b.name);
            });
            
            let foldersHtml = '';
            sortedFolders.forEach(folder => {
                const isNoneFolder = folder.id === 'none';
                const folderTags = isNoneFolder 
                    ? tagsWithoutFolder 
                    : tags.filter(tag => tag.folderId === folder.id).sort((a, b) => a.name.localeCompare(b.name));
                const folderColor = folder.color || '#64748b';
                const isSelected = isNoneFolder ? tagsModalSelectedFolderId === 'none' : tagsModalSelectedFolderId === folder.id;
                
                foldersHtml += `
                    <div class="folder-item" data-folder-id="${folder.id}" onclick="selectTagsModalFolder(${isNoneFolder ? "'none'" : folder.id})" style="
                        padding: 10px 12px;
                        background: ${isSelected ? folderColor + '25' : folderColor + '15'};
                        border-radius: 6px;
                        border-left: 3px solid ${folderColor};
                        border-right: 1px solid ${isSelected ? folderColor : '#e2e8f0'};
                        border-top: 1px solid ${isSelected ? folderColor : '#e2e8f0'};
                        border-bottom: 1px solid ${isSelected ? folderColor : '#e2e8f0'};
                        cursor: pointer;
                        transition: all 0.2s ease;
                        width: 100%;
                        box-sizing: border-box;
                        min-height: 60px;
                        display: flex;
                        flex-direction: column;
                        justify-content: center;
                        position: relative;
                    ">
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <div style="font-weight: 600; color: ${folderColor}; font-size: 13px; margin-bottom: 3px; word-wrap: break-word; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; line-height: 1.3; flex: 1;">${escapeHtml(folder.name.toUpperCase())}</div>
                            ${folder.pinned ? `<svg style="width: 12px; height: 12px; flex-shrink: 0; color: ${folderColor};" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M17 12l4.5-2.5-7-7-2.5 4.5L3.5 10.5l10 10Z"></path>
                                <path d="m1.5 22.5 7-7"></path>
                            </svg>` : ''}
                        </div>
                        <div style="font-size: 10px; color: #64748b; font-weight: 500;">${folderTags.length} ${folderTags.length === 1 ? 'tag' : 'tags'}</div>
                    </div>
                `;
            });
            
            foldersColumn.innerHTML = foldersHtml;
            
            // Render tags in right column based on selection
            let tagsHtml = '';
            if (!tagsModalSelectedFolderId) {
                tagsColumn.innerHTML = '<div style="color: #94a3b8; font-size: 13px; padding: 12px; text-align: center;">Select a folder to view its tags</div>';
            } else if (tagsModalSelectedFolderId === 'none') {
                let filteredTagsWithoutFolder = tagsWithoutFolder;
                if (tagsModalSearchTerm.trim()) {
                    const searchLower = tagsModalSearchTerm.toLowerCase().trim();
                    filteredTagsWithoutFolder = tagsWithoutFolder.filter(tag => tag.name.toLowerCase().includes(searchLower));
                }
                
                if (filteredTagsWithoutFolder.length === 0) {
                    tagsColumn.innerHTML = '<div style="color: #94a3b8; font-size: 13px; padding: 12px; text-align: center;">' + (tagsModalSearchTerm.trim() ? 'No tags found' : 'NO TAGS WITHOUT FOLDER') + '</div>';
                } else {
                    const sortedTagsWithoutFolder = [...filteredTagsWithoutFolder].sort((a, b) => {
                        // First, sort by pinned status (pinned items first)
                        const aPinned = a.pinned ? 1 : 0;
                        const bPinned = b.pinned ? 1 : 0;
                        if (aPinned !== bPinned) {
                            return bPinned - aPinned;
                        }
                        // Then sort by name
                        const comparison = a.name.localeCompare(b.name);
                        return tagsModalSortOrder === 'asc' ? comparison : -comparison;
                    });
                    
                    sortedTagsWithoutFolder.forEach((tag, index) => {
                        const isLast = index === sortedTagsWithoutFolder.length - 1;
                        const isSelected = selectedTagsForTask.includes(tag.id);
                        const selectedStyle = isSelected ? 'background: #dbeafe; border: 1px solid #3b82f6;' : 'background: #ffffff;';
                        tagsHtml += `
                            <div class="tag-item" data-tag-id="${tag.id}" onclick="toggleTagSelection(${tag.id})" style="display: flex; align-items: center; gap: 8px; padding: 6px; ${selectedStyle} border-radius: 4px; margin-bottom: ${isLast ? '0' : '4px'}; transition: background 0.2s ease; cursor: pointer; position: relative;">
                                ${renderTagNameWithPin(tag, {fontSize: '13px', indicatorSize: 10})}
                            </div>
                        `;
                    });
                    tagsColumn.innerHTML = tagsHtml;
                }
            } else {
                const selectedFolder = folders.find(f => f.id === tagsModalSelectedFolderId);
                if (selectedFolder) {
                    let folderTags = tags.filter(tag => tag.folderId === tagsModalSelectedFolderId);
                    if (tagsModalSearchTerm.trim()) {
                        const searchLower = tagsModalSearchTerm.toLowerCase().trim();
                        folderTags = folderTags.filter(tag => tag.name.toLowerCase().includes(searchLower));
                    }
                    
                    if (folderTags.length === 0) {
                        tagsColumn.innerHTML = '<div style="color: #94a3b8; font-size: 13px; padding: 12px; text-align: center;">' + (tagsModalSearchTerm.trim() ? 'No tags found' : 'This folder is empty') + '</div>';
                    } else {
                        const sortedFolderTags = [...folderTags].sort((a, b) => {
                            // First, sort by pinned status (pinned items first)
                            const aPinned = a.pinned ? 1 : 0;
                            const bPinned = b.pinned ? 1 : 0;
                            if (aPinned !== bPinned) {
                                return bPinned - aPinned;
                            }
                            // Then sort by name
                            const comparison = a.name.localeCompare(b.name);
                            return tagsModalSortOrder === 'asc' ? comparison : -comparison;
                        });
                        
                        sortedFolderTags.forEach((tag, index) => {
                            const isLast = index === sortedFolderTags.length - 1;
                            const isSelected = selectedTagsForTask.includes(tag.id);
                            const selectedStyle = isSelected ? 'background: #dbeafe; border: 1px solid #3b82f6;' : 'background: #ffffff;';
                            tagsHtml += `
                                <div class="tag-item" data-tag-id="${tag.id}" onclick="toggleTagSelection(${tag.id})" style="display: flex; align-items: center; gap: 8px; padding: 6px; ${selectedStyle} border-radius: 4px; margin-bottom: ${isLast ? '0' : '4px'}; transition: background 0.2s ease; cursor: pointer; position: relative;">
                                    ${renderTagNameWithPin(tag, {fontSize: '13px', indicatorSize: 10})}
                                </div>
                            `;
                        });
                        tagsColumn.innerHTML = tagsHtml;
                    }
                }
            }
            
            // Update folder select in new tag form
            updateTagsModalFolderSelect();
            
            // Adjust modal height after rendering
            setTimeout(() => {
                adjustTagsModalPosition();
            }, 10);
        }
        
        function adjustTagsModalPosition() {
            const modal = document.getElementById('tagsModalOverlay');
            const modalContent = modal ? modal.querySelector('.task-modal') : null;
            
            if (!modal || !modalContent || !modal.classList.contains('active')) {
                return;
            }
            
            // Position relative to task creation modal
            const modalWidth = 450;
            const createTagModalHeight = 242.406;
            const margin = 16; // Same as lateral margin between taskModal and tagsModal
            let targetX = 600;
            let targetY = 80;
            let calculatedHeight = 500; // Default fallback
            
            const taskModal = document.getElementById('taskModalOverlay');
            if (taskModal && taskModal.classList.contains('active')) {
                const taskModalContent = taskModal.querySelector('.task-modal');
                if (taskModalContent) {
                    const taskModalRect = taskModalContent.getBoundingClientRect();
                    // Position to the right of the task modal with 16px gap
                    targetX = taskModalRect.right + margin;
                    
                    // Calculate height to maintain 16px margin with createTagModal
                    // createTagModal top = taskModalRect.top
                    // createTagModal bottom = taskModalRect.top + createTagModalHeight
                    // tagsModal top = createTagModal bottom + margin = taskModalRect.top + createTagModalHeight + margin
                    // tagsModal bottom = taskModalRect.bottom (aligned with task modal bottom)
                    // tagsModal height = taskModalRect.bottom - (taskModalRect.top + createTagModalHeight + margin)
                    const taskModalHeight = taskModalRect.bottom - taskModalRect.top;
                    calculatedHeight = taskModalHeight - createTagModalHeight - margin;
                    
                    // Position tagsModal so it starts after createTagModal with margin
                    targetY = taskModalRect.top + createTagModalHeight + margin;
                }
            }
            
            // Ensure calculated height is reasonable (minimum 300px)
            const fixedHeight = Math.max(300, calculatedHeight);
            modalContent.style.height = fixedHeight + 'px';
            modalContent.style.maxHeight = fixedHeight + 'px';
            
            // Update the tags list container height to maintain margins
            // Use a small delay to ensure DOM is fully rendered
            setTimeout(() => {
                const tagsList = document.getElementById('tagsModalTagsList');
                const foldersColumn = document.getElementById('tagsModalFoldersColumn');
                const tagsColumn = document.getElementById('tagsModalTagsColumn');
                const allTagsColumn = document.getElementById('tagsModalAllTagsColumn');
                
                if (!tagsList) return;
                
                // Calculate available height for tags list using getBoundingClientRect for accuracy
                const header = modalContent.querySelector('.task-modal-header');
                const content = modalContent.querySelector('.task-modal-content');
                const controlsBar = content ? content.querySelector('div[style*="display: flex"]') : null;
                
                if (header && content && controlsBar) {
                    const modalRect = modalContent.getBoundingClientRect();
                    const headerRect = header.getBoundingClientRect();
                    const controlsRect = controlsBar.getBoundingClientRect();
                    
                    // Calculate available height: from bottom of controls bar to bottom of modal content
                    // Account for content padding (16px bottom) and controls margin-bottom (10px)
                    const contentBottom = content.getBoundingClientRect().bottom;
                    const controlsBottom = controlsRect.bottom;
                    const marginBottom = 10; // margin-bottom of controls bar
                    const contentPaddingBottom = 16; // padding-bottom of content
                    
                const availableHeight = contentBottom - controlsBottom - marginBottom - contentPaddingBottom;
                
                if (availableHeight > 100) {
                    if (tagsModalBaselineHeight === null) {
                        tagsModalBaselineHeight = availableHeight;
                    } else if (availableHeight < tagsModalBaselineHeight) {
                        tagsModalBaselineHeight = availableHeight;
                    }
                    const effectiveHeight = Math.min(availableHeight, tagsModalBaselineHeight);
                    
                    tagsList.style.height = effectiveHeight + 'px';
                    tagsList.style.maxHeight = effectiveHeight + 'px';
                        
                        // Add extra padding-bottom to folders and tags columns to match allTagsColumn margin
                        const extraPaddingBottom = 16; // Additional padding to match allTagsColumn bottom margin
                        
                        if (foldersColumn) {
                        foldersColumn.style.height = effectiveHeight + 'px';
                        foldersColumn.style.maxHeight = effectiveHeight + 'px';
                            // Add padding-bottom to match the margin of allTagsColumn
                            // Keep existing padding-right: 6px, add padding-bottom
                            foldersColumn.style.paddingRight = '6px';
                            foldersColumn.style.paddingBottom = extraPaddingBottom + 'px';
                        }
                        if (tagsColumn) {
                        tagsColumn.style.height = effectiveHeight + 'px';
                        tagsColumn.style.maxHeight = effectiveHeight + 'px';
                            // Update padding to include extra bottom padding (10px all sides + 16px extra bottom)
                            tagsColumn.style.padding = '10px 10px ' + (10 + extraPaddingBottom) + 'px 10px';
                        }
                        if (allTagsColumn) {
                        allTagsColumn.style.height = effectiveHeight + 'px';
                        allTagsColumn.style.maxHeight = effectiveHeight + 'px';
                            // Keep original padding for allTagsColumn (10px all sides)
                            allTagsColumn.style.padding = '10px';
                        }
                    }
                }
            }, 10);
            
            // Ensure modal doesn't go off screen
            const maxX = window.innerWidth - modalWidth - 20;
            const maxY = window.innerHeight - fixedHeight - 20;
            
            const finalX = Math.min(targetX, maxX);
            const finalY = Math.min(targetY, maxY);
            
            modalContent.style.left = Math.max(finalX, 20) + 'px';
            modalContent.style.top = Math.max(finalY, 20) + 'px';
        }

        async function deleteFolder(folderId) {
            if (folderId === 'none') {
                showMessage('This folder cannot be deleted', 'error');
                return;
            }
            try {
                const res = await fetch(`${FOLDERS_URL}/${folderId}`, {
                    method: 'DELETE',
                    headers: getAuthHeaders()
                });

                if (res.status === 401) {
                    logout();
                    return;
                }

                if (!res.ok) throw new Error();
                showMessage('Folder deleted', 'success');
                await loadFolders();
                await loadTags();
            } catch (error) {
                showMessage('Error deleting folder', 'error');
            }
        }

        async function deleteTag(tagId) {
            try {
                const res = await fetch(`${TAGS_URL}/${tagId}`, {
                    method: 'DELETE',
                    headers: getAuthHeaders()
                });

                if (res.status === 401) {
                    logout();
                    return;
                }

                if (!res.ok) throw new Error();
                showMessage('Tag deleted', 'success');
                await loadTags();
                await loadTasks();
            } catch (error) {
                showMessage('Error deleting tag', 'error');
            }
        }

        async function loadTasks() {
            try {
                const res = await fetch(API_URL, {
                    headers: getAuthHeaders()
                });
                
                if (res.status === 401) {
                    logout();
                    showMessage('Session expired. Please login again.', 'error');
                    return;
                }
                
                tasks = await res.json();
                renderTasks();
                updateTagSelect(); // Update tag select to show recently used tags
            } catch (error) {
                showMessage('Error loading tasks', 'error');
            }
        }

        function formatDate(dateStr) {
            if (!dateStr) return '';
            const date = new Date(dateStr + 'T00:00:00');
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = date.getFullYear();
            return `${day}/${month}/${year}`;
        }

        function setFilter(filter) {
            currentFilter = filter;
            
            // Update button states
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`filter${filter.charAt(0).toUpperCase() + filter.slice(1)}`).classList.add('active');
            
            // Update title
            const title = document.getElementById('tasksTitle');
            if (filter === 'pending') {
                title.textContent = 'Pending Tasks';
            } else if (filter === 'completed') {
                title.textContent = 'Completed Tasks';
            } else {
                title.textContent = 'All Tasks';
            }
            
            renderTasks();
        }

        function handleSearch() {
            const searchInput = document.getElementById('taskSearch');
            searchQuery = searchInput.value.trim().toLowerCase();
            renderTasks();
        }

        function renderTasks() {
            const list = document.getElementById('taskList');
            let filteredTasks = [];
            
            if (currentFilter === 'pending') {
                filteredTasks = tasks.filter(task => !task.completed);
            } else if (currentFilter === 'completed') {
                filteredTasks = tasks.filter(task => task.completed);
            } else {
                filteredTasks = tasks;
            }
            
            if (filteredTasks.length === 0) {
                let message = '';
                if (searchQuery) {
                    message = 'No tasks found matching your search';
                } else if (currentFilter === 'pending') {
                    message = 'No pending tasks';
                } else if (currentFilter === 'completed') {
                    message = 'No completed tasks';
                } else {
                    message = 'No tasks';
                }
                list.innerHTML = `<div class="empty">${message}</div>`;
                return;
            }

            // Apply search filter if there's a search query
            if (searchQuery) {
                filteredTasks = filteredTasks.filter(task => {
                    const titleMatch = task.title && task.title.toLowerCase().includes(searchQuery);
                    const descMatch = task.description && task.description.toLowerCase().includes(searchQuery);
                    return titleMatch || descMatch;
                });
            }

            // Sort all tasks by date (closest to today first, regardless of past/future)
            filteredTasks.sort((a, b) => {
                // Tasks without dates go to the end
                if (!a.dueDate && !b.dueDate) return 0;
                if (!a.dueDate) return 1;
                if (!b.dueDate) return -1;

                const dateA = new Date(a.dueDate + (a.dueTime ? 'T' + a.dueTime : 'T00:00:00'));
                const dateB = new Date(b.dueDate + (b.dueTime ? 'T' + b.dueTime : 'T00:00:00'));
                
                return dateA - dateB; // Ascending: closest to today first
            });

            // Build HTML with all tasks sorted by date
            let html = '';
            
            if (filteredTasks.length > 0) {
                html += filteredTasks.map(task => `
                <div class="task-item ${task.completed ? 'completed' : ''}" data-id="${task.id}">
                    <div class="task-header">
                        <input type="checkbox" ${task.completed ? 'checked' : ''} 
                               onchange="toggleTask(${task.id}, this.checked)">
                        <div class="task-title">${escapeHtml(task.title)}</div>
                    </div>
                    ${task.description ? `<div class="task-info">${escapeHtml(task.description)}</div>` : ''}
                    ${task.tags && task.tags.length > 0 ? `<div style="margin-top: 5px; display: flex; flex-wrap: wrap; gap: 5px;">${task.tags.map(tag => `<span class="tag" style="background-color: ${tag.color || '#007bff'}">${escapeHtml(tag.name)}</span>`).join('')}</div>` : ''}
                    ${task.image ? `<div style="margin-top: 10px;"><img src="${escapeHtml(getProtectedImageUrl(task.image))}" alt="Task image" class="task-image" onclick="window.open('${escapeHtml(getProtectedImageUrl(task.image))}', '_blank')"></div>` : ''}
                    ${task.dueDate || task.dueTime ? `
                        <div class="task-date-time">
                            ${task.dueDate ? `📅 ${formatDate(task.dueDate)}` : ''}
                            ${task.dueTime ? `🕐 ${task.dueTime}` : ''}
                        </div>
                    ` : ''}
                    <div class="edit-form" id="editForm-${task.id}">
                        <input type="text" id="editTitle-${task.id}" value="${escapeHtml(task.title)}" style="margin-bottom: 10px; width: 100%;">
                        <textarea id="editDesc-${task.id}" style="margin-bottom: 10px; width: 100%;">${escapeHtml(task.description || '')}</textarea>
                        <div class="date-time-row">
                            <input type="date" id="editDate-${task.id}" value="${task.dueDate || ''}">
                            <input type="time" id="editTime-${task.id}" value="${task.dueTime || ''}">
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label style="font-size: 12px; display: block; margin-bottom: 5px;">Tags</label>
                            <div id="editTags-${task.id}" class="tag-select-row" style="max-height: 150px; overflow-y: auto;">
                                <!-- Tags will be populated when editing -->
                            </div>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label style="font-size: 12px; display: block; margin-bottom: 5px;">Image</label>
                            <div class="image-upload-area" onclick="document.getElementById('editImage-${task.id}').click()">
                                <input type="file" id="editImage-${task.id}" accept="image/*" onchange="previewEditImage(${task.id})">
                                <div id="editImagePreviewText-${task.id}">${task.image ? 'Click to change or drag & drop image' : 'Click to select or drag & drop image'}</div>
                                <img class="image-preview" id="editImagePreview-${task.id}" ${task.image ? `src="${escapeHtml(getProtectedImageUrl(task.image))}"` : 'style="display: none;"'}>
                                <button type="button" class="remove-image-btn" id="removeEditImageBtn-${task.id}" ${task.image ? '' : 'style="display: none;"'} onclick="event.stopPropagation(); removeEditImage(${task.id})">Remove</button>
                            </div>
                            <small style="color: #666; font-size: 11px; display: block; margin-top: 5px;">Formats allowed: JPEG, JPG, PNG, GIF, WEBP (max 5MB)</small>
                        </div>
                        <div class="task-actions">
                            <button class="btn-small" onclick="saveEdit(${task.id})">Save</button>
                            <button class="btn-small" onclick="cancelEdit(${task.id})">Cancel</button>
                        </div>
                    </div>
                    <div class="task-actions">
                        <button class="btn-small btn-edit" onclick="editTask(${task.id})">Edit</button>
                        <button class="btn-small btn-delete" onclick="deleteTask(${task.id})">Delete</button>
                    </div>
                </div>
            `).join('');
            }

            list.innerHTML = html;

            // Scroll to top to show future tasks (closest to today)
            list.scrollTop = 0;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Convert old image paths to protected paths and add auth token
        function getProtectedImageUrl(imagePath) {
            if (!imagePath) return '';
            let protectedPath = imagePath;
            // Convert /uploads/filename to /api/uploads/filename
            if (imagePath.startsWith('/uploads/')) {
                protectedPath = imagePath.replace('/uploads/', '/api/uploads/');
            }
            // Add token as query parameter for authentication
            if (protectedPath.startsWith('/api/uploads/') && token) {
                const separator = protectedPath.includes('?') ? '&' : '?';
                return `${protectedPath}${separator}token=${encodeURIComponent(token)}`;
            }
            // Already in protected format or absolute URL
            return protectedPath;
        }

        // Function to validate image format
        // Store uploaded files
        let uploadedFiles = [];

        function isValidImageFormat(file) {
            const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
            const allowedExtensions = ['.jpeg', '.jpg', '.png', '.gif', '.webp'];
            
            const fileType = file.type.toLowerCase();
            const isValidMimeType = allowedTypes.includes(fileType) || fileType === 'image/jpg';
            
            const fileName = file.name.toLowerCase();
            const hasValidExtension = allowedExtensions.some(ext => fileName.endsWith(ext));
            
            return isValidMimeType || hasValidExtension;
        }

        function isValidPdfFormat(file) {
            const allowedTypes = ['application/pdf'];
            const allowedExtensions = ['.pdf'];
            
            const fileType = file.type.toLowerCase();
            const isValidMimeType = allowedTypes.includes(fileType);
            
            const fileName = file.name.toLowerCase();
            const hasValidExtension = allowedExtensions.some(ext => fileName.endsWith(ext));
            
            return isValidMimeType || hasValidExtension;
        }

        function isValidFileFormat(file) {
            return isValidImageFormat(file) || isValidPdfFormat(file);
        }

        function getCurrentFilesCount() {
            const images = uploadedFiles.filter(f => isValidImageFormat(f.file)).length;
            const pdfs = uploadedFiles.filter(f => isValidPdfFormat(f.file)).length;
            return { images, pdfs, total: uploadedFiles.length };
        }

        function renderFilePreview(fileData) {
            const { file, id } = fileData;
            const isImage = isValidImageFormat(file);
            const isPdf = isValidPdfFormat(file);
            
            const previewItem = document.createElement('div');
            previewItem.className = `file-preview-item ${isImage ? 'image-preview' : 'pdf-preview'}`;
            previewItem.dataset.fileId = id;
            
            if (isImage) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = document.createElement('img');
                    img.className = 'file-preview-image';
                    img.src = e.target.result;
                    previewItem.appendChild(img);
                    
                    // Sincronizar altura con el área de carga
                    const uploadArea = document.getElementById('imageUploadArea');
                    setTimeout(() => {
                        const uploadAreaHeight = uploadArea.offsetHeight;
                        if (uploadAreaHeight > 0) {
                            previewItem.style.height = uploadAreaHeight + 'px';
                        }
                    }, 10);
                };
                reader.readAsDataURL(file);
            } else if (isPdf) {
                // Recuadro rojo con "PDF" en blanco
                const pdfBox = document.createElement('div');
                pdfBox.className = 'file-preview-pdf-box';
                const pdfBoxText = document.createElement('div');
                pdfBoxText.className = 'file-preview-pdf-box-text';
                pdfBoxText.textContent = 'PDF';
                pdfBox.appendChild(pdfBoxText);
                
                // Título del PDF
                const pdfTitle = document.createElement('div');
                pdfTitle.className = 'file-preview-pdf-title';
                pdfTitle.textContent = file.name.replace('.pdf', '').replace('.PDF', '');
                
                previewItem.appendChild(pdfBox);
                previewItem.appendChild(pdfTitle);
                
                // Sincronizar altura con el área de carga y detectar si el título tiene una línea
                const uploadArea = document.getElementById('imageUploadArea');
                setTimeout(() => {
                    const uploadAreaHeight = uploadArea.offsetHeight;
                    if (uploadAreaHeight > 0) {
                        previewItem.style.height = uploadAreaHeight + 'px';
                    }
                    
                    // Detectar si el título tiene solo una línea
                    const titleHeight = pdfTitle.scrollHeight;
                    const lineHeight = parseFloat(getComputedStyle(pdfTitle).lineHeight);
                    if (titleHeight <= lineHeight * 1.5) {
                        pdfTitle.classList.add('single-line');
                    }
                }, 50);
            }
            
            // Botón de eliminar
            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'file-remove-btn';
            removeBtn.onclick = (e) => {
                e.stopPropagation();
                removeFile(id);
            };
            removeBtn.setAttribute('aria-label', 'Remove file');
            removeBtn.innerHTML = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>';
            previewItem.appendChild(removeBtn);
            
            return previewItem;
        }

        function renderAllFilePreviews() {
            const filesList = document.getElementById('filesPreviewList');
            const uploadArea = document.getElementById('imageUploadArea');
            const container = document.querySelector('.files-upload-container');
            
            filesList.innerHTML = '';
            
            uploadedFiles.forEach(fileData => {
                const previewItem = renderFilePreview(fileData);
                filesList.appendChild(previewItem);
            });
            
            // Actualizar estado del área de carga
            const isMaxFiles = uploadedFiles.length >= 4;
            
            if (uploadedFiles.length > 0) {
                uploadArea.classList.add('has-files');
                container.classList.remove('no-files');
                const previewText = document.getElementById('imagePreviewText');
                previewText.textContent = 'Add more files';
            } else {
                uploadArea.classList.remove('has-files');
                container.classList.add('no-files');
                const previewText = document.getElementById('imagePreviewText');
                previewText.textContent = 'Click to select or drag & drop images/PDF';
            }
            
            // Deshabilitar cuando se alcanza el máximo
            if (isMaxFiles) {
                uploadArea.classList.add('disabled');
                uploadArea.style.pointerEvents = 'none';
                uploadArea.style.cursor = 'default';
                uploadArea.style.opacity = '0.5';
                uploadArea.onclick = null;
                uploadArea.removeAttribute('onclick');
            } else {
                uploadArea.classList.remove('disabled');
                uploadArea.style.pointerEvents = 'auto';
                uploadArea.style.cursor = 'pointer';
                uploadArea.style.opacity = '1';
                uploadArea.onclick = function() {
                    document.getElementById('taskFiles').click();
                };
            }
            
            // Sincronizar alturas de imágenes y PDFs
            const syncFileHeights = () => {
                const uploadAreaHeight = uploadArea.offsetHeight;
                if (uploadAreaHeight > 0) {
                    document.querySelectorAll('.file-preview-item.image-preview, .file-preview-item.pdf-preview').forEach(item => {
                        item.style.height = uploadAreaHeight + 'px';
                    });
                }
            };
            
            setTimeout(syncFileHeights, 10);
            setTimeout(syncFileHeights, 100);
            
            // Usar ResizeObserver para mantener las alturas sincronizadas
            if (window.filesResizeObserver) {
                window.filesResizeObserver.disconnect();
            }
            window.filesResizeObserver = new ResizeObserver(() => {
                syncFileHeights();
            });
            window.filesResizeObserver.observe(uploadArea);
        }

        function addFile(file) {
            const counts = getCurrentFilesCount();
            
            // Validar formato
            if (!isValidFileFormat(file)) {
                const fileExtension = file.name.substring(file.name.lastIndexOf('.')).toUpperCase() || 'unknown';
                showMessage(`This file format is not accepted (${fileExtension})`, 'error');
                return false;
            }
            
            // Validar límites
            if (isValidImageFormat(file)) {
                if (counts.images >= 3) {
                    showMessage('Maximum 3 images allowed', 'error');
                    return false;
                }
            } else if (isValidPdfFormat(file)) {
                if (counts.pdfs >= 1) {
                    showMessage('Maximum 1 PDF allowed', 'error');
                    return false;
                }
            }
            
            // Validar tamaño (10MB para imágenes, 20MB para PDFs)
            const maxSize = isValidImageFormat(file) ? 10 * 1024 * 1024 : 20 * 1024 * 1024;
            if (file.size > maxSize) {
                const maxSizeMB = maxSize / (1024 * 1024);
                showMessage(`File size exceeds maximum allowed size (${maxSizeMB}MB)`, 'error');
                return false;
            }
            
            // Añadir archivo
            const id = Date.now() + Math.random();
            uploadedFiles.push({ file, id });
            renderAllFilePreviews();
            return true;
        }

        function removeFile(fileId) {
            uploadedFiles = uploadedFiles.filter(f => f.id !== fileId);
            renderAllFilePreviews();
            updateFileInput();
        }

        function updateFileInput() {
            const fileInput = document.getElementById('taskFiles');
            const dataTransfer = new DataTransfer();
            uploadedFiles.forEach(fileData => {
                dataTransfer.items.add(fileData.file);
            });
            fileInput.files = dataTransfer.files;
        }

        // File handling - File input
        document.getElementById('taskFiles').addEventListener('change', function(e) {
            const files = Array.from(e.target.files);
            files.forEach(file => {
                addFile(file);
            });
            updateFileInput();
        });

        // Drag and drop for task files
        const taskImageArea = document.querySelector('.image-upload-area');
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            taskImageArea.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            taskImageArea.addEventListener(eventName, function(e) {
                if (uploadedFiles.length >= 4) {
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }
                this.classList.add('drag-over');
            }, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            taskImageArea.addEventListener(eventName, function() {
                this.classList.remove('drag-over');
            }, false);
        });

        taskImageArea.addEventListener('drop', function(e) {
            if (uploadedFiles.length >= 4) {
                e.preventDefault();
                e.stopPropagation();
                return;
            }
            const dt = e.dataTransfer;
            const files = Array.from(dt.files);
            let added = false;
            files.forEach(file => {
                if (addFile(file)) {
                    added = true;
                }
            });
            if (added) {
                updateFileInput();
            }
        }, false);

        function handleImageFile(file, previewId, textId, removeBtnId) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const previewWrapper = document.getElementById('imagePreviewWrapper');
                const previewImg = document.getElementById(previewId);
                const uploadArea = document.getElementById('imageUploadArea');
                const previewText = document.getElementById(textId);
                
                previewImg.src = e.target.result;
                previewWrapper.style.display = 'block';
                uploadArea.classList.add('has-image');
                previewText.textContent = 'Click to change or drag & drop image';
                
                // Función para sincronizar alturas
                const syncHeights = () => {
                    const uploadAreaHeight = uploadArea.offsetHeight;
                    if (uploadAreaHeight > 0) {
                        previewWrapper.style.height = uploadAreaHeight + 'px';
                    }
                };
                
                // Sincronizar inmediatamente y después de un pequeño delay
                setTimeout(syncHeights, 10);
                setTimeout(syncHeights, 100);
                
                // Usar ResizeObserver para mantener las alturas sincronizadas
                if (window.imageResizeObserver) {
                    window.imageResizeObserver.disconnect();
                }
                window.imageResizeObserver = new ResizeObserver(() => {
                    syncHeights();
                });
                window.imageResizeObserver.observe(uploadArea);
            };
            reader.readAsDataURL(file);
        }

        function removeTaskImage() {
            uploadedFiles = [];
            renderAllFilePreviews();
            document.getElementById('taskFiles').value = '';
            currentTaskImage = null;
            
            // Desconectar los ResizeObservers si existen
            if (window.imageResizeObserver) {
                window.imageResizeObserver.disconnect();
                window.imageResizeObserver = null;
            }
            if (window.filesResizeObserver) {
                window.filesResizeObserver.disconnect();
                window.filesResizeObserver = null;
            }
        }

        function previewEditImage(taskId) {
            const file = document.getElementById(`editImage-${taskId}`).files[0];
            if (file) {
                if (isValidImageFormat(file)) {
                handleEditImageFile(file, taskId);
                } else {
                    const fileName = file.name;
                    const fileExtension = fileName.substring(fileName.lastIndexOf('.')).toUpperCase() || 'unknown';
                    showMessage(`This file format is not accepted (${fileExtension})`, 'error');
                    // Clear the input
                    document.getElementById(`editImage-${taskId}`).value = '';
                }
            }
        }

        function handleEditImageFile(file, taskId) {
            const reader = new FileReader();
            reader.onload = function(e) {
                document.getElementById(`editImagePreview-${taskId}`).src = e.target.result;
                document.getElementById(`editImagePreview-${taskId}`).style.display = 'block';
                document.getElementById(`editImagePreviewText-${taskId}`).style.display = 'none';
                document.getElementById(`removeEditImageBtn-${taskId}`).style.display = 'block';
            };
            reader.readAsDataURL(file);
        }

        // Setup drag and drop for edit forms dynamically
        function setupEditImageDragDrop(taskId) {
            const editImageArea = document.querySelector(`#editImage-${taskId}`).closest('.image-upload-area');
            if (!editImageArea || editImageArea.dataset.dragSetup === 'true') return;
            
            editImageArea.dataset.dragSetup = 'true';

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                editImageArea.addEventListener(eventName, preventDefaults, false);
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                editImageArea.addEventListener(eventName, function() {
                    this.classList.add('drag-over');
                }, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                editImageArea.addEventListener(eventName, function() {
                    this.classList.remove('drag-over');
                }, false);
            });

            editImageArea.addEventListener('drop', function(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (isValidImageFormat(file)) {
                        handleEditImageFile(file, taskId);
                        // Also set the file input
                        const dataTransfer = new DataTransfer();
                        dataTransfer.items.add(file);
                        document.getElementById(`editImage-${taskId}`).files = dataTransfer.files;
                    } else {
                        const fileName = file.name;
                        const fileExtension = fileName.substring(fileName.lastIndexOf('.')).toUpperCase() || 'unknown';
                        showMessage(`This file format is not accepted (${fileExtension})`, 'error');
                    }
                }
            }, false);
        }

        function removeEditImage(taskId) {
            document.getElementById(`editImage-${taskId}`).value = '';
            const preview = document.getElementById(`editImagePreview-${taskId}`);
            const task = tasks.find(t => t.id === taskId);
            preview.src = getProtectedImageUrl(task.image || '');
            preview.style.display = task.image ? 'block' : 'none';
            document.getElementById(`editImagePreviewText-${taskId}`).style.display = task.image ? 'none' : 'block';
            document.getElementById(`removeEditImageBtn-${taskId}`).setAttribute('data-removed', 'true');
            document.getElementById(`removeEditImageBtn-${taskId}`).style.display = 'none';
        }

        async function uploadImage(file) {
            const formData = new FormData();
            formData.append('image', file);

            try {
                const res = await fetch(UPLOAD_URL, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    },
                    body: formData
                });

                if (res.status === 401) {
                    logout();
                    return null;
                }

                const data = await res.json();
                if (!res.ok) {
                    showMessage(data.message || 'Error uploading image', 'error');
                    return null;
                }

                return data.path;
            } catch (error) {
                showMessage('Error uploading image', 'error');
                return null;
            }
        }

        function setupTaskDescriptionLists() {
            const descriptionTextarea = document.getElementById('taskDescription');
            if (!descriptionTextarea) return;

            const LIST_INDENT = '     '; // 5 espacios

            descriptionTextarea.addEventListener('input', function(e) {
                const textarea = e.target;
                const value = textarea.value;
                const cursorPos = textarea.selectionStart;

                // Obtener la línea actual y su posición
                const textBeforeCursor = value.substring(0, cursorPos);
                const lines = textBeforeCursor.split('\n');
                const currentLineIndex = lines.length - 1;
                const allLines = value.split('\n');
                const currentLine = allLines[currentLineIndex] || '';
                const trimmedLine = currentLine.trim();

                // Detectar si se acaba de escribir "- " al inicio de una línea (sin los 5 espacios)
                if (trimmedLine.startsWith('- ') && !currentLine.startsWith(LIST_INDENT)) {
                    // Calcular la posición del inicio de la línea actual
                    const lineStartPos = textBeforeCursor.lastIndexOf('\n') + 1;
                    const lineBeforeDash = currentLine.substring(0, currentLine.indexOf('- '));
                    const lineAfterDash = currentLine.substring(currentLine.indexOf('- '));
                    
                    // Construir la nueva línea con los 5 espacios
                    const newLine = LIST_INDENT + lineAfterDash;
                    
                    // Reemplazar la línea en el texto completo
                    const beforeLine = value.substring(0, lineStartPos);
                    const afterLine = value.substring(lineStartPos + currentLine.length);
                    const newValue = beforeLine + newLine + afterLine;
                    
                    // Calcular la nueva posición del cursor
                    const newCursorPos = lineStartPos + newLine.length - (currentLine.length - cursorPos);
                    
                    textarea.value = newValue;
                    textarea.setSelectionRange(newCursorPos, newCursorPos);
                    return;
                }

                // Detectar si se acaba de escribir "1. " (o cualquier número) al inicio de una línea (sin los 5 espacios)
                const numberedMatch = trimmedLine.match(/^(\d+)\.\s/);
                if (numberedMatch && !currentLine.startsWith(LIST_INDENT)) {
                    // Calcular la posición del inicio de la línea actual
                    const lineStartPos = textBeforeCursor.lastIndexOf('\n') + 1;
                    const numberPattern = numberedMatch[0];
                    const lineBeforeNumber = currentLine.substring(0, currentLine.indexOf(numberPattern));
                    const lineAfterNumber = currentLine.substring(currentLine.indexOf(numberPattern));
                    
                    // Construir la nueva línea con los 5 espacios
                    const newLine = LIST_INDENT + lineAfterNumber;
                    
                    // Reemplazar la línea en el texto completo
                    const beforeLine = value.substring(0, lineStartPos);
                    const afterLine = value.substring(lineStartPos + currentLine.length);
                    const newValue = beforeLine + newLine + afterLine;
                    
                    // Calcular la nueva posición del cursor
                    const newCursorPos = lineStartPos + newLine.length - (currentLine.length - cursorPos);
                    
                    textarea.value = newValue;
                    textarea.setSelectionRange(newCursorPos, newCursorPos);
                    return;
                }
            });

            descriptionTextarea.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    const textarea = e.target;
                    const value = textarea.value;
                    const cursorPos = textarea.selectionStart;
                    
                    // Obtener la línea actual
                    const lines = value.split('\n');
                    const currentLineIndex = value.substring(0, cursorPos).split('\n').length - 1;
                    const currentLine = lines[currentLineIndex] || '';
                    const trimmedLine = currentLine.trim();
                    
                    // Detectar si estamos en una lista con guiones
                    if (trimmedLine.match(/^-\s/)) {
                        e.preventDefault();
                        const newLine = LIST_INDENT + '- ';
                        const beforeCursor = value.substring(0, cursorPos);
                        const afterCursor = value.substring(cursorPos);
                        textarea.value = beforeCursor + '\n' + newLine + afterCursor;
                        const newCursorPos = cursorPos + 1 + newLine.length;
                        textarea.setSelectionRange(newCursorPos, newCursorPos);
                        return;
                    }
                    
                    // Detectar si estamos en una lista numerada
                    const numberedMatch = trimmedLine.match(/^(\d+)\.\s/);
                    if (numberedMatch) {
                        e.preventDefault();
                        const currentNumber = parseInt(numberedMatch[1], 10);
                        const nextNumber = currentNumber + 1;
                        const newLine = LIST_INDENT + nextNumber + '. ';
                        const beforeCursor = value.substring(0, cursorPos);
                        const afterCursor = value.substring(cursorPos);
                        textarea.value = beforeCursor + '\n' + newLine + afterCursor;
                        const newCursorPos = cursorPos + 1 + newLine.length;
                        textarea.setSelectionRange(newCursorPos, newCursorPos);
                        return;
                    }
                }
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            updateCreateTagPreview();
            setupDatePicker();
            setupTimePicker();
            setupTaskDescriptionLists();
        });

        document.getElementById('taskForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const title = document.getElementById('taskTitle').value.trim();
            const description = document.getElementById('taskDescription').value.trim();
            const dueDate = document.getElementById('taskDate').value;
            const dueTime = document.getElementById('taskTimeHidden')?.value || '';
            
            // Get selected tag IDs
            // Use selectedTagsForTask
            const tagIds = selectedTagsForTask;
            
            // Get uploaded files (images and PDFs)
            // TODO: Implement upload for multiple files
            const files = uploadedFiles.map(f => f.file);
            const imageFiles = files.filter(f => isValidImageFormat(f));
            const pdfFiles = files.filter(f => isValidPdfFormat(f));

            if (!title) {
                showMessage('Please enter a task title', 'error');
                return;
            }

            try {
                // TODO: Upload multiple files (images and PDFs)
                // For now, just use the first image if available (backward compatibility)
                let imagePath = null;
                if (imageFiles.length > 0) {
                    // Temporary: upload first image for backward compatibility
                    // TODO: Upload all files and store paths
                    imagePath = await uploadImage(imageFiles[0]);
                    if (!imagePath) return; // Error already shown
                }

                const res = await fetch(API_URL, {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ title, description, dueDate, dueTime, tagIds, image: imagePath })
                });

                if (res.status === 401) {
                    logout();
                    showMessage('Session expired. Please login again.', 'error');
                    return;
                }

                if (!res.ok) throw new Error();
                showMessage('Task created', 'success');
                resetTaskForm();
                closeTaskModal();
                await loadTasks();
            } catch (error) {
                showMessage('Error creating task', 'error');
            }
        });

        async function toggleTask(id, completed) {
            try {
                const task = tasks.find(t => t.id === id);
                const res = await fetch(`${API_URL}/${id}`, {
                    method: 'PUT',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({
                        title: task.title,
                        description: task.description,
                        completed: completed ? 1 : 0,
                        dueDate: task.dueDate,
                        dueTime: task.dueTime,
                        tagIds: task.tags ? task.tags.map(t => t.id) : (task.tagId ? [task.tagId] : []),
                        image: task.image
                    })
                });
                
                if (res.status === 401) {
                    logout();
                    return;
                }
                
                if (!res.ok) throw new Error();
                await loadTasks();
            } catch (error) {
                showMessage('Error updating task', 'error');
                await loadTasks();
            }
        }

        function editTask(id) {
            const form = document.getElementById(`editForm-${id}`);
            form.classList.add('active');
            
            // Populate tag checkboxes
            const tagContainer = document.getElementById(`editTags-${id}`);
            const task = tasks.find(t => t.id === id);
            const taskTagIds = task.tags ? task.tags.map(t => t.id) : (task.tagId ? [task.tagId] : []);
            
            tagContainer.innerHTML = '';
            tags.forEach(tag => {
                const tagItem = document.createElement('div');
                tagItem.className = 'tag-checkbox-item';
                const isSelected = taskTagIds.includes(tag.id);
                if (isSelected) {
                    tagItem.classList.add('selected');
                }
                tagItem.dataset.tagId = tag.id;
                tagItem.innerHTML = `
                    <span class="tag-color-indicator" style="background-color: ${tag.color || '#007bff'}"></span>
                    <span>${escapeHtml(tag.name)}</span>
                    <input type="checkbox" value="${tag.id}" id="editTagCheck-${id}-${tag.id}" ${isSelected ? 'checked' : ''}>
                `;
                
                tagItem.addEventListener('click', function(e) {
                    if (e.target.tagName !== 'INPUT') {
                        const checkbox = this.querySelector('input[type="checkbox"]');
                        checkbox.checked = !checkbox.checked;
                        this.classList.toggle('selected', checkbox.checked);
                    }
                });
                
                const checkbox = tagItem.querySelector('input[type="checkbox"]');
                checkbox.addEventListener('change', function() {
                    tagItem.classList.toggle('selected', this.checked);
                });
                
                tagContainer.appendChild(tagItem);
            });
            
            // Setup drag and drop for edit image
            setTimeout(() => setupEditImageDragDrop(id), 100);
            
            // Reset image removal flag
            const removeBtn = document.getElementById(`removeEditImageBtn-${id}`);
            if (removeBtn) {
                removeBtn.removeAttribute('data-removed');
            }
        }

        function cancelEdit(id) {
            const form = document.getElementById(`editForm-${id}`);
            form.classList.remove('active');
            
            // Reset image input
            const imageInput = document.getElementById(`editImage-${id}`);
            if (imageInput) {
                imageInput.value = '';
                const task = tasks.find(t => t.id === id);
                const preview = document.getElementById(`editImagePreview-${id}`);
                if (preview && task.image) {
                    preview.src = getProtectedImageUrl(task.image);
                    preview.style.display = 'block';
                    document.getElementById(`editImagePreviewText-${id}`).style.display = 'none';
                    document.getElementById(`removeEditImageBtn-${id}`).style.display = 'block';
                } else if (preview) {
                    preview.style.display = 'none';
                    document.getElementById(`editImagePreviewText-${id}`).style.display = 'block';
                    document.getElementById(`removeEditImageBtn-${id}`).style.display = 'none';
                }
            }
        }

        async function saveEdit(id) {
            const title = document.getElementById(`editTitle-${id}`).value.trim();
            const description = document.getElementById(`editDesc-${id}`).value.trim();
            const dueDate = document.getElementById(`editDate-${id}`).value;
            const dueTime = document.getElementById(`editTime-${id}`).value;
            // Get selected tag IDs
            const selectedTags = Array.from(document.querySelectorAll(`#editTags-${id} input[type="checkbox"]:checked`))
                .map(cb => parseInt(cb.value));
            const tagIds = selectedTags.length > 0 ? selectedTags : [];
            
            const imageFile = document.getElementById(`editImage-${id}`).files[0];
            const task = tasks.find(t => t.id === id);

            if (!title) {
                showMessage('Title is required', 'error');
                return;
            }

            try {
                // Upload new image if provided, otherwise keep existing or remove if explicitly removed
                let imagePath = task.image || null;
                const removeBtn = document.getElementById(`removeEditImageBtn-${id}`);
                
                if (imageFile) {
                    // New image uploaded
                    imagePath = await uploadImage(imageFile);
                    if (!imagePath) return; // Error already shown
                } else if (removeBtn && removeBtn.getAttribute('data-removed') === 'true') {
                    // Image was explicitly removed
                    imagePath = null;
                }

                const res = await fetch(`${API_URL}/${id}`, {
                    method: 'PUT',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ title, description, completed: task.completed, dueDate, dueTime, tagIds, image: imagePath })
                });
                
                if (res.status === 401) {
                    logout();
                    return;
                }
                
                if (!res.ok) throw new Error();
                showMessage('Task updated', 'success');
                cancelEdit(id);
                await loadTasks();
            } catch (error) {
                showMessage('Error updating task', 'error');
            }
        }

        async function deleteTask(id) {
            if (!confirm('Delete this task?')) return;
            try {
                const res = await fetch(`${API_URL}/${id}`, {
                    method: 'DELETE',
                    headers: getAuthHeaders()
                });
                
                if (res.status === 401) {
                    logout();
                    return;
                }
                
                if (!res.ok) throw new Error();
                showMessage('Task deleted', 'success');
                await loadTasks();
            } catch (error) {
                showMessage('Error deleting task', 'error');
            }
        }
        // Close context menu when clicking outside
        document.addEventListener('click', (e) => {
            const contextMenu = document.getElementById('contextMenu');
            if (contextMenu && contextMenu.style.display !== 'none') {
                // Check if click is outside the context menu
                if (!contextMenu.contains(e.target)) {
                    hideContextMenu();
                }
            }
        }, true); // Use capture phase to catch clicks early

        // Close context menu on escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                hideContextMenu();
            }
        });
    </script>
</body>
</html>
