<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task Master</title>
    <link rel="icon" type="image/png" href="/favicon/favicon.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Allow text selection in input fields and textareas */
        input,
        textarea {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #f0f4f8 0%, #e2e8f0 100%);
            height: 100vh;
            overflow: hidden;
            color: #1e293b;
            line-height: 1.6;
        }

        .container {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        /* App Header */
        .app-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: #ffffff;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            z-index: 1000;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            box-sizing: border-box;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .header-title {
            font-size: 20px;
            font-weight: 700;
            color: #0f172a;
            margin: 0;
        }

        .header-user {
            font-size: 14px;
            color: #64748b;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .add-task-btn, .profile-btn {
            padding: 8px 16px;
            border: 1px solid #e2e8f0;
            background: #ffffff;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #475569;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .add-task-btn:hover, .profile-btn:hover {
            background: #f8fafc;
            border-color: #cbd5e1;
        }

        .add-task-btn svg {
            width: 16px;
            height: 16px;
        }

        /* Workspace */
        .workspace {
            display: grid;
            grid-template-columns: 280px 1fr 1fr;
            grid-template-rows: 1fr;
            gap: 16px;
            padding: 16px;
            flex: 1;
            min-height: 0;
            overflow: hidden;
            height: calc(100vh - 60px);
            margin-top: 60px;
        }

        /* Left Column */
        .left-column {
            display: grid;
            grid-template-rows: 1fr 1fr;
            gap: 16px;
            height: 100%;
        }

        /* Floating Window Styles */
        .floating-window {
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(0, 0, 0, 0.08);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: box-shadow 0.2s ease;
            border: 1px solid rgba(226, 232, 240, 0.8);
            height: calc(100vh - 92px);
            max-height: calc(100vh - 92px);
        }

        .floating-window:hover {
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.15), 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .window-header {
            background: linear-gradient(135deg, #f8fafc 0%, #ffffff 100%);
            padding: 14px 18px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            flex-shrink: 0;
            height: 52px;
            box-sizing: border-box;
        }

        .window-title {
            font-size: 15px;
            font-weight: 600;
            color: #0f172a;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .window-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 20px;
            min-height: 0;
            height: calc(100vh - 92px - 52px);
            max-height: calc(100vh - 92px - 52px);
        }

        /* Task Creation Window */
        .task-creation-window {
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 100;
        }

        /* Profile Window */
        .profile-window {
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* Calendar Window */
        .calendar-window {
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* Task List Window */
        .task-list-window {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #taskList {
            flex: 1;
            overflow-y: auto;
            padding-right: 8px;
        }

        /* Custom Scrollbar */
        .left-panel::-webkit-scrollbar,
        .right-panel::-webkit-scrollbar,
        #taskList::-webkit-scrollbar {
            width: 8px;
        }

        .left-panel::-webkit-scrollbar-track,
        .right-panel::-webkit-scrollbar-track,
        #taskList::-webkit-scrollbar-track {
            background: transparent;
        }

        .left-panel::-webkit-scrollbar-thumb,
        .right-panel::-webkit-scrollbar-thumb,
        #taskList::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }

        .left-panel::-webkit-scrollbar-thumb:hover,
        .right-panel::-webkit-scrollbar-thumb:hover,
        #taskList::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        h1 {
            margin-bottom: 8px;
            color: #0f172a;
            font-size: 32px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        h2 {
            margin-bottom: 24px;
            color: #1e293b;
            font-size: 20px;
            font-weight: 600;
            letter-spacing: -0.3px;
        }

        .form-container {
            background: #ffffff;
            padding: 32px;
            border-radius: 16px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05), 0 1px 2px rgba(0,0,0,0.1);
            border: 1px solid #e2e8f0;
            margin-bottom: 24px;
        }

        .form-group {
            margin-bottom: 24px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 14px;
            color: #475569;
        }

        input, textarea, select {
            width: 100%;
            padding: 12px 16px;
            border: 1.5px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.2s ease;
            background: #ffffff;
            color: #1e293b;
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        textarea {
            resize: vertical;
            min-height: 80px;
            font-family: inherit;
        }

        .date-time-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        button {
            padding: 12px 24px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }

        button:hover {
            background: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        button:active {
            transform: translateY(0);
        }

        .task-item {
            background: white;
            padding: 24px;
            margin-bottom: 16px;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05), 0 1px 2px rgba(0,0,0,0.1);
            border: 1px solid #e2e8f0;
            transition: all 0.2s ease;
        }

        .task-item:hover {
            box-shadow: 0 4px 6px rgba(0,0,0,0.07), 0 2px 4px rgba(0,0,0,0.06);
            transform: translateY(-1px);
        }

        .task-header {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            margin-bottom: 12px;
        }

        .task-header input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-top: 2px;
            cursor: pointer;
            accent-color: #3b82f6;
        }

        .task-title {
            font-weight: 600;
            font-size: 16px;
            color: #1e293b;
            flex: 1;
            line-height: 1.5;
        }

        .task-item.completed .task-title {
            text-decoration: line-through;
            color: #94a3b8;
        }

        .task-info {
            color: #64748b;
            font-size: 14px;
            margin-bottom: 12px;
            line-height: 1.6;
            margin-left: 32px;
        }

        .task-date-time {
            color: #94a3b8;
            font-size: 13px;
            margin-top: 8px;
            margin-left: 32px;
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .task-actions {
            display: flex;
            gap: 8px;
            margin-top: 16px;
            margin-left: 32px;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 13px;
            border-radius: 6px;
        }

        .btn-edit {
            background: #f59e0b;
        }

        .btn-edit:hover {
            background: #d97706;
        }

        .btn-delete {
            background: #ef4444;
        }

        .btn-delete:hover {
            background: #dc2626;
        }

        .edit-form {
            display: none;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e2e8f0;
        }

        .edit-form.active {
            display: block;
        }

        .message {
            padding: 14px 18px;
            margin-bottom: 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .message.success {
            background: #d1fae5;
            color: #065f46;
            border: 1px solid #a7f3d0;
        }

        .message.error {
            background: #fee2e2;
            color: #991b1b;
            border: 1px solid #fecaca;
        }

        .message.info {
            background: #dbeafe;
            color: #1d4ed8;
            border: 1px solid #bfdbfe;
        }

        .empty {
            text-align: center;
            padding: 60px 40px;
            color: #94a3b8;
            font-size: 15px;
        }

        #message {
            position: fixed;
            bottom: 24px;
            right: 24px;
            z-index: 100000;
            max-width: 360px;
            animation: slideIn 0.3s ease;
            pointer-events: none;
            filter: none !important;
            mix-blend-mode: normal;
        }

        @keyframes slideIn {
            from {
                transform: translateY(100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* Login/Register Styles */
        .auth-container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .auth-box {
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
            width: 100%;
            max-width: 420px;
        }

        .auth-tabs {
            display: flex;
            margin-bottom: 28px;
            border-bottom: 2px solid #e2e8f0;
        }

        .auth-tab {
            flex: 1;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            background: none;
            border: none;
            font-size: 15px;
            font-weight: 500;
            color: #64748b;
            transition: all 0.2s ease;
        }

        .auth-tab:hover {
            color: #3b82f6;
        }

        .auth-tab.active {
            color: #3b82f6;
            border-bottom: 3px solid #3b82f6;
            margin-bottom: -2px;
            font-weight: 600;
        }

        .auth-form {
            display: none;
        }

        .auth-form.active {
            display: block;
        }

        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 32px;
            padding: 16px 20px;
            background: #f1f5f9;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
        }

        .top-bar strong {
            color: #1e293b;
            font-weight: 600;
            font-size: 14px;
        }

        .profile-btn {
            background: #3b82f6;
            padding: 8px 16px;
            font-size: 13px;
            border-radius: 6px;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .profile-btn:hover {
            background: #2563eb;
        }

        .logout-btn {
            background: transparent !important;
            border: none !important;
            padding: 0;
            color: #ef4444;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: color 0.2s ease;
            width: auto;
            text-align: center;
            display: block;
            margin: 0 auto;
            position: relative;
            box-shadow: none !important;
            text-shadow: none !important;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        .logout-btn:hover {
            background: transparent !important;
            color: #dc2626;
            text-decoration: underline;
            box-shadow: none !important;
        }

        .logout-btn:focus {
            background: transparent !important;
            outline: none;
            box-shadow: none !important;
        }

        .logout-btn:active {
            background: transparent !important;
            box-shadow: none !important;
        }

        /* Logout Confirmation Modal Styles */
        .logout-confirm-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 3000;
            backdrop-filter: blur(4px);
            animation: fadeIn 0.2s ease;
            align-items: center;
            justify-content: center;
        }

        .logout-confirm-overlay.active {
            display: flex;
        }

        .logout-confirm-modal {
            background: white;
            border-radius: 16px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
            animation: slideUpScale 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            transform-origin: center;
        }

        @keyframes slideUpScale {
            from {
                transform: translateY(20px) scale(0.9);
                opacity: 0;
            }
            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        .logout-confirm-content {
            padding: 32px;
            text-align: center;
        }

        .logout-confirm-content h3 {
            margin: 0 0 12px 0;
            font-size: 20px;
            font-weight: 600;
            color: #1e293b;
        }

        .logout-confirm-content p {
            margin: 0 0 24px 0;
            font-size: 14px;
            color: #64748b;
            line-height: 1.5;
        }

        .logout-confirm-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .logout-confirm-btn {
            padding: 10px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            border: none;
            transition: all 0.2s ease;
            min-width: 120px;
        }

        .logout-confirm-yes {
            background: #ef4444;
            color: white;
        }

        .logout-confirm-yes:hover {
            background: #dc2626;
            transform: translateY(-1px);
            box-shadow: 0 4px 6px -1px rgba(239, 68, 68, 0.3);
        }

        .logout-confirm-yes:active {
            transform: translateY(0);
        }

        .logout-confirm-no {
            background: #f1f5f9;
            color: #475569;
        }

        .logout-confirm-no:hover {
            background: #e2e8f0;
            transform: translateY(-1px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .logout-confirm-no:active {
            transform: translateY(0);
        }

        /* Profile Modal Styles */
        .profile-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            backdrop-filter: blur(4px);
            animation: fadeIn 0.2s ease;
        }

        .profile-overlay.active {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .profile-modal {
            background: white;
            border-radius: 20px;
            width: 95%;
            max-width: 1200px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .profile-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 28px 40px;
            border-bottom: 1px solid #e2e8f0;
            background: linear-gradient(135deg, #f8fafc 0%, #ffffff 100%);
        }

        .profile-header h2 {
            margin: 0;
            font-size: 28px;
            font-weight: 700;
            color: #0f172a;
            letter-spacing: -0.5px;
        }

        .close-profile {
            background: none !important;
            border: none !important;
            font-size: 24px;
            color: #64748b;
            cursor: pointer;
            padding: 0;
            margin: 0;
            width: auto;
            height: auto;
            display: inline-block;
            line-height: 1;
            outline: none !important;
            box-shadow: none !important;
            border-radius: 0 !important;
            transition: color 0.2s ease;
        }

        .close-profile:hover {
            color: #ef4444;
            background: none !important;
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
        }

        .close-profile:focus {
            outline: none !important;
            box-shadow: none !important;
            background: none !important;
            border: none !important;
        }

        .profile-content {
            padding: 40px;
            display: grid;
            grid-template-columns: 30% 70%;
            gap: 40px;
        }

        .profile-left-column {
            display: flex;
            flex-direction: column;
            gap: 40px;
        }

        .profile-right-column {
            display: flex;
            flex-direction: column;
            gap: 40px;
            width: 500px;
            flex-shrink: 0;
        }

        .profile-section {
            margin-bottom: 0;
            background: #ffffff;
            padding: 24px;
            padding-bottom: 20px;
            border-radius: 16px;
            border: 1px solid #e2e8f0;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            height: 500px;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            overflow: hidden;
        }

        .profile-section:last-child {
            margin-bottom: 0;
        }

        .profile-section h3 {
            font-size: 16px;
            font-weight: 700;
            color: #0f172a;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e2e8f0;
            letter-spacing: -0.2px;
        }

        .profile-info {
            background: #f8fafc;
            padding: 20px 24px;
            border-radius: 12px;
            margin-bottom: 16px;
            border: 1px solid #e2e8f0;
            transition: all 0.2s ease;
        }

        .profile-info.editable {
            background: #ffffff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            overflow: hidden;
            padding: 16px 20px;
            min-height: 48px;
        }

        .profile-info-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 0;
        }

        .profile-info-item:not(:last-child) {
            margin-bottom: 0;
        }

        .profile-info-label {
            font-weight: 600;
            color: #475569;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }

        .profile-info-value {
            font-weight: 600;
            color: #1e293b;
            font-size: 15px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            text-align: left;
        }

        .profile-editable-input {
            border: none;
            background: transparent;
            font-weight: 600;
            color: #1e293b;
            font-size: 15px;
            padding: 0;
            margin: 0;
            text-align: left;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            outline: none;
            cursor: text;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            height: auto;
            min-height: 24px;
            line-height: 1.6;
        }

        .password-input-wrapper {
            position: relative;
            width: 100%;
            display: flex;
            align-items: center;
        }

        .password-input {
            padding-right: 45px !important;
            width: calc(100% - 45px);
            max-width: 300px;
        }

        .profile-editable-input:hover {
            background: #f1f5f9;
            border-radius: 4px;
        }

        .profile-editable-input:focus {
            background: #f1f5f9;
            border-radius: 4px;
        }

        .password-toggle-btn {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            background: transparent;
            border: none;
            padding: 4px;
            cursor: pointer;
            transition: color 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            color: #64748b;
            flex-shrink: 0;
        }

        .password-toggle-btn:hover {
            background: transparent;
            color: #3b82f6;
            transform: translateY(-50%);
        }

        .password-toggle-btn:active {
            transform: translateY(-50%);
            color: #2563eb;
        }

        .password-toggle-btn svg {
            width: 20px;
            height: 20px;
            stroke: currentColor;
        }

        .profile-editable-input[readonly] {
            cursor: default;
            user-select: none;
            pointer-events: none;
        }

        .profile-editable-input:not([readonly]) {
            cursor: text;
        }

        /* Task Modal Styles */
        .task-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            z-index: 2000;
            backdrop-filter: blur(4px);
            animation: fadeIn 0.2s ease;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .task-modal-overlay.active {
            display: flex;
        }

        .task-modal {
            background: white;
            border-radius: 16px;
            width: 100%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
            animation: slideUpScale 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            transform-origin: center;
        }

        /* Tags modal specific styles - appears as auxiliary window */
        #tagsModalOverlay {
            background: rgba(0, 0, 0, 0.1);
            backdrop-filter: none;
            justify-content: flex-start;
            align-items: flex-start;
            padding: 0;
        }

        #tagsModalOverlay .task-modal {
            max-width: 450px;
            width: 450px;
            height: 500px;
            max-height: 500px;
            margin: 0;
            position: absolute;
            box-shadow: 0 10px 25px -5px rgba(0,0,0,0.2), 0 8px 10px -5px rgba(0,0,0,0.1);
            animation: fadeInScale 0.2s ease;
            transform-origin: top left;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        #tagsModalOverlay .task-modal-content {
            flex: 1;
            overflow: hidden;
            padding: 16px 20px;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        /* Hide scrollbars for tags modal columns but keep scroll functionality */
        #tagsModalFoldersColumn::-webkit-scrollbar,
        #tagsModalTagsColumn::-webkit-scrollbar,
        #tagsModalAllTagsColumn::-webkit-scrollbar {
            width: 0px;
            background: transparent;
        }
        
        #tagsModalFoldersColumn,
        #tagsModalTagsColumn,
        #tagsModalAllTagsColumn {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        
        #tagsModalFoldersColumn::-webkit-scrollbar-track,
        #tagsModalTagsColumn::-webkit-scrollbar-track,
        #tagsModalAllTagsColumn::-webkit-scrollbar-track {
            background: transparent;
        }
        
        #tagsModalOverlay .task-modal-header {
            padding: 16px 20px;
        }
        
        /* Remove profile-section styling inside tags modal */
        #tagsModalOverlay .profile-section {
            border-radius: 0 !important;
            background: transparent !important;
            box-shadow: none !important;
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
            height: auto !important;
            overflow: visible !important;
        }
        
        #tagsModalOverlay .task-modal-header h2 {
            font-size: 18px;
        }

        /* Create tag modal specific styles - appears as auxiliary window */
        #createTagModalOverlay {
            background: rgba(0, 0, 0, 0.1);
            backdrop-filter: none;
            justify-content: flex-start;
            align-items: flex-start;
            padding: 0;
        }

        #createTagModalOverlay .task-modal {
            max-width: 450px;
            width: 450px;
            height: 380px;
            max-height: 380px;
            margin: 0;
            position: absolute;
            box-shadow: 0 10px 25px -5px rgba(0,0,0,0.2), 0 8px 10px -5px rgba(0,0,0,0.1);
            animation: fadeInScale 0.2s ease;
            transform-origin: top left;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #createTagModalOverlay .task-modal-content {
            flex: 1;
            overflow: hidden;
            padding: 16px 20px;
        }

        #createTagModalOverlay .task-modal-header {
            padding: 12px 20px;
        }

        #createTagModalOverlay .task-modal-header h2 {
            font-size: 16px;
        }

        #createTagModalOverlay label {
            margin-bottom: 0 !important;
            line-height: 1 !important;
        }

        @keyframes fadeInScale {
            from {
                transform: scale(0.95);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .task-modal-header {
            padding: 24px 28px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            background: white;
            border-radius: 16px 16px 0 0;
            z-index: 10;
        }

        .task-modal-header h2 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
            color: #0f172a;
        }

        .task-modal-close {
            background: none !important;
            border: none !important;
            font-size: 28px;
            color: #64748b;
            cursor: pointer;
            width: auto;
            height: auto;
            display: inline-block;
            line-height: 1;
            padding: 0;
            margin: 0;
            outline: none !important;
            box-shadow: none !important;
            border-radius: 0 !important;
            transition: color 0.2s ease;
        }

        .task-modal-close:hover {
            color: #ef4444;
            background: none !important;
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
        }

        .task-modal-close:focus {
            outline: none !important;
            box-shadow: none !important;
            background: none !important;
            border: none !important;
        }

        .task-modal-content {
            padding: 24px 28px;
        }

        /* Tags Styles */
        .tag {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
            color: white;
            margin-right: 5px;
        }

        .tag-select-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 5px;
        }

        .tag-checkbox-item {
            display: flex;
            align-items: center;
            padding: 6px 12px;
            border: 2px solid #ddd;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
            font-size: 13px;
        }

        .tag-checkbox-item:hover {
            border-color: #007bff;
            background: #f0f7ff;
        }

        .tag-checkbox-item.selected {
            border-color: #007bff;
            background: #007bff;
            color: white;
        }


        .tag-checkbox-item .tag-color-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 6px;
            display: inline-block;
        }

        .tags-section {
            margin-top: 24px;
            padding-top: 24px;
            border-top: 1px solid #e2e8f0;
        }

        .tags-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .tag-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 12px;
            background: #f1f5f9;
            border: 1px solid #e2e8f0;
            transition: all 0.2s ease;
        }

        .tag-item:hover {
            background: #e2e8f0;
        }

        .tag-item .tag-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
        }

        .tag-item .delete-tag {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            cursor: pointer;
            font-size: 10px;
            padding: 0;
            line-height: 1;
        }

        .tag-item .delete-tag:hover {
            background: #c82333;
        }

        .new-folder-form {
            display: flex;
            gap: 10px;
            margin-bottom: 12px;
        }

        .new-folder-form input {
            flex: 1;
        }

        .new-folder-form input[type="color"] {
            width: 60px;
            height: 44px;
            border-radius: 8px;
            cursor: pointer;
        }

        .folder-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
        }

        .folder-card .delete-tag:hover {
            background: #fee2e2 !important;
        }

        .tag-item:hover {
            background: #f1f5f9 !important;
        }

        .tag-item .delete-tag:hover {
            opacity: 1 !important;
            background: #fee2e2;
        }

        .create-btn {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: 2px solid #3b82f6;
            background: #3b82f6;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.2);
            padding: 0;
        }

        .create-btn:hover {
            background: #2563eb;
            border-color: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 4px 6px rgba(59, 130, 246, 0.3);
        }

        .create-btn:active {
            transform: translateY(0);
        }

        .create-btn svg {
            width: 20px;
            height: 20px;
        }

        .view-btn {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: 2px solid #e2e8f0;
            background: #ffffff;
            color: #64748b;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            padding: 0;
        }

        .view-btn:hover {
            border-color: #3b82f6;
            color: #3b82f6;
            background: #eff6ff;
        }

        .view-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        .view-btn.active:hover {
            background: #2563eb;
            border-color: #2563eb;
        }

        #sortOrderBtn {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 0;
        }

        #sortOrderBtn svg {
            display: block;
            margin: 0;        }

        /* Drag and drop styles */
        .tag-item[draggable="true"] {
            user-select: none;
        }

        .tag-item[draggable="true"]:active {
            cursor: grabbing;
        }

        .folder-item.drag-over {
            opacity: 0.7;
            transform: scale(1.02);
            transition: all 0.2s ease;
        }

        /* Context Menu Styles */
        .context-menu {
            position: fixed;
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 4px;
            z-index: 10000;
            min-width: 160px;
            max-width: 260px;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }

        .context-menu-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            cursor: pointer;
            border-radius: 4px;
            color: #1e293b;
            font-size: 14px;
            transition: background 0.2s ease;
        }

        .context-menu-item:hover {
            background: #f1f5f9;
        }

        .context-menu-item-danger {
            color: #ef4444;
        }

        .context-menu-item-danger:hover {
            background: #fee2e2;
        }

        .context-menu-item svg {
            flex-shrink: 0;
        }

        .context-menu-item + .context-menu-item {
            border-top: 1px solid #f1f5f9;
        }

        .context-menu-confirm {
            display: none;
            flex-direction: column;
            gap: 12px;
            width: 100%;
            min-height: 100%;
            max-width: 100%;
            box-sizing: border-box;
            overflow: hidden;
            word-break: break-word;
            justify-content: center;
            align-items: center;
            padding: 8px 12px;
            background: #ffffff;
            font-family: inherit;
        }

        .context-menu-confirm-title {
            font-weight: 600;
            font-size: 14px;
            color: #1e293b;
            text-align: center;
            width: 100%;
        }

        .context-menu-confirm-buttons {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            flex-wrap: wrap;
            width: 100%;
        }

        .context-menu-btn {
            border: none;
            border-radius: 8px;
            padding: 8px 14px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1 1 100px;
            text-align: center;
        }

        .context-menu-btn-cancel {
            background: #f1f5f9;
            color: #0f172a;
        }

        .context-menu-btn-cancel:hover {
            background: #e2e8f0;
        }

        .context-menu-btn-delete {
            background: #ef4444;
            color: #ffffff;
        }

        .context-menu-btn-delete:hover {
            background: #dc2626;
        }

        /* Highlight styles for context menu selection */
        .tag-item.context-selected {
            background: #dbeafe !important;
        }

        .folder-item.context-selected {
            position: relative;
        }

        .folder-item.context-selected::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255, 200, 87, 0.25) 0%, rgba(255, 140, 0, 0.25) 100%);
            border-radius: 8px;
            pointer-events: none;
            z-index: 1;
        }

        .folder-card-clickable {
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .folder-card-clickable:hover {
            transform: translateX(2px);
        }

        .folder-item:hover {
            transform: translateX(2px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .folder-tags-collapsed {
            display: none;
        }

        /* Hide scrollbars but keep scroll functionality */
        #foldersColumn::-webkit-scrollbar,
        #tagsColumn::-webkit-scrollbar {
            width: 0px;
            background: transparent;
        }

        #foldersColumn,
        #tagsColumn {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        #foldersColumn::-webkit-scrollbar-track,
        #tagsColumn::-webkit-scrollbar-track {
            background: transparent;
        }

        #allTagsColumn::-webkit-scrollbar {
            width: 0px;
            background: transparent;
        }

        #allTagsColumn {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        #allTagsColumn::-webkit-scrollbar-track {
            background: transparent;
        }

        .new-tag-form {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .new-tag-form input {
            flex: 1;
        }

        .new-tag-form input[type="color"] {
            width: 50px;
            height: 38px;
            padding: 2px;
        }

        .new-tag-form select {
            flex: 1;
            max-width: 150px;
            padding: 8px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            background: white;
            font-size: 14px;
        }

        /* Image Styles */
        .image-preview {
            margin-top: 12px;
            max-width: 100%;
            max-height: 200px;
            border-radius: 10px;
            border: 1px solid #e2e8f0;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .task-image {
            margin-top: 12px;
            max-width: 100%;
            max-height: 300px;
            border-radius: 10px;
            border: 1px solid #e2e8f0;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
        }

        .task-image:hover {
            opacity: 0.9;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .image-upload-area {
            border: 2px dashed #cbd5e1;
            border-radius: 12px;
            padding: 24px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8fafc;
        }

        .image-upload-area:hover {
            border-color: #3b82f6;
            background: #eff6ff;
        }

        .image-upload-area.drag-over {
            border-color: #3b82f6;
            background: #dbeafe;
            border-style: solid;
            transform: scale(1.02);
        }

        .image-upload-area input[type="file"] {
            display: none;
        }

        .remove-image-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 5px;
        }

        .remove-image-btn:hover {
            background: #c82333;
        }

        /* Filter Buttons */
        .filter-buttons {
            display: flex;
            gap: 12px;
            margin-bottom: 24px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e2e8f0;
        }

        .filter-btn {
            padding: 10px 20px;
            border: 1.5px solid #e2e8f0;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            color: #64748b;
        }

        .filter-btn:hover {
            border-color: #3b82f6;
            background: #eff6ff;
            color: #3b82f6;
        }

        .filter-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.2);
        }

        /* Search Styles */
        .search-container {
            margin-bottom: 24px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e2e8f0;
        }

        .search-input {
            width: 100%;
            padding: 14px 18px;
            border: 1.5px solid #e2e8f0;
            border-radius: 10px;
            font-size: 14px;
            transition: all 0.2s ease;
            background: white;
        }

        .search-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .search-input::placeholder {
            color: #94a3b8;
        }

        /* Responsive Profile Modal */
        @media (max-width: 768px) {
            .profile-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div id="message"></div>
    
    <!-- Login/Register Screen -->
    <div id="authScreen" class="auth-container">
        <div class="auth-box">
            <div class="auth-tabs">
                <button class="auth-tab active" onclick="showLogin()">Login</button>
                <button class="auth-tab" onclick="showRegister()">Register</button>
            </div>
            
            <form id="loginForm" class="auth-form active">
                <div class="form-group">
                    <label for="loginEmail">Email</label>
                    <input type="email" id="loginEmail" required>
                </div>
                <div class="form-group">
                    <label for="loginPassword">Password</label>
                    <input type="password" id="loginPassword" required>
                </div>
                <button type="submit">Login</button>
            </form>
            
            <form id="registerForm" class="auth-form">
                <div class="form-group">
                    <label for="registerName">Name</label>
                    <input type="text" id="registerName" required>
                </div>
                <div class="form-group">
                    <label for="registerEmail">Email</label>
                    <input type="email" id="registerEmail" required>
                </div>
                <div class="form-group">
                    <label for="registerPassword">Password</label>
                    <input type="password" id="registerPassword" required>
                </div>
                <button type="submit">Register</button>
            </form>
        </div>
    </div>

    <!-- Main App Screen -->
    <div id="appScreen" class="container" style="display: none;">
        <header class="app-header">
            <div class="header-left">
                <h1 class="header-title">Task Master</h1>
                <span class="header-user" id="userEmail"></span>
                    </div>
            <div class="header-actions">
                <button class="add-task-btn" onclick="openTaskModal()">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4"></path>
                    </svg>
                    New Task
                </button>
                    <button class="profile-btn" onclick="openProfile()">Profile</button>
                </div>
        </header>

        <div class="workspace">
            <!-- Left Column: Main and Profile -->
            <div class="left-column">
                <!-- Main Empty Window -->
                <div id="mainEmptyWindow" class="floating-window" style="display: flex;">
                    <div class="window-header">
                        <div class="window-title">
                            <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="margin-right: 4px;">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                            </svg>
                            Main
                        </div>
                    </div>
                    <div class="window-content">
                        <!-- Content will be added here -->
                    </div>
                </div>

                <!-- Profile Window -->
                <div id="profileWindow" class="floating-window profile-window" style="display: flex;">
                    <div class="window-header">
                        <div class="window-title">
                            <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="margin-right: 4px;">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
                            </svg>
                            Profile
                        </div>
                    </div>
                    <div class="window-content">
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 12px; padding: 20px;">
                            <div style="width: 64px; height: 64px; border-radius: 50%; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); display: flex; align-items: center; justify-content: center; color: white; font-size: 24px; font-weight: 600;" id="profileInitial">
                                <!-- User initial will be populated here -->
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 16px; font-weight: 600; color: #0f172a; margin-bottom: 4px;" id="profileWindowName">
                                    <!-- User name will be populated here -->
                                </div>
                                <div style="font-size: 13px; color: #64748b;" id="profileWindowEmail">
                                    <!-- User email will be populated here -->
                                </div>
                            </div>
                            <button onclick="openProfile()" style="margin-top: 8px; padding: 8px 16px; background: #3b82f6; color: white; border: none; border-radius: 6px; font-size: 13px; font-weight: 500; cursor: pointer;">Open Profile</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Center Column: Calendar -->
            <div>
                <div id="calendarWindow" class="floating-window calendar-window" style="display: flex;">
                    <div class="window-header">
                        <div class="window-title">
                            <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="margin-right: 4px;">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                            </svg>
                            Calendar
                        </div>
                    </div>
                    <div class="window-content">
                        <div id="calendarContainer">
                            <!-- Calendar will be rendered here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Column: Task List -->
            <div>
                <div id="taskListWindow" class="floating-window task-list-window" style="display: flex;">
                    <div class="window-header">
                        <div class="window-title">
                            <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="margin-right: 4px;">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path>
                            </svg>
                            <span id="tasksTitle">Pending Tasks</span>
                        </div>
                    </div>
                    <div class="window-content">
                        <div style="margin-bottom: 16px;">
                            <input type="text" id="taskSearch" class="search-input" placeholder="Search tasks..." oninput="handleSearch()" style="width: 100%; margin-bottom: 12px;">
                            <div class="filter-buttons" style="display: flex; gap: 6px;">
                                <button class="filter-btn active" onclick="setFilter('pending')" id="filterPending" style="flex: 1; padding: 6px 12px; font-size: 12px;">Pending</button>
                                <button class="filter-btn" onclick="setFilter('completed')" id="filterCompleted" style="flex: 1; padding: 6px 12px; font-size: 12px;">Completed</button>
                                <button class="filter-btn" onclick="setFilter('all')" id="filterAll" style="flex: 1; padding: 6px 12px; font-size: 12px;">All</button>
                            </div>
                        </div>
                        <div id="taskList" style="flex: 1; overflow-y: auto;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Task Creation Modal -->
    <div id="taskModalOverlay" class="task-modal-overlay" onclick="closeTaskModalOnOverlay(event)">
        <div class="task-modal" onclick="event.stopPropagation()">
            <div class="task-modal-header">
                <h2>Create New Task</h2>
                <button class="task-modal-close" onclick="closeTaskModal()"></button>
            </div>
            <div class="task-modal-content">
                <form id="taskForm">
                    <div class="form-group">
                        <label for="taskTitle">Title *</label>
                        <input type="text" id="taskTitle" required>
                    </div>
                    <div class="form-group">
                        <label for="taskDescription">Description</label>
                        <textarea id="taskDescription" style="min-height: 60px;"></textarea>
                    </div>
                    <div class="form-group">
                        <div class="date-time-row">
                            <div>
                                <label for="taskDate">Date</label>
                                <input type="date" id="taskDate">
                            </div>
                            <div>
                                <label for="taskTime">Time</label>
                                <input type="time" id="taskTime">
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Tags</label>
                        <div id="taskTags" class="tag-select-row">
                            <!-- Tags will be populated here -->
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Image</label>
                        <div class="image-upload-area" onclick="document.getElementById('taskImage').click()">
                            <input type="file" id="taskImage" accept="image/*">
                            <div id="imagePreviewText">Click to select or drag & drop image</div>
                            <img id="taskImagePreview" class="image-preview" style="display: none;">
                            <button type="button" class="remove-image-btn" id="removeImageBtn" style="display: none;" onclick="event.stopPropagation(); removeTaskImage()">Remove</button>
                        </div>
                        <small style="color: #666; font-size: 12px; display: block; margin-top: 5px;">Formats allowed: JPEG, JPG, PNG, GIF, WEBP (max 5MB)</small>
                    </div>
                    <div style="display: flex; gap: 12px; justify-content: flex-end; margin-top: 24px; padding-top: 24px; border-top: 1px solid #e2e8f0;">
                        <button type="button" onclick="closeTaskModal()" style="background: #f1f5f9; color: #475569; border: 1px solid #e2e8f0; padding: 8px 16px; border-radius: 6px; font-size: 13px; font-weight: 500; cursor: pointer;">Cancel</button>
                        <button type="submit" style="background: #3b82f6; color: white; border: none; padding: 8px 16px; border-radius: 6px; font-size: 13px; font-weight: 500; cursor: pointer;">Create Task</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Profile Modal -->
    <div id="profileOverlay" class="profile-overlay" onclick="closeProfileOnOverlay(event)">
        <div class="profile-modal" onclick="event.stopPropagation()">
            <div class="profile-header">
                <h2>Profile</h2>
                <button class="close-profile" onclick="closeProfile()"></button>
            </div>
            <div class="profile-content">
                <div class="profile-left-column">
                    <div class="profile-section">
                        <h3>Account Information</h3>
                        <div style="display: flex; flex-direction: column; gap: 12px; margin-top: 8px;">
                            <div class="profile-info">
                                <div class="profile-info-item">
                                    <span class="profile-info-label">Email</span>
                                    <span class="profile-info-value" id="profileEmail"></span>
                                </div>
                            </div>
                            <div class="profile-info editable">
                                <div class="profile-info-item">
                                    <span class="profile-info-label">Name</span>
                                    <input type="text" id="profileName" class="profile-editable-input" value="" placeholder="Enter your name">
                                </div>
                            </div>
                            <div class="profile-info editable">
                                <div class="profile-info-item">
                                    <span class="profile-info-label">Password</span>
                                    <div class="password-input-wrapper">
                                        <input type="password" id="profilePassword" class="profile-editable-input password-input" value="" readonly>
                                        <button type="button" id="togglePasswordBtn" class="password-toggle-btn" onclick="togglePasswordVisibility()">
                                            <svg id="eyeIcon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                                <circle cx="12" cy="12" r="3"></circle>
                                            </svg>
                                            <svg id="eyeOffIcon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
                                                <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
                                                <line x1="1" y1="1" x2="23" y2="23"></line>
                                            </svg>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e2e8f0;">
                            <button class="logout-btn" onclick="showLogoutConfirm()">Log out</button>
                        </div>
                    </div>
                </div>

                <div class="profile-right-column">
                    <div class="profile-section">
                        <h3>My Tags</h3>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <div style="display: flex; gap: 8px;">
                                <button id="viewFoldersBtn" class="view-btn active" onclick="setViewMode('folders')" title="View folders">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
                                    </svg>
                                </button>
                                <button id="viewTagsBtn" class="view-btn" onclick="setViewMode('tags')" title="View all tags">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
                                        <line x1="7" y1="7" x2="7.01" y2="7"></line>
                                    </svg>
                                </button>
                            </div>
                            <input type="text" id="tagsSearchInput" placeholder="Search tags..." style="flex: 1; max-width: 250px; height: 36px; padding: 8px 12px; border-radius: 8px; border: 2px solid #e2e8f0; background: #ffffff; font-size: 14px; transition: all 0.2s ease; margin: 0 8px; outline: none;" oninput="handleTagsSearch()" onfocus="this.style.borderColor='#3b82f6'; this.style.boxShadow='0 0 0 3px rgba(59, 130, 246, 0.1)'" onblur="this.style.borderColor='#e2e8f0'; this.style.boxShadow='none'">
                            <button id="sortOrderBtn" class="view-btn" onclick="toggleSortOrder()" title="Toggle sort order">
                                <svg id="sortAscIcon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M15 5h4"></path>
                                    <path d="M12 9h7"></path>
                                    <path d="M12 13h7"></path>
                                    <path d="M12 17h7"></path>
                                    <path d="M3 5l3-3 3 3"></path>
                                    <path d="M6 2v20"></path>
                                </svg>
                                <svg id="sortDescIcon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
                                    <path d="M12 5h7"></path>
                                    <path d="M12 9h7"></path>
                                    <path d="M12 13h7"></path>
                                    <path d="M15 17h4"></path>
                                    <path d="M3 19l3 3 3-3"></path>
                                    <path d="M6 22V2"></path>
                                </svg>
                            </button>
                            <button id="createTagFolderBtn" class="create-btn" onclick="showCreateMenu()" title="Create">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                    <line x1="12" y1="5" x2="12" y2="19"></line>
                                    <line x1="5" y1="12" x2="19" y2="12"></line>
                                </svg>
                            </button>
                        </div>
                        <div id="profileTagsList" class="tags-list" style="display: flex; gap: 16px; margin-bottom: 4px; flex: 1; min-height: 0; overflow: hidden; box-sizing: border-box; align-items: flex-start;">
                            <div id="foldersColumn" style="width: 200px; display: flex; flex-direction: column; gap: 8px; overflow-y: auto; padding-right: 8px; flex-shrink: 0; box-sizing: border-box; max-height: 332px;"></div>
                            <div id="tagsColumn" style="flex: 1; display: flex; flex-direction: column; gap: 8px; overflow-y: auto; padding: 12px; padding-bottom: 16px; background: #f8fafc; border-radius: 12px; border: 1px solid #e2e8f0; min-height: 0; box-sizing: border-box; height: 332px; max-height: 332px;"></div>
                            <div id="allTagsColumn" style="flex: 1; display: none; flex-direction: column; gap: 8px; overflow-y: auto; padding: 12px; padding-bottom: 16px; background: #f8fafc; border-radius: 12px; border: 1px solid #e2e8f0; min-height: 0; box-sizing: border-box; height: 332px; max-height: 332px;"></div>
                        </div>
                        <div class="new-folder-form" style="margin-bottom: 4px; margin-top: 0; display: none; flex-shrink: 0;" id="newFolderForm">
                            <input type="text" id="profileNewFolderName" placeholder="Folder name" style="flex: 1;">
                            <input type="color" id="profileNewFolderColor" value="#64748b" style="width: 60px; height: 44px; border-radius: 8px; cursor: pointer;">
                            <button type="button" onclick="createFolderFromProfile()" style="white-space: nowrap; background: #64748b; color: white;">Create Folder</button>
                        </div>
                        <div class="new-tag-form" style="margin-top: 0; margin-bottom: 0; display: none; flex-shrink: 0;" id="newTagForm">
                            <input type="text" id="profileNewTagName" placeholder="Tag name" maxlength="20" style="flex: 1;">
                            <input type="color" id="profileNewTagColor" value="#3b82f6" style="width: 60px; height: 44px; border-radius: 8px; cursor: pointer;">
                            <select id="profileNewTagFolder" style="flex: 1; max-width: 150px; padding: 8px; border-radius: 8px; border: 1px solid #e2e8f0;">
                                <option value="">No folder</option>
                            </select>
                            <button type="button" onclick="createTagFromProfile()" style="white-space: nowrap;">Add Tag</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Logout Confirmation Modal -->
    <div id="logoutConfirmOverlay" class="logout-confirm-overlay" onclick="closeLogoutConfirmOnOverlay(event)">
        <div class="logout-confirm-modal" onclick="event.stopPropagation()">
            <div class="logout-confirm-content">
                <h3>Are you sure you want to log out?</h3>
                <p>You will need to log in again to access your tasks.</p>
                <div class="logout-confirm-buttons">
                    <button class="logout-confirm-btn logout-confirm-yes" onclick="confirmLogout()">Yes, log out</button>
                    <button class="logout-confirm-btn logout-confirm-no" onclick="closeLogoutConfirm()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Tags Selection Modal -->
    <div id="tagsModalOverlay" class="task-modal-overlay" onclick="closeTagsModalOnOverlay(event)">
        <div class="task-modal" onclick="event.stopPropagation()">
            <div class="task-modal-header">
                <h2>Select Tags</h2>
                <button class="task-modal-close" onclick="closeTagsModal()"></button>
            </div>
            <div class="task-modal-content">
                <div class="profile-section" style="margin-bottom: 0; box-shadow: none; border: none; padding: 0; border-radius: 0; background: transparent;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <div style="display: flex; gap: 8px;">
                            <button id="tagsModalViewFoldersBtn" class="view-btn active" onclick="setTagsModalViewMode('folders')" title="View folders">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
                                </svg>
                            </button>
                            <button id="tagsModalViewTagsBtn" class="view-btn" onclick="setTagsModalViewMode('tags')" title="View all tags">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
                                    <line x1="7" y1="7" x2="7.01" y2="7"></line>
                                </svg>
                            </button>
                        </div>
                        <input type="text" id="tagsModalSearchInput" placeholder="Search tags..." style="flex: 1; max-width: 220px; height: 36px; padding: 8px 12px; border-radius: 8px; border: 2px solid #e2e8f0; background: #ffffff; font-size: 14px; transition: all 0.2s ease; margin: 0 8px; outline: none;" oninput="handleTagsModalSearch()" onfocus="this.style.borderColor='#3b82f6'; this.style.boxShadow='0 0 0 3px rgba(59, 130, 246, 0.1)'" onblur="this.style.borderColor='#e2e8f0'; this.style.boxShadow='none'">
                        <div style="display: flex; gap: 8px;">
                            <button id="tagsModalSortOrderBtn" class="view-btn" onclick="toggleTagsModalSortOrder()" title="Toggle sort order">
                                <svg id="tagsModalSortAscIcon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M15 5h4"></path>
                                    <path d="M12 9h7"></path>
                                    <path d="M12 13h7"></path>
                                    <path d="M12 17h7"></path>
                                    <path d="M3 5l3-3 3 3"></path>
                                    <path d="M6 2v20"></path>
                                </svg>
                                <svg id="tagsModalSortDescIcon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
                                    <path d="M12 5h7"></path>
                                    <path d="M12 9h7"></path>
                                    <path d="M12 13h7"></path>
                                    <path d="M15 17h4"></path>
                                    <path d="M3 19l3 3 3-3"></path>
                                    <path d="M6 22V2"></path>
                                </svg>
                            </button>
                            <button id="tagsModalCreateTagBtn" class="create-btn" onclick="openCreateTagModal()" title="Create new tag">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                    <line x1="12" y1="5" x2="12" y2="19"></line>
                                    <line x1="5" y1="12" x2="19" y2="12"></line>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div id="tagsModalTagsList" class="tags-list" style="display: flex; gap: 10px; margin-bottom: 0; flex: 1; min-height: 0; overflow: hidden; box-sizing: border-box; align-items: flex-start; height: 350px; max-height: 350px;">
                        <div id="tagsModalFoldersColumn" style="flex: 1; display: flex; flex-direction: column; gap: 6px; overflow-y: auto; padding-right: 6px; box-sizing: border-box; height: 350px; max-height: 350px; min-width: 0;"></div>
                        <div id="tagsModalTagsColumn" style="flex: 1; display: flex; flex-direction: column; gap: 6px; overflow-y: auto; padding: 10px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0; min-height: 0; box-sizing: border-box; height: 350px; max-height: 350px; min-width: 0;"></div>
                        <div id="tagsModalAllTagsColumn" style="flex: 1; display: none; flex-direction: column; gap: 6px; overflow-y: auto; padding: 10px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0; min-height: 0; box-sizing: border-box; height: 350px; max-height: 350px;"></div>
                    </div>
                </div>
                <div class="new-tag-form" style="margin-top: 10px; margin-bottom: 0; display: none; flex-shrink: 0;" id="tagsModalNewTagForm">
                    <input type="text" id="tagsModalNewTagName" placeholder="Tag name" maxlength="20" style="flex: 1;">
                    <input type="color" id="tagsModalNewTagColor" value="#3b82f6" style="width: 60px; height: 44px; border-radius: 8px; cursor: pointer;">
                    <select id="tagsModalNewTagFolder" style="flex: 1; max-width: 150px; padding: 8px; border-radius: 8px; border: 1px solid #e2e8f0;">
                        <option value="">No folder</option>
                    </select>
                    <button type="button" onclick="createTagFromTagsModal()" style="white-space: nowrap;">Add Tag</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Create Tag Modal -->
    <div id="createTagModalOverlay" class="task-modal-overlay" onclick="closeCreateTagModalOnOverlay(event)">
        <div class="task-modal" onclick="event.stopPropagation()">
            <div class="task-modal-header">
                <h2>Create Tag</h2>
                <button class="task-modal-close" onclick="closeCreateTagModal()"></button>
            </div>
            <div class="task-modal-content">
                <form id="createTagForm" onsubmit="handleCreateTagSubmit(event)">
                    <div style="display: flex; gap: 16px; align-items: flex-end; margin-bottom: 16px;">
                        <div style="flex: 0 1 auto; min-width: 200px; max-width: 250px; display: flex; flex-direction: column; gap: 4px;">
                            <label for="createTagName" style="font-size: 13px; font-weight: 500; color: #1e293b; margin: 0;">Title</label>
                            <input type="text" id="createTagName" required maxlength="20" placeholder="Enter tag name" style="height: 36px; padding: 8px 12px; border-radius: 8px; border: 2px solid #e2e8f0; background: #ffffff; font-size: 14px; outline: none; transition: all 0.2s ease; width: 100%; box-sizing: border-box;" onfocus="this.style.borderColor='#3b82f6'; this.style.boxShadow='0 0 0 3px rgba(59, 130, 246, 0.1)'" onblur="this.style.borderColor='#e2e8f0'; this.style.boxShadow='none'">
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 4px; align-items: center;">
                            <label for="createTagColorBtn" style="font-size: 13px; font-weight: 500; color: #1e293b; margin: 0; text-align: center;">Color</label>
                            <button type="button" id="createTagColorBtn" class="view-btn" title="Select color" onclick="showCreateTagColorMenu(event)" style="width: 50px; height: 36px;">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path>
                                    <line x1="7" y1="7" x2="7.01" y2="7"></line>
                                </svg>
                            </button>
                        </div>
                        <input type="hidden" id="createTagColor" value="#3b82f6">
                        <div style="display: flex; flex-direction: column; gap: 4px; align-items: center;">
                            <label for="createTagFolderBtn" style="font-size: 13px; font-weight: 500; color: #1e293b; margin: 0; text-align: center;">Folder</label>
                            <button type="button" id="createTagFolderBtn" class="view-btn" title="Select folder" onclick="showCreateTagFolderMenu(event)" style="width: 50px; height: 36px;">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
                                </svg>
                            </button>
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 4px; align-items: center;">
                            <label for="createTagPinnedBtn" style="font-size: 13px; font-weight: 500; color: #1e293b; margin: 0; text-align: center;">Pin</label>
                            <button type="button" id="createTagPinnedBtn" class="view-btn" title="Pin to top" onclick="toggleCreateTagPin()" style="width: 50px; height: 36px;">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="5" r="3"></circle>
                                    <line x1="12" y1="22" x2="12" y2="8"></line>
                                    <path d="M5 12H2a10 10 0 0 0 20 0h-3"></path>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div style="display: flex; gap: 12px; justify-content: flex-end; margin-top: 0;">
                        <button type="button" onclick="closeCreateTagModal()" style="background: #f1f5f9; color: #475569; border: 1px solid #e2e8f0; padding: 8px 16px; border-radius: 6px; font-size: 13px; font-weight: 500; cursor: pointer;">Cancel</button>
                        <button type="submit" style="background: #3b82f6; color: white; border: none; padding: 8px 16px; border-radius: 6px; font-size: 13px; font-weight: 500; cursor: pointer;">Create Tag</button>
                    </div>
                    <input type="hidden" id="createTagFolderHidden" value="">
                    <input type="hidden" id="createTagPinnedHidden" value="false">
                </form>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div id="contextMenu" class="context-menu" style="display: none;" onclick="event.stopPropagation()">
        <div id="contextMenuOptions" style="display: flex; flex-direction: column; gap: 4px;">
            <div class="context-menu-item" onclick="handleContextMenuPin()">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="5" r="3"></circle>
                    <line x1="12" y1="22" x2="12" y2="8"></line>
                    <path d="M5 12H2a10 10 0 0 0 20 0h-3"></path>
                </svg>
                <span>Pin</span>
            </div>
            <div class="context-menu-item" onclick="handleContextMenuEdit()">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                </svg>
                <span>Edit</span>
            </div>
            <div class="context-menu-item context-menu-item-danger" onclick="handleContextMenuDelete()">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="3 6 5 6 21 6"></polyline>
                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                </svg>
                <span>Delete</span>
            </div>
        </div>
        <div id="contextMenuConfirm" class="context-menu-confirm">
            <div class="context-menu-confirm-title" id="contextMenuConfirmTitle">Are you sure?</div>
            <div class="context-menu-confirm-buttons">
                <button class="context-menu-btn context-menu-btn-cancel" onclick="cancelContextMenuDelete()">Cancel</button>
                <button class="context-menu-btn context-menu-btn-delete" onclick="confirmContextMenuDelete()">Delete</button>
            </div>
        </div>
    </div>

    <script>
        const API_URL = '/api/tasks';
        const AUTH_URL = '/api/auth';
        const TAGS_URL = '/api/tags';
        const FOLDERS_URL = '/api/folders';
        const UPLOAD_URL = '/api/upload';
        let tasks = [];
        let tags = [];
        let folders = [];
        let viewMode = 'folders'; // 'folders' or 'tags'
        let selectedFolderId = null; // Currently selected folder
        let tagsSearchTerm = ''; // Search term for filtering tags
        let tagsSortOrder = 'asc'; // 'asc' for ascending (A-Z), 'desc' for descending (Z-A)
        // Tags modal state
        let tagsModalViewMode = 'folders'; // 'folders' or 'tags'
        let tagsModalSelectedFolderId = null; // Currently selected folder in modal
        let tagsModalSearchTerm = ''; // Search term for filtering tags in modal
        let tagsModalSortOrder = 'asc'; // 'asc' for ascending (A-Z), 'desc' for descending (Z-A)
        let selectedTagsForTask = []; // Array of tag IDs selected for the current task (max 3)
        let tagsModalOpened = false; // Flag to track if tags modal has been opened
        let token = localStorage.getItem('token');
        let userName = localStorage.getItem('userName') || '';
        let userEmail = localStorage.getItem('userEmail') || '';
        let currentTaskImage = null;
        let currentFilter = 'pending'; // 'pending', 'completed', 'all'
        let searchQuery = ''; // Current search query

        // Check if user is logged in
        if (token) {
            userName = localStorage.getItem('userName') || '';
            userEmail = localStorage.getItem('userEmail') || '';
            showApp().catch(error => {
                console.error('Error initializing app:', error);
                showAuth();
            });
        } else {
            showAuth();
        }

        function showAuth() {
            document.getElementById('authScreen').style.display = 'flex';
            document.getElementById('appScreen').style.display = 'none';
        }

        // Calendar state
        let currentCalendarDate = new Date();

        async function showApp() {
            document.getElementById('authScreen').style.display = 'none';
            document.getElementById('appScreen').style.display = 'flex';
            updateUserDisplay();
            // Load tasks, tags and folders in parallel, but wait for all to complete
            try {
                await Promise.all([loadTasks(), loadTags(), loadFolders()]);
                updateTagSelect();
                renderCalendar();
            } catch (error) {
                console.error('Error loading app data:', error);
                showMessage('Error loading data', 'error');
            }
        }

        // Task Modal Functions
        function openTaskModal() {
            const modal = document.getElementById('taskModalOverlay');
            if (modal) {
                modal.classList.add('active');
                // Focus on title input
                setTimeout(() => {
                    const titleInput = document.getElementById('taskTitle');
                    if (titleInput) {
                        titleInput.focus();
                    }
                }, 100);
            }
        }

        function closeTaskModal() {
            const modal = document.getElementById('taskModalOverlay');
            if (modal) {
                modal.classList.remove('active');
            }
        }

        function closeTaskModalOnOverlay(event) {
            if (event.target.id === 'taskModalOverlay') {
                closeTaskModal();
            }
        }

        function resetTaskForm() {
            document.getElementById('taskForm').reset();
            removeTaskImage();
            // Clear tag selections
            document.querySelectorAll('#taskTags .tag-checkbox-item').forEach(item => {
                item.classList.remove('selected');
            });
            // Clear selected tags from modal
            selectedTagsForTask = [];
            tagsModalOpened = false; // Reset modal opened flag
            updateTagSelect();
            // Re-render tags modal if it's open
            const tagsModal = document.getElementById('tagsModalOverlay');
            if (tagsModal && tagsModal.classList.contains('active')) {
                renderTagsModal();
            }
            document.getElementById('taskTitle').focus();
        }

        // Calendar Functions
        function renderCalendar() {
            const container = document.getElementById('calendarContainer');
            if (!container) return;

            const year = currentCalendarDate.getFullYear();
            const month = currentCalendarDate.getMonth();

            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const daysInMonth = lastDay.getDate();
            const startingDayOfWeek = firstDay.getDay();

            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
            const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

            let html = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                    <button onclick="previousMonth()" style="padding: 6px 12px; background: #f1f5f9; border: 1px solid #e2e8f0; border-radius: 6px; cursor: pointer; font-size: 14px;"></button>
                    <h3 style="margin: 0; font-size: 16px; font-weight: 600; color: #0f172a;">${monthNames[month]} ${year}</h3>
                    <button onclick="nextMonth()" style="padding: 6px 12px; background: #f1f5f9; border: 1px solid #e2e8f0; border-radius: 6px; cursor: pointer; font-size: 14px;"></button>
                </div>
                <div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 4px; margin-bottom: 8px;">
            `;

            // Day names header
            dayNames.forEach(day => {
                html += `<div style="text-align: center; font-size: 12px; font-weight: 600; color: #64748b; padding: 8px;">${day}</div>`;
            });

            html += `</div><div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 4px;">`;

            // Empty cells for days before month starts
            for (let i = 0; i < startingDayOfWeek; i++) {
                html += `<div style="aspect-ratio: 1; background: #f8fafc; border-radius: 6px;"></div>`;
            }

            // Days of the month
            for (let day = 1; day <= daysInMonth; day++) {
                html += `<div style="aspect-ratio: 1; background: #ffffff; border: 1px solid #e2e8f0; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-size: 13px; color: #1e293b; cursor: pointer; transition: all 0.2s ease;" onmouseover="this.style.background='#f8fafc'; this.style.borderColor='#cbd5e1'" onmouseout="this.style.background='#ffffff'; this.style.borderColor='#e2e8f0'">${day}</div>`;
            }

            html += `</div>`;
            container.innerHTML = html;
        }

        function previousMonth() {
            currentCalendarDate.setMonth(currentCalendarDate.getMonth() - 1);
            renderCalendar();
        }

        function nextMonth() {
            currentCalendarDate.setMonth(currentCalendarDate.getMonth() + 1);
            renderCalendar();
        }

        function updateUserDisplay() {
            const displayText = userName ? `${userName} (${userEmail})` : userEmail;
            const userEmailEl = document.getElementById('userEmail');
            if (userEmailEl) {
                userEmailEl.textContent = displayText;
            }
            
            // Update profile window
            const profileInitial = document.getElementById('profileInitial');
            const profileWindowName = document.getElementById('profileWindowName');
            const profileWindowEmail = document.getElementById('profileWindowEmail');
            
            if (profileInitial) {
                const initial = userName ? userName.charAt(0).toUpperCase() : (userEmail ? userEmail.charAt(0).toUpperCase() : 'U');
                profileInitial.textContent = initial;
            }
            if (profileWindowName) {
                profileWindowName.textContent = userName || 'User';
            }
            if (profileWindowEmail) {
                profileWindowEmail.textContent = userEmail || '';
            }
        }

        function showMessage(text, type) {
            const msg = document.getElementById('message');
            msg.textContent = text;
            msg.className = `message ${type}`;
            msg.style.display = 'block';
            setTimeout(() => {
                msg.textContent = '';
                msg.style.display = 'none';
            }, 3000);
        }

        function getAuthHeaders() {
            return {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            };
        }

        function showLogin() {
            document.querySelectorAll('.auth-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.auth-form').forEach(form => form.classList.remove('active'));
            document.querySelector('.auth-tab').classList.add('active');
            document.getElementById('loginForm').classList.add('active');
        }

        function showRegister() {
            document.querySelectorAll('.auth-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.auth-form').forEach(form => form.classList.remove('active'));
            document.querySelectorAll('.auth-tab')[1].classList.add('active');
            document.getElementById('registerForm').classList.add('active');
        }

        // Login
        document.getElementById('loginForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const email = document.getElementById('loginEmail').value.trim();
            const password = document.getElementById('loginPassword').value.trim();

            try {
                const res = await fetch(`${AUTH_URL}/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email, password })
                });

                const data = await res.json();
                if (!res.ok) {
                    showMessage(data.message || 'Login failed', 'error');
                    return;
                }

                token = data.token;
                userName = data.name || '';
                userEmail = data.email;
                // Store plain password if available (from login response)
                if (data.passwordPlain) {
                    localStorage.setItem('userPasswordPlain', data.passwordPlain);
                }
                localStorage.setItem('token', token);
                localStorage.setItem('userName', userName);
                localStorage.setItem('userEmail', userEmail);
                showMessage('Login successful', 'success');
                await showApp();
            } catch (error) {
                showMessage('Error logging in', 'error');
            }
        });

        // Register
        document.getElementById('registerForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const name = document.getElementById('registerName').value.trim();
            const email = document.getElementById('registerEmail').value.trim();
            const password = document.getElementById('registerPassword').value.trim();

            if (!name) {
                showMessage('Name is required', 'error');
                return;
            }

            try {
                const res = await fetch(`${AUTH_URL}/register`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, email, password })
                });

                const data = await res.json();
                if (!res.ok) {
                    showMessage(data.message || 'Registration failed', 'error');
                    return;
                }

                showMessage('Registration successful! Please login.', 'success');
                showLogin();
                document.getElementById('loginEmail').value = email;
            } catch (error) {
                showMessage('Error registering', 'error');
            }
        });

        let passwordVisible = false;
        let userPasswordPlain = '';
        const PASSWORD_PLACEHOLDER = '';

        async function loadUserPassword() {
            try {
                const res = await fetch(`${AUTH_URL}/password`, {
                    headers: getAuthHeaders()
                });
                
                if (res.status === 401) {
                    logout();
                    return;
                }
                
                if (res.ok) {
                    const data = await res.json();
                    userPasswordPlain = data.passwordPlain || '';
                }
            } catch (error) {
                console.error('Error loading password:', error);
            }
        }

        function openProfile() {
            const overlay = document.getElementById('profileOverlay');
            overlay.classList.add('active');
            document.getElementById('profileEmail').textContent = userEmail;
            document.getElementById('profileName').value = userName || '';
            
            // Try to get password from localStorage first, then from API
            userPasswordPlain = localStorage.getItem('userPasswordPlain') || '';
            loadUserPassword(); // Also load from API in case it's updated
            
            const passwordInput = document.getElementById('profilePassword');
            passwordInput.value = PASSWORD_PLACEHOLDER;
            passwordInput.type = 'password';
            passwordInput.readOnly = true;
            passwordInput.style.color = '#1e293b';
            passwordInput.style.letterSpacing = 'normal';
            passwordInput.style.cursor = 'default';
            passwordInput.style.pointerEvents = 'none';
            passwordVisible = false;
            document.getElementById('eyeIcon').style.display = 'block';
            document.getElementById('eyeOffIcon').style.display = 'none';
            loadTags(); // Refresh tags in profile
            loadFolders(); // Refresh folders in profile
            
            // Setup name input with debounce
            setupNameInput();
        }

        function togglePasswordVisibility() {
            const passwordInput = document.getElementById('profilePassword');
            const eyeIcon = document.getElementById('eyeIcon');
            const eyeOffIcon = document.getElementById('eyeOffIcon');
            
            if (passwordVisible) {
                // Ocultar contrasea - guardar cambios si se edit
                const currentValue = passwordInput.value;
                if (currentValue !== PASSWORD_PLACEHOLDER && currentValue !== userPasswordPlain) {
                    // La contrasea fue editada, actualizarla
                    updatePasswordFromProfile(currentValue);
                }
                
                passwordInput.type = 'password';
                passwordInput.value = PASSWORD_PLACEHOLDER;
                passwordInput.readOnly = true;
                passwordInput.style.color = '#1e293b';
                passwordInput.style.letterSpacing = 'normal';
                passwordInput.style.cursor = 'default';
                passwordInput.style.pointerEvents = 'none';
                eyeIcon.style.display = 'block';
                eyeOffIcon.style.display = 'none';
                passwordInput.title = '';
                passwordVisible = false;
            } else {
                // Mostrar contrasea real - permitir edicin
                const passwordToShow = userPasswordPlain || PASSWORD_PLACEHOLDER;
                passwordInput.type = 'text';
                passwordInput.value = passwordToShow;
                passwordInput.readOnly = false;
                passwordInput.style.color = '#1e293b';
                passwordInput.style.letterSpacing = 'normal';
                passwordInput.style.cursor = 'text';
                passwordInput.style.pointerEvents = 'auto';
                eyeIcon.style.display = 'none';
                eyeOffIcon.style.display = 'block';
                passwordInput.title = 'Click to edit password';
                passwordVisible = true;
            }
        }

        async function updatePasswordFromProfile(newPassword) {
            if (!newPassword || newPassword.trim().length === 0) {
                showMessage('Password cannot be empty', 'error');
                return;
            }

            if (newPassword.length < 6) {
                showMessage('Password must be at least 6 characters', 'error');
                return;
            }

            try {
                // Primero verificar la contrasea actual (necesitamos la actual para cambiarla)
                // Como no tenemos la contrasea actual hasheada, vamos a usar un enfoque diferente:
                // Usar el endpoint de cambio de contrasea con la contrasea actual
                const currentPassword = userPasswordPlain || '';
                
                const res = await fetch(`${AUTH_URL}/change-password`, {
                    method: 'PUT',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ 
                        currentPassword: currentPassword,
                        newPassword: newPassword 
                    })
                });

                if (res.status === 401) {
                    logout();
                    return;
                }

                const data = await res.json();
                if (!res.ok) {
                    showMessage(data.message || 'Error updating password', 'error');
                    // Revertir el valor
                    document.getElementById('profilePassword').value = userPasswordPlain || PASSWORD_PLACEHOLDER;
                    return;
                }

                // Actualizar la contrasea almacenada
                userPasswordPlain = newPassword;
                localStorage.setItem('userPasswordPlain', newPassword);
                
                showMessage('Password updated successfully', 'success');
            } catch (error) {
                console.error('Error updating password:', error);
                showMessage('Error updating password', 'error');
                // Revertir el valor
                document.getElementById('profilePassword').value = userPasswordPlain || PASSWORD_PLACEHOLDER;
            }
        }

        function setupNameInput() {
            const nameInput = document.getElementById('profileName');
            let timeout;
            
            nameInput.addEventListener('input', () => {
                clearTimeout(timeout);
                timeout = setTimeout(async () => {
                    const newName = nameInput.value.trim();
                    if (newName && newName !== userName) {
                        await updateUserName(newName);
                    }
                }, 1000); // Wait 1 second after user stops typing
            });
            
            nameInput.addEventListener('blur', async () => {
                clearTimeout(timeout);
                const newName = nameInput.value.trim();
                if (newName && newName !== userName) {
                    await updateUserName(newName);
                } else if (!newName) {
                    nameInput.value = userName || ''; // Reset if empty
                }
            });
        }

        async function updateUserName(newName) {
            if (!newName) return;
            
            try {
                const res = await fetch(`${AUTH_URL}/update-name`, {
                    method: 'PUT',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ name: newName })
                });

                if (res.status === 401) {
                    logout();
                    return;
                }

                const data = await res.json();
                if (!res.ok) {
                    showMessage(data.message || 'Error updating name', 'error');
                    document.getElementById('profileName').value = userName || ''; // Revert on error
                    return;
                }

                userName = data.name;
                localStorage.setItem('userName', userName);
                updateUserDisplay();
                showMessage('Name updated', 'success');
            } catch (error) {
                showMessage('Error updating name', 'error');
                document.getElementById('profileName').value = userName || ''; // Revert on error
            }
        }

        function closeProfile() {
            const overlay = document.getElementById('profileOverlay');
            overlay.classList.remove('active');
        }

        function closeProfileOnOverlay(event) {
            if (event.target === event.currentTarget) {
                closeProfile();
            }
        }

        function showLogoutConfirm() {
            const overlay = document.getElementById('logoutConfirmOverlay');
            overlay.classList.add('active');
        }

        function closeLogoutConfirm() {
            const overlay = document.getElementById('logoutConfirmOverlay');
            overlay.classList.remove('active');
        }

        function closeLogoutConfirmOnOverlay(event) {
            if (event.target === event.currentTarget) {
                closeLogoutConfirm();
            }
        }

        function confirmLogout() {
            closeLogoutConfirm();
            logout();
        }

        function logout() {
            token = null;
            userName = null;
            userEmail = null;
            localStorage.removeItem('token');
            localStorage.removeItem('userName');
            localStorage.removeItem('userEmail');
            localStorage.removeItem('userPasswordPlain');
            closeProfile();
            showAuth();
        }

        function showCreateMenu() {
            // For now, just toggle the forms (design only)
            const folderForm = document.getElementById('newFolderForm');
            const tagForm = document.getElementById('newTagForm');
            
            if (folderForm.style.display === 'none' || folderForm.style.display === '') {
                folderForm.style.display = 'flex';
                tagForm.style.display = 'flex';
            } else {
                folderForm.style.display = 'none';
                tagForm.style.display = 'none';
            }
        }

        function toggleFolder(folderId) {
            const folderTags = document.getElementById(folderId);
            if (folderTags.style.display === 'none' || folderTags.style.display === '') {
                folderTags.style.display = 'block';
            } else {
                folderTags.style.display = 'none';
            }
        }

        async function createFolderFromProfile() {
            const name = document.getElementById('profileNewFolderName').value.trim();
            const color = document.getElementById('profileNewFolderColor').value;

            if (!name) {
                showMessage('Folder name is required', 'error');
                return;
            }

            try {
                const res = await fetch(FOLDERS_URL, {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ name, color })
                });

                if (res.status === 401) {
                    logout();
                    return;
                }

                const data = await res.json();
                if (!res.ok) {
                    showMessage(data.message || 'Error creating folder', 'error');
                    return;
                }

                showMessage('Folder created', 'success');
                document.getElementById('profileNewFolderName').value = '';
                document.getElementById('newFolderForm').style.display = 'none';
                await loadFolders();
            } catch (error) {
                showMessage('Error creating folder', 'error');
            }
        }

        async function createTagFromProfile() {
            const name = document.getElementById('profileNewTagName').value.trim();
            const color = document.getElementById('profileNewTagColor').value;
            const folderId = document.getElementById('profileNewTagFolder').value || null;

            if (!name) {
                showMessage('Tag name is required', 'error');
                return;
            }

            if (name.length > 20) {
                showMessage('Tag name must be 20 characters or less', 'error');
                return;
            }

            try {
                const res = await fetch(TAGS_URL, {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ name, color, folderId: folderId ? parseInt(folderId) : null })
                });

                if (res.status === 401) {
                    logout();
                    return;
                }

                const data = await res.json();
                if (!res.ok) {
                    showMessage(data.message || 'Error creating tag', 'error');
                    return;
                }

                showMessage('Tag created', 'success');
                document.getElementById('profileNewTagName').value = '';
                document.getElementById('newTagForm').style.display = 'none';
                await loadTags();
            } catch (error) {
                showMessage('Error creating tag', 'error');
            }
        }

        // Change Password form removed (password can be edited inline when visible)

        // Tags Management
        async function loadFolders() {
            try {
                const res = await fetch(FOLDERS_URL, {
                    headers: getAuthHeaders()
                });
                
                if (res.status === 401) {
                    logout();
                    return;
                }
                
                folders = await res.json();
                updateFolderSelect();
                renderTags();
                // Update tags modal if it's open
                const tagsModal = document.getElementById('tagsModalOverlay');
                if (tagsModal && tagsModal.classList.contains('active')) {
                    renderTagsModal();
                }
            } catch (error) {
                showMessage('Error loading folders', 'error');
            }
        }

        async function loadTags() {
            try {
                const res = await fetch(TAGS_URL, {
                    headers: getAuthHeaders()
                });
                
                if (res.status === 401) {
                    logout();
                    return;
                }
                
                tags = await res.json();
                renderTags();
                updateTagSelect();
                // Update tags modal if it's open
                const tagsModal = document.getElementById('tagsModalOverlay');
                if (tagsModal && tagsModal.classList.contains('active')) {
                    renderTagsModal();
                }
            } catch (error) {
                showMessage('Error loading tags', 'error');
            }
        }

        function updateFolderSelect() {
            const select = document.getElementById('profileNewTagFolder');
            const currentValue = select.value;
            select.innerHTML = '<option value="">No folder</option>';
            folders.forEach(folder => {
                const option = document.createElement('option');
                option.value = folder.id;
                option.textContent = escapeHtml(folder.name.toUpperCase());
                select.appendChild(option);
            });
            if (currentValue) {
                select.value = currentValue;
            }
        }

        function setViewMode(mode) {
            viewMode = mode;
            
            // Reset selected folder when switching to tags view
            if (mode === 'tags') {
                selectedFolderId = null;
            }
            
            // Update button states
            document.getElementById('viewFoldersBtn').classList.toggle('active', mode === 'folders');
            document.getElementById('viewTagsBtn').classList.toggle('active', mode === 'tags');
            
            // Re-render
            renderTags();
        }

        function renderTags() {
            // Render in profile modal
            const foldersColumn = document.getElementById('foldersColumn');
            const tagsColumn = document.getElementById('tagsColumn');
            const allTagsColumn = document.getElementById('allTagsColumn');
            
            if (!foldersColumn || !tagsColumn || !allTagsColumn) {
                return;
            }
            
            // Update sort button icon
            updateSortButtonIcon();
            
            if (viewMode === 'tags') {
                // Show all tags in a flat list
                // Hide folders column and tags column, show allTagsColumn
                foldersColumn.style.display = 'none';
                tagsColumn.style.display = 'none';
                allTagsColumn.style.display = 'flex';
                
                if (tags.length === 0) {
                    allTagsColumn.innerHTML = '<div style="color: #94a3b8; font-size: 14px; padding: 20px; text-align: center;">No tags yet. Create your first tag below!</div>';
                    return;
                }

                let html = '';
                // Filter and sort tags alphabetically
                let filteredTags = tags;
                if (tagsSearchTerm.trim()) {
                    const searchLower = tagsSearchTerm.toLowerCase().trim();
                    filteredTags = tags.filter(tag => tag.name.toLowerCase().includes(searchLower));
                }
                const sortedTags = [...filteredTags].sort((a, b) => {
                    const comparison = a.name.localeCompare(b.name);
                    return tagsSortOrder === 'asc' ? comparison : -comparison;
                });
                
                if (sortedTags.length === 0) {
                    allTagsColumn.innerHTML = '<div style="color: #94a3b8; font-size: 14px; padding: 20px; text-align: center;">No tags found</div>';
                    return;
                }
                
                sortedTags.forEach((tag, index) => {
                    const folder = folders.find(f => f.id === tag.folderId);
                    const isLast = index === sortedTags.length - 1;
                    html += `
                        <div class="tag-item" data-tag-id="${tag.id}" style="display: flex; align-items: center; gap: 10px; padding: 8px; background: #ffffff; border-radius: 6px; margin-bottom: ${isLast ? '0' : '6px'}; transition: background 0.2s ease;">
                            <div style="width: 12px; height: 12px; border-radius: 50%; background-color: ${tag.color || '#3b82f6'}; flex-shrink: 0;"></div>
                            <span style="flex: 1; color: #1e293b; font-size: 14px;">${escapeHtml(tag.name)}</span>
                            ${folder ? `<span onclick="navigateToFolder(${folder.id})" style="font-size: 12px; color: ${folder.color || '#64748b'}; padding: 2px 8px; background: ${folder.color || '#64748b'}20; border-radius: 4px; border: 1px solid ${folder.color || '#64748b'}; cursor: pointer; transition: all 0.2s ease;" onmouseover="this.style.color='${folder.color || '#64748b'}'; this.style.borderColor='${folder.color || '#64748b'}'; this.style.filter='brightness(1.2) saturate(1.3)'" onmouseout="this.style.color='${folder.color || '#64748b'}'; this.style.borderColor='${folder.color || '#64748b'}'; this.style.filter='none'">${escapeHtml(folder.name.toUpperCase())}</span>` : ''}
                        </div>
                    `;
                });
                allTagsColumn.innerHTML = html;
                
                // Setup context menu for tags in All Tags view
                setupTagContextMenu();
                
                return;
            }
            
            // View mode: folders
            // Show folders column and tags column, hide allTagsColumn
            foldersColumn.style.display = 'flex';
            tagsColumn.style.display = 'flex';
            allTagsColumn.style.display = 'none';
            
            if (tags.length === 0 && folders.length === 0) {
                foldersColumn.innerHTML = '';
                tagsColumn.innerHTML = '<div style="color: #94a3b8; font-size: 14px; padding: 20px; text-align: center;">No tags or folders yet. Create your first folder or tag below!</div>';
                return;
            }

            // Render folders in left column
            // Include "TAGS WITHOUT FOLDER" as a virtual folder in the sorting
            const tagsWithoutFolder = tags.filter(tag => !tag.folderId);
            const allFoldersForSorting = [...folders];
            
            // Add virtual folder for tags without folder if there are any
            if (tagsWithoutFolder.length > 0) {
                allFoldersForSorting.push({
                    id: 'none',
                    name: 'TAGS WITHOUT FOLDER',
                    color: '#000000',
                    userId: null
                });
            }
            
            // Sort folders by number of tags (descending), then alphabetically
            const sortedFolders = allFoldersForSorting.sort((a, b) => {
                const aTagsCount = a.id === 'none' 
                    ? tagsWithoutFolder.length 
                    : tags.filter(tag => tag.folderId === a.id).length;
                const bTagsCount = b.id === 'none' 
                    ? tagsWithoutFolder.length 
                    : tags.filter(tag => tag.folderId === b.id).length;
                
                // First sort by number of tags (descending)
                if (aTagsCount !== bTagsCount) {
                    return bTagsCount - aTagsCount;
                }
                
                // If equal, sort alphabetically
                return a.name.localeCompare(b.name);
            });
            
            let foldersHtml = '';
            sortedFolders.forEach(folder => {
                const isNoneFolder = folder.id === 'none';
                const folderTags = isNoneFolder 
                    ? tagsWithoutFolder 
                    : tags.filter(tag => tag.folderId === folder.id).sort((a, b) => a.name.localeCompare(b.name));
                const folderColor = folder.color || '#64748b';
                const isSelected = isNoneFolder ? selectedFolderId === 'none' : selectedFolderId === folder.id;
                
                foldersHtml += `
                    <div class="folder-item" data-folder-id="${folder.id}" onclick="selectFolder(${isNoneFolder ? "'none'" : folder.id})" style="
                        padding: 10px 12px;
                        background: ${isSelected ? folderColor + '25' : folderColor + '15'};
                        border-radius: 8px;
                        border-left: 4px solid ${folderColor};
                        border-right: 2px solid ${isSelected ? folderColor : '#e2e8f0'};
                        border-top: 2px solid ${isSelected ? folderColor : '#e2e8f0'};
                        border-bottom: 2px solid ${isSelected ? folderColor : '#e2e8f0'};
                        cursor: pointer;
                        transition: all 0.2s ease;
                        width: 100%;
                        box-sizing: border-box;
                        height: 60px;
                        display: flex;
                        flex-direction: column;
                        justify-content: center;
                        position: relative;
                    ">
                        <div style="font-weight: 600; color: ${folderColor}; font-size: 14px; margin-bottom: 2px; word-wrap: break-word; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${escapeHtml(folder.name.toUpperCase())}</div>
                        <div style="font-size: 11px; color: #64748b; font-weight: 500;">${folderTags.length} ${folderTags.length === 1 ? 'tag' : 'tags'}</div>
                    </div>
                `;
            });
            
            foldersColumn.innerHTML = foldersHtml;
            
            // Setup drag and drop event listeners for folders
            setupDragAndDrop();
            
            // Setup context menu for folders
            setupFolderContextMenu();
            
            // Render tags in right column based on selection
            let tagsHtml = '';
            if (selectedFolderId === null) {
                tagsColumn.innerHTML = '<div style="color: #94a3b8; font-size: 14px; padding: 20px; text-align: center;">Select a folder to view its tags</div>';
            } else if (selectedFolderId === 'none') {
                // Show tags without folder
                let filteredTagsWithoutFolder = tagsWithoutFolder;
                if (tagsSearchTerm.trim()) {
                    const searchLower = tagsSearchTerm.toLowerCase().trim();
                    filteredTagsWithoutFolder = tagsWithoutFolder.filter(tag => tag.name.toLowerCase().includes(searchLower));
                }
                
                if (filteredTagsWithoutFolder.length === 0) {
                    tagsColumn.innerHTML = '<div style="color: #94a3b8; font-size: 14px; padding: 20px; text-align: center;">' + (tagsSearchTerm.trim() ? 'No tags found' : 'NO TAGS WITHOUT FOLDER') + '</div>';
                } else {
                    // Sort filtered tags alphabetically
                    const sortedTagsWithoutFolder = [...filteredTagsWithoutFolder].sort((a, b) => {
                        const comparison = a.name.localeCompare(b.name);
                        return tagsSortOrder === 'asc' ? comparison : -comparison;
                    });
                        sortedTagsWithoutFolder.forEach((tag, index) => {
                        const isLast = index === sortedTagsWithoutFolder.length - 1;
                        tagsHtml += `
                            <div class="tag-item" draggable="true" data-tag-id="${tag.id}" style="display: flex; align-items: center; gap: 10px; padding: 8px; background: #ffffff; border-radius: 6px; margin-bottom: ${isLast ? '0' : '6px'}; transition: background 0.2s ease;">
                                <div style="width: 12px; height: 12px; border-radius: 50%; background-color: ${tag.color || '#3b82f6'}; flex-shrink: 0;"></div>
                                <span style="flex: 1; color: #1e293b; font-size: 14px;">${escapeHtml(tag.name)}</span>
                            </div>
                        `;
                    });
                    tagsColumn.innerHTML = tagsHtml;
                }
            } else {
                // Show tags from selected folder
                const selectedFolder = folders.find(f => f.id === selectedFolderId);
                if (selectedFolder) {
                    let folderTags = tags.filter(tag => tag.folderId === selectedFolderId);
                    // Apply search filter
                    if (tagsSearchTerm.trim()) {
                        const searchLower = tagsSearchTerm.toLowerCase().trim();
                        folderTags = folderTags.filter(tag => tag.name.toLowerCase().includes(searchLower));
                    }
                    
                    if (folderTags.length === 0) {
                        tagsColumn.innerHTML = '<div style="color: #94a3b8; font-size: 14px; padding: 20px; text-align: center;">' + (tagsSearchTerm.trim() ? 'No tags found' : 'This folder is empty') + '</div>';
                    } else {
                        // Sort filtered tags alphabetically
                        const sortedFolderTags = [...folderTags].sort((a, b) => {
                            const comparison = a.name.localeCompare(b.name);
                            return tagsSortOrder === 'asc' ? comparison : -comparison;
                        });
                        sortedFolderTags.forEach((tag, index) => {
                            const isLast = index === sortedFolderTags.length - 1;
                            tagsHtml += `
                                <div class="tag-item" draggable="true" data-tag-id="${tag.id}" style="display: flex; align-items: center; gap: 10px; padding: 8px; background: #ffffff; border-radius: 6px; margin-bottom: ${isLast ? '0' : '6px'}; transition: background 0.2s ease;">
                                    <div style="width: 12px; height: 12px; border-radius: 50%; background-color: ${tag.color || '#3b82f6'}; flex-shrink: 0;"></div>
                                    <span style="flex: 1; color: #1e293b; font-size: 14px;">${escapeHtml(tag.name)}</span>
                                </div>
                            `;
                        });
                        tagsColumn.innerHTML = tagsHtml;
                    }
                }
            }
            
            // Setup drag and drop event listeners for tags
            setupTagDragListeners();
            
            // Setup context menu for tags
            setupTagContextMenu();
        }

        function setupDragAndDrop() {
            const folderItems = document.querySelectorAll('.folder-item[data-folder-id]');
            folderItems.forEach(folderItem => {
                folderItem.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    folderItem.style.opacity = '0.7';
                    folderItem.style.transform = 'scale(1.02)';
                });
                
                folderItem.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    folderItem.style.opacity = '1';
                    folderItem.style.transform = 'scale(1)';
                });
                
                folderItem.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    folderItem.style.opacity = '1';
                    folderItem.style.transform = 'scale(1)';
                    
                    const tagId = e.dataTransfer.getData('text/plain');
                    if (!tagId) return;
                    
                    const targetFolderId = folderItem.getAttribute('data-folder-id');
                    const newFolderId = targetFolderId === 'none' ? null : parseInt(targetFolderId);
                    
                    await moveTagToFolder(parseInt(tagId), newFolderId);
                });
            });
        }

        function setupTagDragListeners() {
            const tagItems = document.querySelectorAll('.tag-item[data-tag-id]');
            tagItems.forEach(tagItem => {
                // Track if right mouse button is pressed
                let isRightClick = false;
                let rightClickTimeout = null;
                
                tagItem.addEventListener('mousedown', (e) => {
                    if (e.button === 2) {
                        isRightClick = true;
                        // Temporarily disable draggable
                        tagItem.setAttribute('draggable', 'false');
                        // Re-enable after a short delay
                        rightClickTimeout = setTimeout(() => {
                            tagItem.setAttribute('draggable', 'true');
                            isRightClick = false;
                        }, 100);
                    }
                });
                
                tagItem.addEventListener('contextmenu', (e) => {
                    // Prevent drag when right clicking
                    isRightClick = true;
                    tagItem.setAttribute('draggable', 'false');
                    setTimeout(() => {
                        tagItem.setAttribute('draggable', 'true');
                        isRightClick = false;
                    }, 100);
                });
                
                tagItem.addEventListener('dragstart', (e) => {
                    // Prevent drag if it was triggered by right click
                    if (isRightClick) {
                        e.preventDefault();
                        e.stopPropagation();
                        return false;
                    }
                    
                    const tagId = tagItem.getAttribute('data-tag-id');
                    e.dataTransfer.setData('text/plain', tagId);
                    e.dataTransfer.effectAllowed = 'move';
                    tagItem.style.opacity = '0.5';
                });
                
                tagItem.addEventListener('dragend', (e) => {
                    tagItem.style.opacity = '1';
                    isRightClick = false;
                    if (rightClickTimeout) {
                        clearTimeout(rightClickTimeout);
                        rightClickTimeout = null;
                    }
                    // Reset all folder styles in case drag was cancelled
                    const folderItems = document.querySelectorAll('.folder-item[data-folder-id]');
                    folderItems.forEach(folder => {
                        folder.style.opacity = '1';
                        folder.style.transform = 'scale(1)';
                    });
                });
            });
        }

        // Context menu variables
        let contextMenuTarget = null;
        let contextMenuType = null; // 'folder' or 'tag'
        let contextSelectedElement = null;
        let contextMenuMode = 'options'; // 'options' or 'confirm'

        function setContextMenuMode(mode) {
            const options = document.getElementById('contextMenuOptions');
            const confirm = document.getElementById('contextMenuConfirm');
            if (!options || !confirm) return;

            contextMenuMode = mode;
            if (mode === 'options') {
                options.style.display = 'flex';
                confirm.style.display = 'none';
            } else {
                options.style.display = 'none';
                confirm.style.display = 'flex';
            }
        }

        function showContextMenu(event, type, id) {
            event.preventDefault();
            event.stopPropagation();

            setContextMenuMode('options');
            
            // Remove previous selection
            if (contextSelectedElement) {
                contextSelectedElement.classList.remove('context-selected');
            }
            
            // Find and highlight the clicked element
            let element = null;
            if (type === 'folder') {
                element = document.querySelector(`.folder-item[data-folder-id="${id}"]`);
            } else if (type === 'tag') {
                element = document.querySelector(`.tag-item[data-tag-id="${id}"]`);
            }
            
            if (element) {
                element.classList.add('context-selected');
                contextSelectedElement = element;
            }
            
            const contextMenu = document.getElementById('contextMenu');
            contextMenuTarget = id;
            contextMenuType = type;
            
            // Position menu at cursor
            contextMenu.style.display = 'flex';
            contextMenu.style.left = event.pageX + 'px';
            contextMenu.style.top = event.pageY + 'px';
            
            // Ensure menu stays within viewport
            setTimeout(() => {
                const rect = contextMenu.getBoundingClientRect();
                if (rect.right > window.innerWidth) {
                    contextMenu.style.left = (event.pageX - rect.width) + 'px';
                }
                if (rect.bottom > window.innerHeight) {
                    contextMenu.style.top = (event.pageY - rect.height) + 'px';
                }
            }, 0);
        }

        function hideContextMenu() {
            const contextMenu = document.getElementById('contextMenu');
            contextMenu.style.display = 'none';

            setContextMenuMode('options');
            
            // Remove highlight from selected element
            if (contextSelectedElement) {
                contextSelectedElement.classList.remove('context-selected');
                contextSelectedElement = null;
            }
            
            contextMenuTarget = null;
            contextMenuType = null;
        }

        function setupFolderContextMenu() {
            const folderItems = document.querySelectorAll('.folder-item[data-folder-id]');
            folderItems.forEach(folderItem => {
                folderItem.addEventListener('contextmenu', (e) => {
                    const folderId = folderItem.getAttribute('data-folder-id');
                    // Treat "none" folder the same as other folders
                    if (folderId === 'none') {
                        showContextMenu(e, 'folder', 'none');
                    } else {
                        showContextMenu(e, 'folder', parseInt(folderId));
                    }
                });
            });
        }

        function setupTagContextMenu() {
            const tagItems = document.querySelectorAll('.tag-item[data-tag-id]');
            tagItems.forEach(tagItem => {
                tagItem.addEventListener('contextmenu', (e) => {
                    const tagId = tagItem.getAttribute('data-tag-id');
                    showContextMenu(e, 'tag', parseInt(tagId));
                });
            });
        }

        function handleContextMenuEdit() {
            hideContextMenu();

            showMessage('Editing from this menu will be available soon.', 'info');
        }

        function handleContextMenuPin() {
            hideContextMenu();

            showMessage('Pinning will be available soon. This will keep the item at the top.', 'info');
        }

        function handleContextMenuDelete() {
            if (contextMenuType === 'folder' && contextMenuTarget === 'none') {
                showMessage('This folder cannot be deleted', 'error');
                hideContextMenu();
                return;
            }

            const confirmTitle = document.getElementById('contextMenuConfirmTitle');
            confirmTitle.textContent = 'Are you sure?';

            setContextMenuMode('confirm');
        }

        function cancelContextMenuDelete() {
            setContextMenuMode('options');
        }

        function confirmContextMenuDelete() {
            const targetId = contextMenuTarget;
            const targetType = contextMenuType;

            hideContextMenu();

            if (targetType === 'folder' && targetId !== null) {
                deleteFolder(targetId);
            } else if (targetType === 'tag' && targetId !== null) {
                deleteTag(targetId);
            }
        }

        async function editFolder(folderId) {
            // "TAGS WITHOUT FOLDER" is a special folder that cannot be edited
            if (folderId === 'none') {
                showMessage('This folder cannot be edited', 'error');
                return;
            }

            const folder = folders.find(f => f.id === folderId);
            if (!folder) return;

            const newName = prompt('Enter new folder name:', folder.name);
            if (!newName || newName.trim() === '') return;

            const newColor = prompt('Enter new folder color (hex):', folder.color || '#64748b');
            if (!newColor) return;

            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`${FOLDERS_URL}/${folderId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        name: newName.trim().toUpperCase(),
                        color: newColor
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message || 'Failed to update folder');
                }

                await loadFolders();
                renderTags();
                showMessage('Folder updated', 'success');
            } catch (error) {
                console.error('Error updating folder:', error);
                showMessage('Error updating folder: ' + error.message, 'error');
            }
        }

        async function editTag(tagId) {
            const tag = tags.find(t => t.id === tagId);
            if (!tag) return;

            const newName = prompt('Enter new tag name:', tag.name);
            if (!newName || newName.trim() === '') return;
            
            if (newName.length > 20) {
                showMessage('Tag name must be 20 characters or less', 'error');
                return;
            }

            const newColor = prompt('Enter new tag color (hex):', tag.color || '#3b82f6');
            if (!newColor) return;

            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`${TAGS_URL}/${tagId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        name: newName.trim(),
                        color: newColor
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message || 'Failed to update tag');
                }

                await loadTags();
                renderTags();
                showMessage('Tag updated', 'success');
            } catch (error) {
                console.error('Error updating tag:', error);
                showMessage('Error updating tag: ' + error.message, 'error');
            }
        }

        async function moveTagToFolder(tagId, newFolderId) {
            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`/api/tags/${tagId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({ folderId: newFolderId })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message || 'Failed to move tag');
                }

                const updatedTag = await response.json();
                
                // Update the tag in the local array
                const tagIndex = tags.findIndex(t => t.id === tagId);
                if (tagIndex !== -1) {
                    tags[tagIndex] = updatedTag;
                }
                
                // Reload folders to update counts
                await loadFolders();
                
                // Re-render tags
                renderTags();
            } catch (error) {
                console.error('Error moving tag:', error);
                alert('Failed to move tag: ' + error.message);
            }
        }

        function selectFolder(folderId) {
            if (viewMode === 'folders') {
                selectedFolderId = folderId;
                renderTags();
            }
        }

        function navigateToFolder(folderId) {
            // Switch to folders view
            setViewMode('folders');
            // Select the folder
            selectedFolderId = folderId;
            // Re-render to show the selected folder
            renderTags();
        }

        function handleTagsSearch() {
            const searchInput = document.getElementById('tagsSearchInput');
            if (searchInput) {
                tagsSearchTerm = searchInput.value;
                renderTags();
            }
        }

        function toggleSortOrder() {
            tagsSortOrder = tagsSortOrder === 'asc' ? 'desc' : 'asc';
            updateSortButtonIcon();
            renderTags();
        }

        function updateSortButtonIcon() {
            const sortAscIcon = document.getElementById('sortAscIcon');
            const sortDescIcon = document.getElementById('sortDescIcon');
            if (sortAscIcon && sortDescIcon) {
                if (tagsSortOrder === 'asc') {
                    sortAscIcon.style.display = 'block';
                    sortDescIcon.style.display = 'none';
                } else {
                    sortAscIcon.style.display = 'none';
                    sortDescIcon.style.display = 'block';
                }
            }
        }

        function renderAccountTags() {
            const accountTagsList = document.getElementById('accountTagsList');
            if (!accountTagsList) return;

            if (tags.length === 0 && folders.length === 0) {
                accountTagsList.innerHTML = '<div style="color: #94a3b8; font-size: 12px; font-style: italic;">No tags yet</div>';
                return;
            }

            let html = '';

            // Render tags grouped by folders
            folders.forEach(folder => {
                const folderTags = tags.filter(tag => tag.folderId === folder.id);
                if (folderTags.length > 0) {
                    const folderColor = folder.color || '#64748b';
                    html += `
                        <div style="margin-bottom: 8px;">
                            <div style="font-size: 11px; font-weight: 600; color: ${folderColor}; margin-bottom: 6px; letter-spacing: 0.5px;">${escapeHtml(folder.name.toUpperCase())}</div>
                            <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                ${folderTags.map(tag => `
                                    <span style="display: inline-flex; align-items: center; gap: 6px; padding: 4px 8px; background: ${tag.color || '#3b82f6'}15; border: 1px solid ${tag.color || '#3b82f6'}40; border-radius: 6px; font-size: 12px; color: #1e293b;">
                                        <span style="width: 8px; height: 8px; border-radius: 50%; background-color: ${tag.color || '#3b82f6'}; flex-shrink: 0;"></span>
                                        ${escapeHtml(tag.name)}
                                    </span>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }
            });

            // Render tags without folder
            const tagsWithoutFolder = tags.filter(tag => !tag.folderId).sort((a, b) => a.name.localeCompare(b.name));
            if (tagsWithoutFolder.length > 0) {
                html += `
                    <div style="margin-bottom: 8px;">
                        <div style="font-size: 11px; font-weight: 600; color: #64748b; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Sin carpeta</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                            ${tagsWithoutFolder.map(tag => `
                                <span style="display: inline-flex; align-items: center; gap: 6px; padding: 4px 8px; background: ${tag.color || '#3b82f6'}15; border: 1px solid ${tag.color || '#3b82f6'}40; border-radius: 6px; font-size: 12px; color: #1e293b;">
                                    <span style="width: 8px; height: 8px; border-radius: 50%; background-color: ${tag.color || '#3b82f6'}; flex-shrink: 0;"></span>
                                    ${escapeHtml(tag.name)}
                                </span>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            accountTagsList.innerHTML = html || '<div style="color: #94a3b8; font-size: 12px; font-style: italic;">No tags yet</div>';
        }

        function updateTagSelect() {
            const container = document.getElementById('taskTags');
            container.innerHTML = '';
            
            if (tags.length === 0) {
                container.innerHTML = '<div style="color: #999; font-size: 12px;">No tags available. Create tags below.</div>';
                return;
            }
            
            // If modal has been opened, show only selected tags
            if (tagsModalOpened && selectedTagsForTask.length > 0) {
                selectedTagsForTask.forEach(tagId => {
                    const tag = tags.find(t => t.id === tagId);
                    if (tag) {
                        const tagItem = createTagCheckboxItem(tag, true);
                        container.appendChild(tagItem);
                    }
                });
                
                // Always show "X more" button if there are remaining tags
                if (tags.length > selectedTagsForTask.length) {
                    const remainingCount = tags.length - selectedTagsForTask.length;
                    const moreBtn = document.createElement('div');
                    moreBtn.className = 'tag-checkbox-item';
                    moreBtn.style.cssText = 'border: 2px dashed #cbd5e1; border-radius: 12px; background: #f8fafc; color: #64748b; font-weight: 500; cursor: pointer; white-space: nowrap; transition: all 0.3s ease;';
                    moreBtn.textContent = `${remainingCount} more`;
                    moreBtn.onclick = function(event) {
                        openTagsModal(event);
                    };
                    moreBtn.onmouseover = function() {
                        this.style.borderColor = '#3b82f6';
                        this.style.background = '#eff6ff';
                    };
                    moreBtn.onmouseout = function() {
                        this.style.borderColor = '#cbd5e1';
                        this.style.background = '#f8fafc';
                    };
                    container.appendChild(moreBtn);
                }
                return;
            }
            
            // If modal hasn't been opened, show recommended tags + selected tags
            // Get recently used tags (tags used in tasks, sorted by most recent task)
            const tagUsageMap = new Map(); // tagId -> { lastUsed: date, count: number }
            
            tasks.forEach(task => {
                if (task.tagIds && Array.isArray(task.tagIds)) {
                    const taskDate = new Date(task.updatedAt || task.createdAt || 0);
                    task.tagIds.forEach(tagId => {
                        const existing = tagUsageMap.get(tagId);
                        if (!existing || taskDate > existing.lastUsed) {
                            tagUsageMap.set(tagId, {
                                lastUsed: taskDate,
                                count: (existing?.count || 0) + 1
                            });
                        } else {
                            existing.count++;
                        }
                    });
                }
            });
            
            // Sort tags by most used (count), prioritizing those that have been used
            const sortedTags = [...tags].sort((a, b) => {
                const aUsage = tagUsageMap.get(a.id);
                const bUsage = tagUsageMap.get(b.id);
                
                // Tags that have been used come before tags that haven't
                if (!aUsage && !bUsage) {
                    // If neither has been used, sort alphabetically
                    return a.name.localeCompare(b.name);
                }
                if (!aUsage) return 1; // Unused tags go to the end
                if (!bUsage) return -1; // Used tags come first
                
                // Both have been used - sort by count (most used first)
                if (aUsage.count !== bUsage.count) {
                    return bUsage.count - aUsage.count;
                }
                // If same count, sort by most recent
                return bUsage.lastUsed - aUsage.lastUsed;
            });
            
            // Always show top 4 most used tags
            const numTagsToShow = 4;
            const visibleTags = sortedTags.slice(0, numTagsToShow);
            const totalRemaining = tags.length - visibleTags.length;
            
            // Render visible tags (highlight selected ones)
            visibleTags.forEach(tag => {
                const isSelected = selectedTagsForTask.includes(tag.id);
                const tagItem = createTagCheckboxItem(tag, isSelected);
                container.appendChild(tagItem);
            });
            
            // Add "X more" button if there are remaining tags
            if (totalRemaining > 0) {
                const moreBtn = document.createElement('div');
                moreBtn.className = 'tag-checkbox-item';
                moreBtn.style.cssText = 'border: 2px dashed #cbd5e1; border-radius: 12px; background: #f8fafc; color: #64748b; font-weight: 500; cursor: pointer; white-space: nowrap; transition: all 0.3s ease;';
                moreBtn.textContent = `${totalRemaining} more`;
                moreBtn.onclick = function(event) {
                    openTagsModal(event);
                };
                moreBtn.onmouseover = function() {
                    this.style.borderColor = '#3b82f6';
                    this.style.background = '#eff6ff';
                };
                moreBtn.onmouseout = function() {
                    this.style.borderColor = '#cbd5e1';
                    this.style.background = '#f8fafc';
                };
                container.appendChild(moreBtn);
            }
        }
        
        function createTagCheckboxItem(tag, isSelectedFromModal = false) {
                const tagItem = document.createElement('div');
                tagItem.className = 'tag-checkbox-item';
                tagItem.dataset.tagId = tag.id;
            const isSelected = isSelectedFromModal || selectedTagsForTask.includes(tag.id);
            const tagColor = tag.color || '#3b82f6';
            
            // Create close button for selected tags
            const closeBtn = isSelected ? `
                <span class="tag-remove-btn" onclick="removeTagFromSelection(${tag.id}); event.stopPropagation();" style="
                    position: absolute;
                    top: -6px;
                    right: -6px;
                    width: 18px;
                    height: 18px;
                    border-radius: 50%;
                    background: #ef4444;
                    color: white;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 12px;
                    cursor: pointer;
                    opacity: 0;
                    transition: opacity 0.2s ease;
                    z-index: 10;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                "></span>
            ` : '';
            
            tagItem.style.position = 'relative';
            
            // If selected, use tag color as background with white text, no color indicator
            if (isSelected) {
                tagItem.style.backgroundColor = tagColor;
                tagItem.style.borderColor = tagColor;
                tagItem.style.color = 'white';
                tagItem.style.textAlign = 'center';
                tagItem.style.justifyContent = 'center';
                tagItem.innerHTML = `
                    <span style="color: white;">${escapeHtml(tag.name)}</span>
                    ${closeBtn}
                `;
            } else {
                // Not selected: show color indicator and normal styling
                tagItem.innerHTML = `
                    <span class="tag-color-indicator" style="background-color: ${tagColor}"></span>
                    <span>${escapeHtml(tag.name)}</span>
                `;
            }
            
            if (isSelected) {
                tagItem.classList.add('selected');
            }
            
            // Show/hide close button on hover
            if (isSelected) {
                tagItem.addEventListener('mouseenter', function() {
                    const closeBtn = this.querySelector('.tag-remove-btn');
                    if (closeBtn) closeBtn.style.opacity = '1';
                });
                tagItem.addEventListener('mouseleave', function() {
                    const closeBtn = this.querySelector('.tag-remove-btn');
                    if (closeBtn) closeBtn.style.opacity = '0';
                });
            }
                
                tagItem.addEventListener('click', function(e) {
                if (e.target.className !== 'tag-remove-btn') {
                    const wasSelected = selectedTagsForTask.includes(tag.id);
                    
                    if (wasSelected) {
                        // Deselect
                        selectedTagsForTask = selectedTagsForTask.filter(id => id !== tag.id);
                        this.classList.remove('selected');
                        // Restore normal styling
                        this.style.backgroundColor = '';
                        this.style.borderColor = '';
                        this.style.color = '';
                        this.style.textAlign = '';
                        this.style.justifyContent = '';
                        this.innerHTML = `
                            <span class="tag-color-indicator" style="background-color: ${tagColor}"></span>
                            <span>${escapeHtml(tag.name)}</span>
                        `;
                    } else {
                        // Select (with max 3 limit)
                        if (selectedTagsForTask.length >= 3) {
                            // Remove the first (oldest) selected tag
                            selectedTagsForTask.shift();
                        }
                        selectedTagsForTask.push(tag.id);
                        this.classList.add('selected');
                        // Apply selected styling
                        this.style.backgroundColor = tagColor;
                        this.style.borderColor = tagColor;
                        this.style.color = 'white';
                        this.style.textAlign = 'center';
                        this.style.justifyContent = 'center';
                        this.innerHTML = `
                            <span style="color: white;">${escapeHtml(tag.name)}</span>
                            ${closeBtn}
                        `;
                        // Re-attach hover listeners for close button
                        this.addEventListener('mouseenter', function() {
                            const closeBtn = this.querySelector('.tag-remove-btn');
                            if (closeBtn) closeBtn.style.opacity = '1';
                        });
                        this.addEventListener('mouseleave', function() {
                            const closeBtn = this.querySelector('.tag-remove-btn');
                            if (closeBtn) closeBtn.style.opacity = '0';
                        });
                    }
                    
                    updateTagSelect();
                    // Re-render tags modal if it's open
                    const tagsModal = document.getElementById('tagsModalOverlay');
                    if (tagsModal && tagsModal.classList.contains('active')) {
                        renderTagsModal();
                    }
                    }
                });
            
            return tagItem;
        }
        
        function toggleTagSelection(tagId) {
            const index = selectedTagsForTask.indexOf(tagId);
            
            if (index > -1) {
                // Deselect
                selectedTagsForTask.splice(index, 1);
            } else {
                // Select (with max 3 limit)
                if (selectedTagsForTask.length >= 3) {
                    // Remove the first (oldest) selected tag
                    selectedTagsForTask.shift();
                }
                selectedTagsForTask.push(tagId);
            }
            
            // Update the tag select display
            updateTagSelect();
            // Re-render tags modal to show updated selection state
            renderTagsModal();
        }
        
        function removeTagFromSelection(tagId) {
            selectedTagsForTask = selectedTagsForTask.filter(id => id !== tagId);
            updateTagSelect();
            // Re-render tags modal if it's open
            const tagsModal = document.getElementById('tagsModalOverlay');
            if (tagsModal && tagsModal.classList.contains('active')) {
                renderTagsModal();
            }
        }

        // Tags Modal Functions
        function openTagsModal(event) {
            // Mark that modal has been opened
            tagsModalOpened = true;
            const modal = document.getElementById('tagsModalOverlay');
            const modalContent = modal ? modal.querySelector('.task-modal') : null;
            
            if (modal && modalContent) {
                // Position relative to task creation modal
                let targetX = 600;
                let targetY = 120;
                
                const taskModal = document.getElementById('taskModalOverlay');
                if (taskModal && taskModal.classList.contains('active')) {
                    const taskModalContent = taskModal.querySelector('.task-modal');
                    if (taskModalContent) {
                        const taskModalRect = taskModalContent.getBoundingClientRect();
                        // Position to the right of the task modal with 16px gap
                        targetX = taskModalRect.right + 16;
                        targetY = taskModalRect.top;
                    }
                }
                
                // Set position
                modalContent.style.left = targetX + 'px';
                modalContent.style.top = targetY + 'px';
                
                modal.classList.add('active');
                // Reset modal state - default to showing all tags
                tagsModalViewMode = 'tags';
                tagsModalSelectedFolderId = null;
                tagsModalSearchTerm = '';
                tagsModalSortOrder = 'asc';
                const searchInput = document.getElementById('tagsModalSearchInput');
                if (searchInput) {
                    searchInput.value = '';
                }
                
                // Update button states
                const foldersBtn = document.getElementById('tagsModalViewFoldersBtn');
                const tagsBtn = document.getElementById('tagsModalViewTagsBtn');
                if (foldersBtn) foldersBtn.classList.remove('active');
                if (tagsBtn) tagsBtn.classList.add('active');
                
                renderTagsModal();
                updateTagsModalFolderSelect();
                
                // Adjust position and height after content is rendered
                setTimeout(() => {
                    adjustTagsModalPosition();
                }, 10);
        }
        }
        
        function showTagsModalNewTagForm() {
            // Only show form when in tags view (all tags)
            if (tagsModalViewMode !== 'tags') {
                return;
            }
            
            const tagForm = document.getElementById('tagsModalNewTagForm');
            if (tagForm) {
                if (tagForm.style.display === 'none' || tagForm.style.display === '') {
                    tagForm.style.display = 'flex';
                } else {
                    tagForm.style.display = 'none';
                }
            }
        }
        
        function updateTagsModalFolderSelect() {
            const select = document.getElementById('tagsModalNewTagFolder');
            if (!select) return;
            
            const currentValue = select.value;
            select.innerHTML = '<option value="">No folder</option>';
            
            folders.forEach(folder => {
                const option = document.createElement('option');
                option.value = folder.id;
                option.textContent = escapeHtml(folder.name.toUpperCase());
                select.appendChild(option);
            });
            
            if (currentValue) {
                select.value = currentValue;
            }
        }
        
        function createTagFromTagsModal() {
            // Open the create tag modal instead
            openCreateTagModal();
        }

        // Create Tag Modal Functions
        function openCreateTagModal() {
            const modal = document.getElementById('createTagModalOverlay');
            const modalContent = modal ? modal.querySelector('.task-modal') : null;
            
            if (modal && modalContent) {
                // Position relative to task creation modal
                let targetX = 600;
                let targetY = 120;
                
                const taskModal = document.getElementById('taskModalOverlay');
                const tagsModal = document.getElementById('tagsModalOverlay');
                const createTagModalHeight = 380;
                const createTagModalWidth = 450;
                
                if (taskModal && taskModal.classList.contains('active')) {
                    const taskModalContent = taskModal.querySelector('.task-modal');
                    if (taskModalContent) {
                        const taskModalRect = taskModalContent.getBoundingClientRect();
                        // Position to the right of the task modal with 16px gap (same as tags modal)
                        targetX = taskModalRect.right + 16;
                        
                        // Always align top with task modal
                        targetY = taskModalRect.top;
                        
                        // If tags modal is open, adjust height to leave margin
                        if (tagsModal && tagsModal.classList.contains('active')) {
                            const tagsModalContent = tagsModal.querySelector('.task-modal');
                            if (tagsModalContent) {
                                const tagsModalRect = tagsModalContent.getBoundingClientRect();
                                // Calculate available space above tags modal
                                const availableHeight = tagsModalRect.top - targetY - 16; // 16px margin
                                // Adjust height if needed, but keep minimum
                                if (availableHeight < createTagModalHeight) {
                                    modalContent.style.height = Math.max(availableHeight, 200) + 'px';
                                    modalContent.style.maxHeight = Math.max(availableHeight, 200) + 'px';
                                } else {
                                    modalContent.style.height = createTagModalHeight + 'px';
                                    modalContent.style.maxHeight = createTagModalHeight + 'px';
                                }
                            }
                        }
                    }
                } else {
                    // If task modal is not open, center it on screen
                    targetX = (window.innerWidth - createTagModalWidth) / 2;
                    targetY = (window.innerHeight - createTagModalHeight) / 2;
                }
                
                // Ensure modal doesn't go off screen
                const maxX = window.innerWidth - createTagModalWidth - 20;
                const maxY = window.innerHeight - createTagModalHeight - 20;
                
                const finalX = Math.min(targetX, maxX);
                const finalY = Math.min(targetY, maxY);
                
                // Set position
                modalContent.style.left = Math.max(finalX, 20) + 'px';
                modalContent.style.top = Math.max(finalY, 20) + 'px';
                
                modal.classList.add('active');
                
                // Reset form state
                document.getElementById('createTagFolderHidden').value = '';
                document.getElementById('createTagPinnedHidden').value = 'false';
                document.getElementById('createTagColor').value = '#3b82f6';
                updateCreateTagFolderBtnVisual(document.getElementById('createTagFolderBtn'));
                updateCreateTagColorBtnVisual(document.getElementById('createTagColorBtn'));
                updateCreateTagPinBtnVisual(document.getElementById('createTagPinnedBtn'));
                
                // Focus on name input
                setTimeout(() => {
                    const nameInput = document.getElementById('createTagName');
                    if (nameInput) {
                        nameInput.focus();
                    }
                }, 100);
            }
        }

        function closeCreateTagModal() {
            const modal = document.getElementById('createTagModalOverlay');
            if (modal) {
                modal.classList.remove('active');
            }
            // Reset form
            const form = document.getElementById('createTagForm');
            if (form) {
                form.reset();
                document.getElementById('createTagColor').value = '#3b82f6';
                document.getElementById('createTagFolderHidden').value = '';
                document.getElementById('createTagPinnedHidden').value = 'false';
                updateCreateTagFolderBtnVisual(document.getElementById('createTagFolderBtn'));
                updateCreateTagColorBtnVisual(document.getElementById('createTagColorBtn'));
                updateCreateTagPinBtnVisual(document.getElementById('createTagPinnedBtn'));
            }
        }

        function closeCreateTagModalOnOverlay(event) {
            if (event.target.id === 'createTagModalOverlay') {
                closeCreateTagModal();
            }
        }

        function updateCreateTagModalFolderSelect() {
            // No longer needed - using button instead of select
        }

        function updateCreateTagFolderBtnVisual(btnElement) {
            if (!btnElement) return;
            const folderId = document.getElementById('createTagFolderHidden').value;
            if (folderId) {
                const folder = folders.find(f => f.id === parseInt(folderId));
                if (folder) {
                    btnElement.style.borderColor = folder.color || '#3b82f6';
                    btnElement.style.background = folder.color || '#3b82f6';
                    btnElement.style.color = '#ffffff';
                    const svg = btnElement.querySelector('svg');
                    if (svg) {
                        svg.setAttribute('stroke', '#ffffff');
                    }
                }
            } else {
                btnElement.style.borderColor = '#e2e8f0';
                btnElement.style.background = '#ffffff';
                btnElement.style.color = '#64748b';
                const svg = btnElement.querySelector('svg');
                if (svg) {
                    svg.setAttribute('stroke', 'currentColor');
                }
            }
        }

        function showCreateTagFolderMenu(event) {
            event.preventDefault();
            event.stopPropagation();
            
            // Create a simple dropdown menu
            const existingMenu = document.getElementById('createTagFolderMenu');
            if (existingMenu) {
                existingMenu.remove();
                return;
            }
            
            const menu = document.createElement('div');
            menu.id = 'createTagFolderMenu';
            menu.style.cssText = 'position: absolute; background: white; border: 1px solid #e2e8f0; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 10001; max-height: 200px; overflow-y: auto; overflow-x: hidden; min-width: 200px;';
            
            // Hide scrollbar but keep scroll functionality
            const style = document.createElement('style');
            style.textContent = `
                #createTagFolderMenu::-webkit-scrollbar {
                    display: none;
                }
                #createTagFolderMenu {
                    -ms-overflow-style: none;
                    scrollbar-width: none;
                }
            `;
            document.head.appendChild(style);
            
            const btnRect = event.target.closest('button').getBoundingClientRect();
            menu.style.left = btnRect.left + 'px';
            menu.style.top = (btnRect.bottom + 4) + 'px';
            
            // Add "No folder" option
            const noFolderItem = document.createElement('div');
            noFolderItem.style.cssText = 'padding: 8px 12px; cursor: pointer; font-size: 14px; color: #1e293b; transition: background 0.2s ease;';
            noFolderItem.textContent = 'No folder';
            noFolderItem.onmouseover = () => noFolderItem.style.background = '#f8fafc';
            noFolderItem.onmouseout = () => noFolderItem.style.background = 'transparent';
            noFolderItem.onclick = () => {
                document.getElementById('createTagFolderHidden').value = '';
                updateCreateTagFolderBtnVisual(document.getElementById('createTagFolderBtn'));
                menu.remove();
            };
            menu.appendChild(noFolderItem);
            
            // Add folder options
            folders.forEach(folder => {
                const folderItem = document.createElement('div');
                folderItem.style.cssText = 'padding: 8px 12px; cursor: pointer; font-size: 14px; color: #1e293b; transition: background 0.2s ease; display: flex; align-items: center; gap: 8px;';
                folderItem.innerHTML = `<span style="width: 12px; height: 12px; border-radius: 50%; background: ${folder.color || '#64748b'};"></span>${escapeHtml(folder.name.toUpperCase())}`;
                folderItem.onmouseover = () => folderItem.style.background = '#f8fafc';
                folderItem.onmouseout = () => folderItem.style.background = 'transparent';
                folderItem.onclick = () => {
                    document.getElementById('createTagFolderHidden').value = folder.id;
                    updateCreateTagFolderBtnVisual(document.getElementById('createTagFolderBtn'));
                    menu.remove();
                };
                menu.appendChild(folderItem);
            });
            
            document.body.appendChild(menu);
            
            // Close menu when clicking outside
            setTimeout(() => {
                const closeMenu = (e) => {
                    if (!menu.contains(e.target) && !event.target.closest('button').contains(e.target)) {
                        menu.remove();
                        document.removeEventListener('click', closeMenu);
                    }
                };
                document.addEventListener('click', closeMenu);
            }, 0);
        }

        function showCreateTagColorMenu(event) {
            event.preventDefault();
            event.stopPropagation();
            
            // Create a simple dropdown menu
            const existingMenu = document.getElementById('createTagColorMenu');
            if (existingMenu) {
                existingMenu.remove();
                return;
            }
            
            const menu = document.createElement('div');
            menu.id = 'createTagColorMenu';
            menu.style.cssText = 'position: absolute; background: white; border: 1px solid #e2e8f0; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 10001; padding: 8px; display: grid; grid-template-columns: repeat(5, 1fr); gap: 6px; min-width: 180px;';
            
            const btnRect = event.target.closest('button').getBoundingClientRect();
            menu.style.left = btnRect.left + 'px';
            menu.style.top = (btnRect.bottom + 4) + 'px';
            
            // After menu is rendered, align right edge of menu with right edge of button
            setTimeout(() => {
                const menuRect = menu.getBoundingClientRect();
                const menuWidth = menuRect.width;
                const leftPosition = btnRect.right - menuWidth;
                menu.style.left = leftPosition + 'px';
                
                // Ensure menu doesn't go off-screen to the left
                const finalMenuRect = menu.getBoundingClientRect();
                if (finalMenuRect.left < 20) {
                    menu.style.left = '20px';
                }
            }, 0);
            
            // Predefined colors
            const colors = [
                '#3b82f6', // Blue
                '#ef4444', // Red
                '#10b981', // Green
                '#fbbf24', // Amber/Yellow (lighter)
                '#f97316', // Orange
                '#8b5cf6', // Purple
                '#ec4899', // Pink
                '#a16207', // Brown
                '#84cc16', // Lime
                '#64748b'  // Gray
            ];
            
            colors.forEach(color => {
                const colorItem = document.createElement('div');
                colorItem.style.cssText = `width: 28px; height: 28px; border-radius: 6px; background: ${color}; cursor: pointer; border: 2px solid transparent; transition: all 0.2s ease;`;
                colorItem.onmouseover = () => {
                    colorItem.style.borderColor = '#3b82f6';
                    colorItem.style.transform = 'scale(1.1)';
                };
                colorItem.onmouseout = () => {
                    colorItem.style.borderColor = 'transparent';
                    colorItem.style.transform = 'scale(1)';
                };
                colorItem.onclick = () => {
                    document.getElementById('createTagColor').value = color;
                    updateCreateTagColorBtnVisual(document.getElementById('createTagColorBtn'));
                    menu.remove();
                };
                menu.appendChild(colorItem);
            });
            
            document.body.appendChild(menu);
            
            // Close menu when clicking outside (but not the modal)
            setTimeout(() => {
                const closeMenu = (e) => {
                    const clickedButton = e.target.closest('#createTagColorBtn');
                    if (!menu.contains(e.target) && !clickedButton) {
                        menu.remove();
                        document.removeEventListener('click', closeMenu, true);
                    }
                };
                // Use capture phase to catch clicks before they reach other handlers
                document.addEventListener('click', closeMenu, true);
            }, 0);
        }

        function updateCreateTagColorBtnVisual(btnElement) {
            if (!btnElement) return;
            const color = document.getElementById('createTagColor').value;
            if (color) {
                btnElement.style.borderColor = color;
                btnElement.style.background = color;
                btnElement.style.color = '#ffffff';
                const svg = btnElement.querySelector('svg');
                if (svg) {
                    svg.setAttribute('stroke', '#ffffff');
                }
            } else {
                btnElement.style.borderColor = '#e2e8f0';
                btnElement.style.background = '#ffffff';
                btnElement.style.color = '#64748b';
                const svg = btnElement.querySelector('svg');
                if (svg) {
                    svg.setAttribute('stroke', 'currentColor');
                }
            }
        }

        function toggleCreateTagPin() {
            const hiddenInput = document.getElementById('createTagPinnedHidden');
            const btn = document.getElementById('createTagPinnedBtn');
            const isPinned = hiddenInput.value === 'true';
            hiddenInput.value = isPinned ? 'false' : 'true';
            updateCreateTagPinBtnVisual(btn);
        }

        function updateCreateTagPinBtnVisual(btnElement) {
            if (!btnElement) return;
            const isPinned = document.getElementById('createTagPinnedHidden').value === 'true';
            const svg = btnElement.querySelector('svg');
            
            if (isPinned) {
                btnElement.classList.add('active');
                btnElement.style.background = '#3b82f6';
                btnElement.style.borderColor = '#3b82f6';
                btnElement.style.color = '#ffffff';
                if (svg) {
                    svg.setAttribute('stroke', 'currentColor');
                }
            } else {
                btnElement.classList.remove('active');
                btnElement.style.background = '#ffffff';
                btnElement.style.borderColor = '#e2e8f0';
                btnElement.style.color = '#64748b';
                if (svg) {
                    svg.setAttribute('stroke', 'currentColor');
                }
            }
        }

        async function handleCreateTagSubmit(event) {
            event.preventDefault();
            
            const name = document.getElementById('createTagName').value.trim();
            const color = document.getElementById('createTagColor').value;
            const folderId = document.getElementById('createTagFolderHidden').value || null;
            const pinned = document.getElementById('createTagPinnedHidden').value === 'true';

            if (!name) {
                showMessage('Tag name is required', 'error');
                return;
            }

            if (name.length > 20) {
                showMessage('Tag name must be 20 characters or less', 'error');
                return;
            }

            try {
                const res = await fetch(TAGS_URL, {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ 
                        name, 
                        color, 
                        folderId: folderId ? parseInt(folderId) : null,
                        pinned: pinned || false
                    })
                });

                if (res.status === 401) {
                    logout();
                    return;
                }

                const data = await res.json();
                if (!res.ok) {
                    showMessage(data.message || 'Error creating tag', 'error');
                    return;
                }

                showMessage('Tag created', 'success');
                closeCreateTagModal();
                await loadTags();
                renderTags();
                // If tags modal is open, refresh it
                const tagsModal = document.getElementById('tagsModalOverlay');
                if (tagsModal && tagsModal.classList.contains('active')) {
                    renderTagsModal();
                }
            } catch (error) {
                console.error('Error creating tag:', error);
                showMessage('Error creating tag', 'error');
            }
        }

        function closeTagsModal() {
            const modal = document.getElementById('tagsModalOverlay');
            if (modal) {
                modal.classList.remove('active');
            }
        }

        function closeTagsModalOnOverlay(event) {
            if (event.target.id === 'tagsModalOverlay') {
                closeTagsModal();
            }
        }

        function setTagsModalViewMode(mode) {
            tagsModalViewMode = mode;
            
            // Reset selected folder when switching to tags view
            if (mode === 'tags') {
                tagsModalSelectedFolderId = null;
            }
            
            // Update button states
            const foldersBtn = document.getElementById('tagsModalViewFoldersBtn');
            const tagsBtn = document.getElementById('tagsModalViewTagsBtn');
            if (foldersBtn) foldersBtn.classList.toggle('active', mode === 'folders');
            if (tagsBtn) tagsBtn.classList.toggle('active', mode === 'tags');
            
            // Hide new tag form when switching to folders view
            const newTagForm = document.getElementById('tagsModalNewTagForm');
            if (newTagForm) {
                if (mode === 'folders') {
                    newTagForm.style.display = 'none';
                }
            }
            
            // Re-render
            renderTagsModal();
            // Adjust position after rendering
            setTimeout(() => {
                adjustTagsModalPosition();
            }, 10);
        }

        function handleTagsModalSearch() {
            const searchInput = document.getElementById('tagsModalSearchInput');
            if (searchInput) {
                tagsModalSearchTerm = searchInput.value;
                renderTagsModal();
                // Adjust position after rendering
                setTimeout(() => {
                    adjustTagsModalPosition();
                }, 10);
            }
        }

        function toggleTagsModalSortOrder() {
            tagsModalSortOrder = tagsModalSortOrder === 'asc' ? 'desc' : 'asc';
            updateTagsModalSortButtonIcon();
            renderTagsModal();
            // Adjust position after rendering
            setTimeout(() => {
                adjustTagsModalPosition();
            }, 10);
        }

        function updateTagsModalSortButtonIcon() {
            const sortAscIcon = document.getElementById('tagsModalSortAscIcon');
            const sortDescIcon = document.getElementById('tagsModalSortDescIcon');
            if (sortAscIcon && sortDescIcon) {
                if (tagsModalSortOrder === 'asc') {
                    sortAscIcon.style.display = 'block';
                    sortDescIcon.style.display = 'none';
                } else {
                    sortAscIcon.style.display = 'none';
                    sortDescIcon.style.display = 'block';
                }
            }
        }

        function selectTagsModalFolder(folderId) {
            tagsModalSelectedFolderId = folderId === 'none' ? 'none' : folderId;
            renderTagsModal();
            // Adjust position after rendering
            setTimeout(() => {
                adjustTagsModalPosition();
            }, 10);
        }
        
        function navigateToTagsModalFolder(folderId) {
            // Change to folders view mode
            tagsModalViewMode = 'folders';
            const foldersBtn = document.getElementById('tagsModalViewFoldersBtn');
            const tagsBtn = document.getElementById('tagsModalViewTagsBtn');
            if (foldersBtn) foldersBtn.classList.add('active');
            if (tagsBtn) tagsBtn.classList.remove('active');
            
            // Select the folder
            selectTagsModalFolder(folderId);
            
            // Scroll to make the folder visible in the left column
            setTimeout(() => {
                const foldersColumn = document.getElementById('tagsModalFoldersColumn');
                const folderElement = foldersColumn ? foldersColumn.querySelector(`[data-folder-id="${folderId === 'none' ? 'none' : folderId}"]`) : null;
                
                if (folderElement && foldersColumn) {
                    // Calculate the position of the folder relative to the scrollable container
                    // We need to account for all parent elements up to the foldersColumn
                    let totalOffsetTop = 0;
                    let currentElement = folderElement;
                    
                    // Traverse up to calculate the total offset from the top of foldersColumn
                    while (currentElement && currentElement !== foldersColumn) {
                        totalOffsetTop += currentElement.offsetTop;
                        currentElement = currentElement.offsetParent;
                        
                        // If we've gone outside the foldersColumn, we need to stop
                        if (currentElement && !foldersColumn.contains(currentElement)) {
                            // We've reached a parent outside foldersColumn, so we need to subtract
                            // the offset of foldersColumn itself
                            const foldersColumnOffset = foldersColumn.offsetTop;
                            totalOffsetTop = totalOffsetTop - foldersColumnOffset;
                            break;
                        }
                    }
                    
                    // Alternative simpler approach: use getBoundingClientRect
                    const folderRect = folderElement.getBoundingClientRect();
                    const columnRect = foldersColumn.getBoundingClientRect();
                    
                    // Calculate how much we need to scroll
                    // The difference between where the folder is and where we want it (top of visible area)
                    const currentScrollTop = foldersColumn.scrollTop;
                    const folderTopInColumn = folderRect.top - columnRect.top + currentScrollTop;
                    
                    // Scroll to position the folder at the very top of the visible area
                    foldersColumn.scrollTop = Math.max(0, folderTopInColumn);
                }
            }, 100);
        }

        function renderTagsModal() {
            // Render in tags modal
            const foldersColumn = document.getElementById('tagsModalFoldersColumn');
            const tagsColumn = document.getElementById('tagsModalTagsColumn');
            const allTagsColumn = document.getElementById('tagsModalAllTagsColumn');
            
            if (!foldersColumn || !tagsColumn || !allTagsColumn) {
                return;
            }
            
            // Update sort button icon
            updateTagsModalSortButtonIcon();
            
            if (tagsModalViewMode === 'tags') {
                // Show all tags in a flat list
                foldersColumn.style.display = 'none';
                tagsColumn.style.display = 'none';
                allTagsColumn.style.display = 'flex';
                
                if (tags.length === 0) {
                    allTagsColumn.innerHTML = '<div style="color: #94a3b8; font-size: 13px; padding: 12px; text-align: center;">No tags yet. Create your first tag in the profile!</div>';
                    return;
                }

                let html = '';
                // Filter and sort tags alphabetically
                let filteredTags = tags;
                if (tagsModalSearchTerm.trim()) {
                    const searchLower = tagsModalSearchTerm.toLowerCase().trim();
                    filteredTags = tags.filter(tag => tag.name.toLowerCase().includes(searchLower));
                }
                const sortedTags = [...filteredTags].sort((a, b) => {
                    const comparison = a.name.localeCompare(b.name);
                    return tagsModalSortOrder === 'asc' ? comparison : -comparison;
                });
                
                if (sortedTags.length === 0) {
                    allTagsColumn.innerHTML = '<div style="color: #94a3b8; font-size: 13px; padding: 12px; text-align: center;">No tags found</div>';
                    return;
                }
                
                sortedTags.forEach((tag, index) => {
                    const folder = folders.find(f => f.id === tag.folderId);
                    const isLast = index === sortedTags.length - 1;
                    const isSelected = selectedTagsForTask.includes(tag.id);
                    const selectedStyle = isSelected ? 'background: #dbeafe; border: 1px solid #3b82f6;' : 'background: #ffffff;';
                    html += `
                        <div class="tag-item" data-tag-id="${tag.id}" onclick="toggleTagSelection(${tag.id})" style="display: flex; align-items: center; gap: 8px; padding: 6px; ${selectedStyle} border-radius: 4px; margin-bottom: ${isLast ? '0' : '4px'}; transition: background 0.2s ease; cursor: pointer; position: relative;">
                            <div style="width: 10px; height: 10px; border-radius: 50%; background-color: ${tag.color || '#3b82f6'}; flex-shrink: 0;"></div>
                            <span style="flex: 1; color: #1e293b; font-size: 13px;">${escapeHtml(tag.name)}</span>
                            ${folder ? `<span onclick="navigateToTagsModalFolder(${folder.id}); event.stopPropagation();" style="font-size: 11px; color: ${folder.color || '#64748b'}; padding: 2px 6px; background: ${folder.color || '#64748b'}20; border-radius: 3px; border: 1px solid ${folder.color || '#64748b'}; cursor: pointer; transition: all 0.2s ease;" onmouseover="this.style.color='${folder.color || '#64748b'}'; this.style.borderColor='${folder.color || '#64748b'}'; this.style.filter='brightness(1.2) saturate(1.3)'" onmouseout="this.style.color='${folder.color || '#64748b'}'; this.style.borderColor='${folder.color || '#64748b'}'; this.style.filter='none'">${escapeHtml(folder.name.toUpperCase())}</span>` : ''}
                        </div>
                    `;
                });
                allTagsColumn.innerHTML = html;
                // Adjust modal height after rendering
                setTimeout(() => {
                    adjustTagsModalPosition();
                }, 10);
                return;
            }
            
            // View mode: folders
            foldersColumn.style.display = 'flex';
            tagsColumn.style.display = 'flex';
            allTagsColumn.style.display = 'none';
            
            if (tags.length === 0 && folders.length === 0) {
                foldersColumn.innerHTML = '';
                tagsColumn.innerHTML = '<div style="color: #94a3b8; font-size: 13px; padding: 12px; text-align: center;">No tags or folders yet. Create your first folder or tag in the profile!</div>';
                return;
            }

            // Render folders in left column
            const tagsWithoutFolder = tags.filter(tag => !tag.folderId);
            const allFoldersForSorting = [...folders];
            
            if (tagsWithoutFolder.length > 0) {
                allFoldersForSorting.push({
                    id: 'none',
                    name: 'TAGS WITHOUT FOLDER',
                    color: '#000000',
                    userId: null
                });
            }
            
            const sortedFolders = allFoldersForSorting.sort((a, b) => {
                const aTagsCount = a.id === 'none' 
                    ? tagsWithoutFolder.length 
                    : tags.filter(tag => tag.folderId === a.id).length;
                const bTagsCount = b.id === 'none' 
                    ? tagsWithoutFolder.length 
                    : tags.filter(tag => tag.folderId === b.id).length;
                
                if (aTagsCount !== bTagsCount) {
                    return bTagsCount - aTagsCount;
                }
                
                return a.name.localeCompare(b.name);
            });
            
            let foldersHtml = '';
            sortedFolders.forEach(folder => {
                const isNoneFolder = folder.id === 'none';
                const folderTags = isNoneFolder 
                    ? tagsWithoutFolder 
                    : tags.filter(tag => tag.folderId === folder.id).sort((a, b) => a.name.localeCompare(b.name));
                const folderColor = folder.color || '#64748b';
                const isSelected = isNoneFolder ? tagsModalSelectedFolderId === 'none' : tagsModalSelectedFolderId === folder.id;
                
                foldersHtml += `
                    <div class="folder-item" data-folder-id="${folder.id}" onclick="selectTagsModalFolder(${isNoneFolder ? "'none'" : folder.id})" style="
                        padding: 10px 12px;
                        background: ${isSelected ? folderColor + '25' : folderColor + '15'};
                        border-radius: 6px;
                        border-left: 3px solid ${folderColor};
                        border-right: 1px solid ${isSelected ? folderColor : '#e2e8f0'};
                        border-top: 1px solid ${isSelected ? folderColor : '#e2e8f0'};
                        border-bottom: 1px solid ${isSelected ? folderColor : '#e2e8f0'};
                        cursor: pointer;
                        transition: all 0.2s ease;
                        width: 100%;
                        box-sizing: border-box;
                        min-height: 60px;
                        display: flex;
                        flex-direction: column;
                        justify-content: center;
                        position: relative;
                    ">
                        <div style="font-weight: 600; color: ${folderColor}; font-size: 13px; margin-bottom: 3px; word-wrap: break-word; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; line-height: 1.3;">${escapeHtml(folder.name.toUpperCase())}</div>
                        <div style="font-size: 10px; color: #64748b; font-weight: 500;">${folderTags.length} ${folderTags.length === 1 ? 'tag' : 'tags'}</div>
                    </div>
                `;
            });
            
            foldersColumn.innerHTML = foldersHtml;
            
            // Render tags in right column based on selection
            let tagsHtml = '';
            if (!tagsModalSelectedFolderId) {
                tagsColumn.innerHTML = '<div style="color: #94a3b8; font-size: 13px; padding: 12px; text-align: center;">Select a folder to view its tags</div>';
            } else if (tagsModalSelectedFolderId === 'none') {
                let filteredTagsWithoutFolder = tagsWithoutFolder;
                if (tagsModalSearchTerm.trim()) {
                    const searchLower = tagsModalSearchTerm.toLowerCase().trim();
                    filteredTagsWithoutFolder = tagsWithoutFolder.filter(tag => tag.name.toLowerCase().includes(searchLower));
                }
                
                if (filteredTagsWithoutFolder.length === 0) {
                    tagsColumn.innerHTML = '<div style="color: #94a3b8; font-size: 13px; padding: 12px; text-align: center;">' + (tagsModalSearchTerm.trim() ? 'No tags found' : 'NO TAGS WITHOUT FOLDER') + '</div>';
                } else {
                    const sortedTagsWithoutFolder = [...filteredTagsWithoutFolder].sort((a, b) => {
                        const comparison = a.name.localeCompare(b.name);
                        return tagsModalSortOrder === 'asc' ? comparison : -comparison;
                    });
                    
                    sortedTagsWithoutFolder.forEach((tag, index) => {
                        const isLast = index === sortedTagsWithoutFolder.length - 1;
                        const isSelected = selectedTagsForTask.includes(tag.id);
                        const selectedStyle = isSelected ? 'background: #dbeafe; border: 1px solid #3b82f6;' : 'background: #ffffff;';
                        tagsHtml += `
                            <div class="tag-item" data-tag-id="${tag.id}" onclick="toggleTagSelection(${tag.id})" style="display: flex; align-items: center; gap: 8px; padding: 6px; ${selectedStyle} border-radius: 4px; margin-bottom: ${isLast ? '0' : '4px'}; transition: background 0.2s ease; cursor: pointer; position: relative;">
                                <div style="width: 10px; height: 10px; border-radius: 50%; background-color: ${tag.color || '#3b82f6'}; flex-shrink: 0;"></div>
                                <span style="flex: 1; color: #1e293b; font-size: 13px;">${escapeHtml(tag.name)}</span>
                            </div>
                        `;
                    });
                    tagsColumn.innerHTML = tagsHtml;
                }
            } else {
                const selectedFolder = folders.find(f => f.id === tagsModalSelectedFolderId);
                if (selectedFolder) {
                    let folderTags = tags.filter(tag => tag.folderId === tagsModalSelectedFolderId);
                    if (tagsModalSearchTerm.trim()) {
                        const searchLower = tagsModalSearchTerm.toLowerCase().trim();
                        folderTags = folderTags.filter(tag => tag.name.toLowerCase().includes(searchLower));
                    }
                    
                    if (folderTags.length === 0) {
                        tagsColumn.innerHTML = '<div style="color: #94a3b8; font-size: 13px; padding: 12px; text-align: center;">' + (tagsModalSearchTerm.trim() ? 'No tags found' : 'This folder is empty') + '</div>';
                    } else {
                        const sortedFolderTags = [...folderTags].sort((a, b) => {
                            const comparison = a.name.localeCompare(b.name);
                            return tagsModalSortOrder === 'asc' ? comparison : -comparison;
                        });
                        
                        sortedFolderTags.forEach((tag, index) => {
                            const isLast = index === sortedFolderTags.length - 1;
                            const isSelected = selectedTagsForTask.includes(tag.id);
                            const selectedStyle = isSelected ? 'background: #dbeafe; border: 1px solid #3b82f6;' : 'background: #ffffff;';
                            tagsHtml += `
                                <div class="tag-item" data-tag-id="${tag.id}" onclick="toggleTagSelection(${tag.id})" style="display: flex; align-items: center; gap: 8px; padding: 6px; ${selectedStyle} border-radius: 4px; margin-bottom: ${isLast ? '0' : '4px'}; transition: background 0.2s ease; cursor: pointer; position: relative;">
                                    <div style="width: 10px; height: 10px; border-radius: 50%; background-color: ${tag.color || '#3b82f6'}; flex-shrink: 0;"></div>
                                    <span style="flex: 1; color: #1e293b; font-size: 13px;">${escapeHtml(tag.name)}</span>
                                </div>
                            `;
                        });
                        tagsColumn.innerHTML = tagsHtml;
                    }
                }
            }
            
            // Update folder select in new tag form
            updateTagsModalFolderSelect();
            
            // Adjust modal height after rendering
            setTimeout(() => {
                adjustTagsModalPosition();
            }, 10);
        }
        
        function adjustTagsModalPosition() {
            const modal = document.getElementById('tagsModalOverlay');
            const modalContent = modal ? modal.querySelector('.task-modal') : null;
            
            if (!modal || !modalContent || !modal.classList.contains('active')) {
                return;
            }
            
            // Fixed height: 500px
            const fixedHeight = 500;
            modalContent.style.height = fixedHeight + 'px';
            modalContent.style.maxHeight = fixedHeight + 'px';
            
            // Position relative to task creation modal
            const modalWidth = 450;
            let targetX = 600;
            let targetY = 80;
            
            const taskModal = document.getElementById('taskModalOverlay');
            if (taskModal && taskModal.classList.contains('active')) {
                const taskModalContent = taskModal.querySelector('.task-modal');
                if (taskModalContent) {
                    const taskModalRect = taskModalContent.getBoundingClientRect();
                    // Position to the right of the task modal with 16px gap
                    targetX = taskModalRect.right + 16;
                    // Align bottom of tags modal with bottom of task modal
                    targetY = taskModalRect.bottom - fixedHeight;
                }
            }
            
            // Ensure modal doesn't go off screen
            const maxX = window.innerWidth - modalWidth - 20;
            const maxY = window.innerHeight - fixedHeight - 20;
            
            const finalX = Math.min(targetX, maxX);
            const finalY = Math.min(targetY, maxY);
            
            modalContent.style.left = Math.max(finalX, 20) + 'px';
            modalContent.style.top = Math.max(finalY, 20) + 'px';
        }

        async function deleteFolder(folderId) {
            try {
                const res = await fetch(`${FOLDERS_URL}/${folderId}`, {
                    method: 'DELETE',
                    headers: getAuthHeaders()
                });

                if (res.status === 401) {
                    logout();
                    return;
                }

                if (!res.ok) throw new Error();
                showMessage('Folder deleted', 'success');
                await loadFolders();
                await loadTags();
            } catch (error) {
                showMessage('Error deleting folder', 'error');
            }
        }

        async function deleteTag(tagId) {
            try {
                const res = await fetch(`${TAGS_URL}/${tagId}`, {
                    method: 'DELETE',
                    headers: getAuthHeaders()
                });

                if (res.status === 401) {
                    logout();
                    return;
                }

                if (!res.ok) throw new Error();
                showMessage('Tag deleted', 'success');
                await loadTags();
                await loadTasks();
            } catch (error) {
                showMessage('Error deleting tag', 'error');
            }
        }

        async function loadTasks() {
            try {
                const res = await fetch(API_URL, {
                    headers: getAuthHeaders()
                });
                
                if (res.status === 401) {
                    logout();
                    showMessage('Session expired. Please login again.', 'error');
                    return;
                }
                
                tasks = await res.json();
                renderTasks();
                updateTagSelect(); // Update tag select to show recently used tags
            } catch (error) {
                showMessage('Error loading tasks', 'error');
            }
        }

        function formatDate(dateStr) {
            if (!dateStr) return '';
            const date = new Date(dateStr + 'T00:00:00');
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = date.getFullYear();
            return `${day}/${month}/${year}`;
        }

        function setFilter(filter) {
            currentFilter = filter;
            
            // Update button states
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`filter${filter.charAt(0).toUpperCase() + filter.slice(1)}`).classList.add('active');
            
            // Update title
            const title = document.getElementById('tasksTitle');
            if (filter === 'pending') {
                title.textContent = 'Pending Tasks';
            } else if (filter === 'completed') {
                title.textContent = 'Completed Tasks';
            } else {
                title.textContent = 'All Tasks';
            }
            
            renderTasks();
        }

        function handleSearch() {
            const searchInput = document.getElementById('taskSearch');
            searchQuery = searchInput.value.trim().toLowerCase();
            renderTasks();
        }

        function renderTasks() {
            const list = document.getElementById('taskList');
            let filteredTasks = [];
            
            if (currentFilter === 'pending') {
                filteredTasks = tasks.filter(task => !task.completed);
            } else if (currentFilter === 'completed') {
                filteredTasks = tasks.filter(task => task.completed);
            } else {
                filteredTasks = tasks;
            }
            
            if (filteredTasks.length === 0) {
                let message = '';
                if (searchQuery) {
                    message = 'No tasks found matching your search';
                } else if (currentFilter === 'pending') {
                    message = 'No pending tasks';
                } else if (currentFilter === 'completed') {
                    message = 'No completed tasks';
                } else {
                    message = 'No tasks';
                }
                list.innerHTML = `<div class="empty">${message}</div>`;
                return;
            }

            // Apply search filter if there's a search query
            if (searchQuery) {
                filteredTasks = filteredTasks.filter(task => {
                    const titleMatch = task.title && task.title.toLowerCase().includes(searchQuery);
                    const descMatch = task.description && task.description.toLowerCase().includes(searchQuery);
                    return titleMatch || descMatch;
                });
            }

            // Sort all tasks by date (closest to today first, regardless of past/future)
            filteredTasks.sort((a, b) => {
                // Tasks without dates go to the end
                if (!a.dueDate && !b.dueDate) return 0;
                if (!a.dueDate) return 1;
                if (!b.dueDate) return -1;

                const dateA = new Date(a.dueDate + (a.dueTime ? 'T' + a.dueTime : 'T00:00:00'));
                const dateB = new Date(b.dueDate + (b.dueTime ? 'T' + b.dueTime : 'T00:00:00'));
                
                return dateA - dateB; // Ascending: closest to today first
            });

            // Build HTML with all tasks sorted by date
            let html = '';
            
            if (filteredTasks.length > 0) {
                html += filteredTasks.map(task => `
                <div class="task-item ${task.completed ? 'completed' : ''}" data-id="${task.id}">
                    <div class="task-header">
                        <input type="checkbox" ${task.completed ? 'checked' : ''} 
                               onchange="toggleTask(${task.id}, this.checked)">
                        <div class="task-title">${escapeHtml(task.title)}</div>
                    </div>
                    ${task.description ? `<div class="task-info">${escapeHtml(task.description)}</div>` : ''}
                    ${task.tags && task.tags.length > 0 ? `<div style="margin-top: 5px; display: flex; flex-wrap: wrap; gap: 5px;">${task.tags.map(tag => `<span class="tag" style="background-color: ${tag.color || '#007bff'}">${escapeHtml(tag.name)}</span>`).join('')}</div>` : ''}
                    ${task.image ? `<div style="margin-top: 10px;"><img src="${escapeHtml(getProtectedImageUrl(task.image))}" alt="Task image" class="task-image" onclick="window.open('${escapeHtml(getProtectedImageUrl(task.image))}', '_blank')"></div>` : ''}
                    ${task.dueDate || task.dueTime ? `
                        <div class="task-date-time">
                            ${task.dueDate ? ` ${formatDate(task.dueDate)}` : ''}
                            ${task.dueTime ? ` ${task.dueTime}` : ''}
                        </div>
                    ` : ''}
                    <div class="edit-form" id="editForm-${task.id}">
                        <input type="text" id="editTitle-${task.id}" value="${escapeHtml(task.title)}" style="margin-bottom: 10px; width: 100%;">
                        <textarea id="editDesc-${task.id}" style="margin-bottom: 10px; width: 100%;">${escapeHtml(task.description || '')}</textarea>
                        <div class="date-time-row">
                            <input type="date" id="editDate-${task.id}" value="${task.dueDate || ''}">
                            <input type="time" id="editTime-${task.id}" value="${task.dueTime || ''}">
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label style="font-size: 12px; display: block; margin-bottom: 5px;">Tags</label>
                            <div id="editTags-${task.id}" class="tag-select-row" style="max-height: 150px; overflow-y: auto;">
                                <!-- Tags will be populated when editing -->
                            </div>
                        </div>
                        <div style="margin-bottom: 10px;">
                            <label style="font-size: 12px; display: block; margin-bottom: 5px;">Image</label>
                            <div class="image-upload-area" onclick="document.getElementById('editImage-${task.id}').click()">
                                <input type="file" id="editImage-${task.id}" accept="image/*" onchange="previewEditImage(${task.id})">
                                <div id="editImagePreviewText-${task.id}">${task.image ? 'Click to change or drag & drop image' : 'Click to select or drag & drop image'}</div>
                                <img class="image-preview" id="editImagePreview-${task.id}" ${task.image ? `src="${escapeHtml(getProtectedImageUrl(task.image))}"` : 'style="display: none;"'}>
                                <button type="button" class="remove-image-btn" id="removeEditImageBtn-${task.id}" ${task.image ? '' : 'style="display: none;"'} onclick="event.stopPropagation(); removeEditImage(${task.id})">Remove</button>
                            </div>
                            <small style="color: #666; font-size: 11px; display: block; margin-top: 5px;">Formats allowed: JPEG, JPG, PNG, GIF, WEBP (max 5MB)</small>
                        </div>
                        <div class="task-actions">
                            <button class="btn-small" onclick="saveEdit(${task.id})">Save</button>
                            <button class="btn-small" onclick="cancelEdit(${task.id})">Cancel</button>
                        </div>
                    </div>
                    <div class="task-actions">
                        <button class="btn-small btn-edit" onclick="editTask(${task.id})">Edit</button>
                        <button class="btn-small btn-delete" onclick="deleteTask(${task.id})">Delete</button>
                    </div>
                </div>
            `).join('');
            }

            list.innerHTML = html;

            // Scroll to top to show future tasks (closest to today)
            list.scrollTop = 0;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Convert old image paths to protected paths and add auth token
        function getProtectedImageUrl(imagePath) {
            if (!imagePath) return '';
            let protectedPath = imagePath;
            // Convert /uploads/filename to /api/uploads/filename
            if (imagePath.startsWith('/uploads/')) {
                protectedPath = imagePath.replace('/uploads/', '/api/uploads/');
            }
            // Add token as query parameter for authentication
            if (protectedPath.startsWith('/api/uploads/') && token) {
                const separator = protectedPath.includes('?') ? '&' : '?';
                return `${protectedPath}${separator}token=${encodeURIComponent(token)}`;
            }
            // Already in protected format or absolute URL
            return protectedPath;
        }

        // Function to validate image format
        function isValidImageFormat(file) {
            const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
            const allowedExtensions = ['.jpeg', '.jpg', '.png', '.gif', '.webp'];
            
            // Check MIME type (jpeg and jpg both use image/jpeg)
            const fileType = file.type.toLowerCase();
            const isValidMimeType = allowedTypes.includes(fileType) || fileType === 'image/jpg';
            
            // Check file extension as fallback
            const fileName = file.name.toLowerCase();
            const hasValidExtension = allowedExtensions.some(ext => fileName.endsWith(ext));
            
            return isValidMimeType || hasValidExtension;
        }

        // Image handling - File input
        document.getElementById('taskImage').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                if (isValidImageFormat(file)) {
                handleImageFile(file, 'taskImagePreview', 'imagePreviewText', 'removeImageBtn');
                } else {
                    const fileName = file.name;
                    const fileExtension = fileName.substring(fileName.lastIndexOf('.')).toUpperCase() || 'unknown';
                    showMessage(`This file format is not accepted (${fileExtension})`, 'error');
                    // Clear the input
                    document.getElementById('taskImage').value = '';
                }
            }
        });

        // Drag and drop for task image
        const taskImageArea = document.querySelector('.image-upload-area');
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            taskImageArea.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            taskImageArea.addEventListener(eventName, function() {
                this.classList.add('drag-over');
            }, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            taskImageArea.addEventListener(eventName, function() {
                this.classList.remove('drag-over');
            }, false);
        });

        taskImageArea.addEventListener('drop', function(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            if (files.length > 0) {
                const file = files[0];
                if (isValidImageFormat(file)) {
                    handleImageFile(file, 'taskImagePreview', 'imagePreviewText', 'removeImageBtn');
                    // Also set the file input
                    const dataTransfer = new DataTransfer();
                    dataTransfer.items.add(file);
                    document.getElementById('taskImage').files = dataTransfer.files;
                } else {
                    const fileName = file.name;
                    const fileExtension = fileName.substring(fileName.lastIndexOf('.')).toUpperCase() || 'unknown';
                    showMessage(`This file format is not accepted (${fileExtension})`, 'error');
                }
            }
        }, false);

        function handleImageFile(file, previewId, textId, removeBtnId) {
            const reader = new FileReader();
            reader.onload = function(e) {
                document.getElementById(previewId).src = e.target.result;
                document.getElementById(previewId).style.display = 'block';
                document.getElementById(textId).style.display = 'none';
                document.getElementById(removeBtnId).style.display = 'block';
            };
            reader.readAsDataURL(file);
        }

        function removeTaskImage() {
            document.getElementById('taskImage').value = '';
            document.getElementById('taskImagePreview').style.display = 'none';
            document.getElementById('imagePreviewText').style.display = 'block';
            document.getElementById('removeImageBtn').style.display = 'none';
            currentTaskImage = null;
        }

        function previewEditImage(taskId) {
            const file = document.getElementById(`editImage-${taskId}`).files[0];
            if (file) {
                if (isValidImageFormat(file)) {
                handleEditImageFile(file, taskId);
                } else {
                    const fileName = file.name;
                    const fileExtension = fileName.substring(fileName.lastIndexOf('.')).toUpperCase() || 'unknown';
                    showMessage(`This file format is not accepted (${fileExtension})`, 'error');
                    // Clear the input
                    document.getElementById(`editImage-${taskId}`).value = '';
                }
            }
        }

        function handleEditImageFile(file, taskId) {
            const reader = new FileReader();
            reader.onload = function(e) {
                document.getElementById(`editImagePreview-${taskId}`).src = e.target.result;
                document.getElementById(`editImagePreview-${taskId}`).style.display = 'block';
                document.getElementById(`editImagePreviewText-${taskId}`).style.display = 'none';
                document.getElementById(`removeEditImageBtn-${taskId}`).style.display = 'block';
            };
            reader.readAsDataURL(file);
        }

        // Setup drag and drop for edit forms dynamically
        function setupEditImageDragDrop(taskId) {
            const editImageArea = document.querySelector(`#editImage-${taskId}`).closest('.image-upload-area');
            if (!editImageArea || editImageArea.dataset.dragSetup === 'true') return;
            
            editImageArea.dataset.dragSetup = 'true';

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                editImageArea.addEventListener(eventName, preventDefaults, false);
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                editImageArea.addEventListener(eventName, function() {
                    this.classList.add('drag-over');
                }, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                editImageArea.addEventListener(eventName, function() {
                    this.classList.remove('drag-over');
                }, false);
            });

            editImageArea.addEventListener('drop', function(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (isValidImageFormat(file)) {
                        handleEditImageFile(file, taskId);
                        // Also set the file input
                        const dataTransfer = new DataTransfer();
                        dataTransfer.items.add(file);
                        document.getElementById(`editImage-${taskId}`).files = dataTransfer.files;
                    } else {
                        const fileName = file.name;
                        const fileExtension = fileName.substring(fileName.lastIndexOf('.')).toUpperCase() || 'unknown';
                        showMessage(`This file format is not accepted (${fileExtension})`, 'error');
                    }
                }
            }, false);
        }

        function removeEditImage(taskId) {
            document.getElementById(`editImage-${taskId}`).value = '';
            const preview = document.getElementById(`editImagePreview-${taskId}`);
            const task = tasks.find(t => t.id === taskId);
            preview.src = getProtectedImageUrl(task.image || '');
            preview.style.display = task.image ? 'block' : 'none';
            document.getElementById(`editImagePreviewText-${taskId}`).style.display = task.image ? 'none' : 'block';
            document.getElementById(`removeEditImageBtn-${taskId}`).setAttribute('data-removed', 'true');
            document.getElementById(`removeEditImageBtn-${taskId}`).style.display = 'none';
        }

        async function uploadImage(file) {
            const formData = new FormData();
            formData.append('image', file);

            try {
                const res = await fetch(UPLOAD_URL, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    },
                    body: formData
                });

                if (res.status === 401) {
                    logout();
                    return null;
                }

                const data = await res.json();
                if (!res.ok) {
                    showMessage(data.message || 'Error uploading image', 'error');
                    return null;
                }

                return data.path;
            } catch (error) {
                showMessage('Error uploading image', 'error');
                return null;
            }
        }

        document.getElementById('taskForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const title = document.getElementById('taskTitle').value.trim();
            const description = document.getElementById('taskDescription').value.trim();
            const dueDate = document.getElementById('taskDate').value;
            const dueTime = document.getElementById('taskTime').value;
            
            // Get selected tag IDs
            // Use selectedTagsForTask
            const tagIds = selectedTagsForTask;
            
            const imageFile = document.getElementById('taskImage').files[0];

            if (!title) {
                showMessage('Title is required', 'error');
                return;
            }

            try {
                // Upload image if provided
                let imagePath = null;
                if (imageFile) {
                    imagePath = await uploadImage(imageFile);
                    if (!imagePath) return; // Error already shown
                }

                const res = await fetch(API_URL, {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ title, description, dueDate, dueTime, tagIds, image: imagePath })
                });

                if (res.status === 401) {
                    logout();
                    showMessage('Session expired. Please login again.', 'error');
                    return;
                }

                if (!res.ok) throw new Error();
                showMessage('Task created', 'success');
                resetTaskForm();
                closeTaskModal();
                await loadTasks();
            } catch (error) {
                showMessage('Error creating task', 'error');
            }
        });

        async function toggleTask(id, completed) {
            try {
                const task = tasks.find(t => t.id === id);
                const res = await fetch(`${API_URL}/${id}`, {
                    method: 'PUT',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({
                        title: task.title,
                        description: task.description,
                        completed: completed ? 1 : 0,
                        dueDate: task.dueDate,
                        dueTime: task.dueTime,
                        tagIds: task.tags ? task.tags.map(t => t.id) : (task.tagId ? [task.tagId] : []),
                        image: task.image
                    })
                });
                
                if (res.status === 401) {
                    logout();
                    return;
                }
                
                if (!res.ok) throw new Error();
                await loadTasks();
            } catch (error) {
                showMessage('Error updating task', 'error');
                await loadTasks();
            }
        }

        function editTask(id) {
            const form = document.getElementById(`editForm-${id}`);
            form.classList.add('active');
            
            // Populate tag checkboxes
            const tagContainer = document.getElementById(`editTags-${id}`);
            const task = tasks.find(t => t.id === id);
            const taskTagIds = task.tags ? task.tags.map(t => t.id) : (task.tagId ? [task.tagId] : []);
            
            tagContainer.innerHTML = '';
            tags.forEach(tag => {
                const tagItem = document.createElement('div');
                tagItem.className = 'tag-checkbox-item';
                const isSelected = taskTagIds.includes(tag.id);
                if (isSelected) {
                    tagItem.classList.add('selected');
                }
                tagItem.dataset.tagId = tag.id;
                tagItem.innerHTML = `
                    <span class="tag-color-indicator" style="background-color: ${tag.color || '#007bff'}"></span>
                    <span>${escapeHtml(tag.name)}</span>
                    <input type="checkbox" value="${tag.id}" id="editTagCheck-${id}-${tag.id}" ${isSelected ? 'checked' : ''}>
                `;
                
                tagItem.addEventListener('click', function(e) {
                    if (e.target.tagName !== 'INPUT') {
                        const checkbox = this.querySelector('input[type="checkbox"]');
                        checkbox.checked = !checkbox.checked;
                        this.classList.toggle('selected', checkbox.checked);
                    }
                });
                
                const checkbox = tagItem.querySelector('input[type="checkbox"]');
                checkbox.addEventListener('change', function() {
                    tagItem.classList.toggle('selected', this.checked);
                });
                
                tagContainer.appendChild(tagItem);
            });
            
            // Setup drag and drop for edit image
            setTimeout(() => setupEditImageDragDrop(id), 100);
            
            // Reset image removal flag
            const removeBtn = document.getElementById(`removeEditImageBtn-${id}`);
            if (removeBtn) {
                removeBtn.removeAttribute('data-removed');
            }
        }

        function cancelEdit(id) {
            const form = document.getElementById(`editForm-${id}`);
            form.classList.remove('active');
            
            // Reset image input
            const imageInput = document.getElementById(`editImage-${id}`);
            if (imageInput) {
                imageInput.value = '';
                const task = tasks.find(t => t.id === id);
                const preview = document.getElementById(`editImagePreview-${id}`);
                if (preview && task.image) {
                    preview.src = getProtectedImageUrl(task.image);
                    preview.style.display = 'block';
                    document.getElementById(`editImagePreviewText-${id}`).style.display = 'none';
                    document.getElementById(`removeEditImageBtn-${id}`).style.display = 'block';
                } else if (preview) {
                    preview.style.display = 'none';
                    document.getElementById(`editImagePreviewText-${id}`).style.display = 'block';
                    document.getElementById(`removeEditImageBtn-${id}`).style.display = 'none';
                }
            }
        }

        async function saveEdit(id) {
            const title = document.getElementById(`editTitle-${id}`).value.trim();
            const description = document.getElementById(`editDesc-${id}`).value.trim();
            const dueDate = document.getElementById(`editDate-${id}`).value;
            const dueTime = document.getElementById(`editTime-${id}`).value;
            // Get selected tag IDs
            const selectedTags = Array.from(document.querySelectorAll(`#editTags-${id} input[type="checkbox"]:checked`))
                .map(cb => parseInt(cb.value));
            const tagIds = selectedTags.length > 0 ? selectedTags : [];
            
            const imageFile = document.getElementById(`editImage-${id}`).files[0];
            const task = tasks.find(t => t.id === id);

            if (!title) {
                showMessage('Title is required', 'error');
                return;
            }

            try {
                // Upload new image if provided, otherwise keep existing or remove if explicitly removed
                let imagePath = task.image || null;
                const removeBtn = document.getElementById(`removeEditImageBtn-${id}`);
                
                if (imageFile) {
                    // New image uploaded
                    imagePath = await uploadImage(imageFile);
                    if (!imagePath) return; // Error already shown
                } else if (removeBtn && removeBtn.getAttribute('data-removed') === 'true') {
                    // Image was explicitly removed
                    imagePath = null;
                }

                const res = await fetch(`${API_URL}/${id}`, {
                    method: 'PUT',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ title, description, completed: task.completed, dueDate, dueTime, tagIds, image: imagePath })
                });
                
                if (res.status === 401) {
                    logout();
                    return;
                }
                
                if (!res.ok) throw new Error();
                showMessage('Task updated', 'success');
                cancelEdit(id);
                await loadTasks();
            } catch (error) {
                showMessage('Error updating task', 'error');
            }
        }

        async function deleteTask(id) {
            if (!confirm('Delete this task?')) return;
            try {
                const res = await fetch(`${API_URL}/${id}`, {
                    method: 'DELETE',
                    headers: getAuthHeaders()
                });
                
                if (res.status === 401) {
                    logout();
                    return;
                }
                
                if (!res.ok) throw new Error();
                showMessage('Task deleted', 'success');
                await loadTasks();
            } catch (error) {
                showMessage('Error deleting task', 'error');
            }
        }
        // Close context menu when clicking outside
        document.addEventListener('click', (e) => {
            const contextMenu = document.getElementById('contextMenu');
            if (contextMenu && contextMenu.style.display !== 'none') {
                // Check if click is outside the context menu
                if (!contextMenu.contains(e.target)) {
                    hideContextMenu();
                }
            }
        }, true); // Use capture phase to catch clicks early

        // Close context menu on escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                hideContextMenu();
            }
        });
    </script>
</body>
</html>
